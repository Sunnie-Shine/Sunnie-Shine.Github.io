
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>向向的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="向向">
    

    
    <meta name="description" content="This is my blog...">
<meta property="og:type" content="website">
<meta property="og:title" content="向向的博客">
<meta property="og:url" content="https:&#x2F;&#x2F;sunnie-shine.github.io&#x2F;index.html">
<meta property="og:site_name" content="向向的博客">
<meta property="og:description" content="This is my blog...">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="向向的博客" title="向向的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="向向的博客">向向的博客</a></h1>
				<h2 class="blog-motto">Console.WriteLine(&#34;Hello, ^_^&#34;);</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">全部文档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:Sunnie-Shine.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/18/csharplang-complement-04-enum/" title="C# 语法查漏补缺系列（4）：枚举类型" itemprop="url">C# 语法查漏补缺系列（4）：枚举类型</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-18T11:47:37.000Z" itemprop="datePublished"> 发表于 2019-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="枚举类型是什么？"><a href="#枚举类型是什么？" class="headerlink" title="枚举类型是什么？"></a>枚举类型是什么？</h2><p>在搞懂枚举类型之前，我们先要搞清楚，什么是<strong>枚举</strong>（Enumeration）。枚举是一种机制，它将整数用更容易理解的自定义词汇表达，来表现数据的灵活性。最常见的枚举的使用就是表示执行程序的状态了。比如，程序分启动、运行、退出三种大状态，所以我们可以把它们三个情况用 <code>Start</code>、<code>Running</code> 和 <code>End</code> 三个单词表达出来。但计算机并不识别单词，所以我们不得不用数字表达，于是，我们便建立起了数字和单词的关系和映射。</p>
<p>在使用的时候，我们就不必使用枯燥的数字来表示一个运行状态了。这就是枚举的产生。当然，<strong>枚举类型</strong>（Enumeration Type）就是这个枚举的名称，比如程序状态类型 <code>ExecutingStatus</code>。</p>
<h2 id="枚举类型的使用"><a href="#枚举类型的使用" class="headerlink" title="枚举类型的使用"></a>枚举类型的使用</h2><h3 id="枚举类型的语法"><a href="#枚举类型的语法" class="headerlink" title="枚举类型的语法"></a>枚举类型的语法</h3><p>在 C# 里，枚举类型是这么书写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符] enum 枚举类型名[ : 整数类型]</span><br><span class="line">&#123;</span><br><span class="line">    枚举值1[ = 值1],</span><br><span class="line">    枚举值2[ = 值2],</span><br><span class="line">    枚举值3[ = 值3],</span><br><span class="line">    ...</span><br><span class="line">    枚举值n[ = 值n,]</span><br><span class="line">&#125;[;]</span><br></pre></td></tr></table></figure>
<p>其中所有的中括号内的东西都可以不写。比如，程序执行状态的类型 <code>ExecutingStatus</code> 就可以表达为</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutingStatus : <span class="keyword">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    Start, <span class="comment">// Default value is 0.</span></span><br><span class="line">    Running, <span class="comment">// Default value is Start + 1.</span></span><br><span class="line">    End, <span class="comment">// Default value is Running + 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你不写第一个变量的枚举的等价数值时，系统默认为你分配为 0，当然你也可以给出一个非 0 数据来表示起始数值。但尽量使用 0，因为枚举如果没有 0 的话，后面写代码就可能会产生很隐蔽的错误，这一点我们稍后说明。另外，后面的任意一个数据不给等价数值的时候，默认是它前一个枚举类型的数值再加上 1 的结果。比如这里的三个枚举值分别就是 0、1、2。</p>
<p>另外，如果枚举类型的数值用得不是很大，我们为了节约内存，甚至可以为其设置枚举类型的数值范围，方法是在枚举类型名后跟上一个冒号，加上指定类型的范围的整数类型名称（可以是 <code>byte</code>、<code>sbyte</code>、<code>int</code>、<code>short</code>、<code>long</code>、<code>uint</code>、<code>ushort</code>、<code>ulong</code> 这些类型）。</p>
<p>由于整个大括号的关系，整体末尾的分号可以不写。</p>
<p>那么，我们就可以使用枚举类型了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (thread.CurrentStatus == ExecutingStatus.Running)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Means the current status is running.</span></span><br><span class="line">    <span class="comment">// We can do something such as abort the execution.</span></span><br><span class="line">    thread.Abort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上面这种用法（只是一个举例），如果当前线程还在跑的话，我们就中止这个线程。</p>
<h3 id="枚举类型的原理"><a href="#枚举类型的原理" class="headerlink" title="枚举类型的原理"></a>枚举类型的原理</h3><p>就枚举类型这一点来说，它可能比 Java 做得好。Java 的枚举类型是通过类实现的，这样使得枚举这种轻量级的东西变得非常“臃肿”。而 C# 里，枚举类型用的是值类型。在 C# 里，值类型认为是一些基础的、原子的类型（即元素不可拆分）。而这种类型通过调用栈来分配内存，使得比类的内存分配要快一点，而且要轻量级一些。</p>
<p>实际上，枚举可以在某种程度上认为是整数类型的等价封装。因为 C# 只是提供了一种将有意义的标识符来替换掉原本枯燥的数字，所以可以这么认为。</p>
<h3 id="枚举类型、数值和字符串三者的转换"><a href="#枚举类型、数值和字符串三者的转换" class="headerlink" title="枚举类型、数值和字符串三者的转换"></a>枚举类型、数值和字符串三者的转换</h3><p>枚举类型在编译期之前，可以使用显隐式转换，转换为对应的数值类型。比如，前文我们把 <code>ExecutingStatus</code> 类型设置为 <code>byte</code> 类型的数值范围，因为它只有三个字段，所以我们完全可以用 <code>byte</code> 内的元素搞定这些数值的枚举情况。</p>
<p>而从另外一个角度出发，这种类型的所有字段数值都将可以被转换为 <code>byte</code> 类型的数据。所以，C# 语法层面提供了隐式转换和显式转换两种模式。</p>
<p>当你想要把一个数值转换为枚举类型的时候，这个时候由于转换结果不定（比如我尝试把 3 转换为 <code>ExecutingStatus</code> 类型时，由于枚举里不存在该数值，所以这种转换是不安全的），所以 C# 提供的是显式转换，即需要写出转换类型符号来转换到指定类型）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutingStatus es = (ExecutingStatus)<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>显然，这样的转换是没有意义的。不过，在执行这句话的时候，是不会产生错误的；而相反，反而在使用的时候，它才会报错。</p>
<p>而且，枚举类型转数值的时候，依然用的是显式转换。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)ExecutingStatus.Running;</span><br></pre></td></tr></table></figure>
<p>所以，如果遇到想把上述枚举类型转为一个字符类型 <code>char</code> 的时候，你就必须写成这样：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="keyword">byte</span>)ExecutingStatus.Running;</span><br></pre></td></tr></table></figure>
<p>因为枚举类型是不允许直接转换为其它类型的，所以你需要先转换为 <code>byte</code> 后，然后再用 <code>byte</code> 转为 <code>char</code> 的强制转换来实现。当然，这种用法很少见。</p>
<p>另外，如果你想要把枚举类型的文本标识符获取到的话，可以使用 <code>ToString</code> 方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> s = ExecutingStatus.Running.ToString();</span><br></pre></td></tr></table></figure>
<p>但如果你需要把字符串等价的枚举类型字段转换过去的话，就得使用 <code>Enum.Parse</code> 或 <code>Enum.TryParse</code> 方法了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Way of usage 1:</span></span><br><span class="line">ExecutingStatus es1</span><br><span class="line">    = (ExecutingStatus)Enum.Parse(<span class="keyword">typeof</span>(ExecutingStatus), <span class="string">"Start"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 2:</span></span><br><span class="line">ExecutingStatus es2 = Enum.Parse&lt;ExecutingStatus&gt;(<span class="string">"Start"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 3:</span></span><br><span class="line"><span class="keyword">if</span> (Enum.TryParse(<span class="keyword">typeof</span>(ExecutingStatus), <span class="string">"Start"</span>, <span class="keyword">out</span> <span class="keyword">object</span> o))</span><br><span class="line">&#123;</span><br><span class="line">    ExecutingStatus es3 = (ExecutingStatus)o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 4:</span></span><br><span class="line"><span class="comment">// Same as type 3, but using pattern matching to get es3 value.</span></span><br><span class="line"><span class="keyword">if</span> (Enum.TryParse(<span class="keyword">typeof</span>(ExecutingStatus), <span class="string">"Start"</span>, <span class="keyword">out</span> <span class="keyword">object</span> o)</span><br><span class="line">    &amp;&amp; o <span class="keyword">is</span> ExecutingStatus es4)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es4` is assigned successfully.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 5:</span></span><br><span class="line"><span class="keyword">if</span> (Enum.TryParse&lt;ExecutingStatus&gt;(<span class="string">"Start"</span>, <span class="keyword">out</span> ExecutingStatus es5))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es5` is assigned successfully.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这五种书写格式都可以读取字符串，但前面两种当字符串书写不正确的时候，会抛出转换失败的异常，后面三种则不会。但第三种、第四种模式都会通过拆箱，因为是把 <code>object</code> 引用类型拆箱为 <code>ExecutingStatus</code> 值类型。第五种则使用的是泛型转换，这样的话 <code>es5</code> 的类型一定是和泛型参数类型一样的类型。</p>
<blockquote>
<p>所以你可以从这里看到，由于类型是一样的，所以泛型参数和 <code>out</code> 参数的类型里的任意一个都可以不写，即要么</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Enum.TryParse(<span class="string">"Start"</span>, <span class="keyword">out</span> ExecutingStatus es5))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es5` is assigned successfully.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要么</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Enum.TryParse&lt;ExecutingStatus&gt;(<span class="string">"Start"</span>, <span class="keyword">out</span> <span class="keyword">var</span> es5))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es5` is assigned successfully.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种写法均可。</p>
</blockquote>
<p>以上就介绍了枚举类型转数字和字符串，以及数字和字符串转枚举类型的方法。</p>
<h3 id="枚举类型的运算符重载"><a href="#枚举类型的运算符重载" class="headerlink" title="枚举类型的运算符重载"></a>枚举类型的运算符重载</h3><p>这才是最骚的，C# 由于和 Java 机制不同的关系，C# 具有操作符重载的说法。在语法层面上，C# 提供了枚举类型和整数的加减法重载。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es1 = ExecutingStatus.Running + <span class="number">1</span>; <span class="comment">// ExecutingStatus.End</span></span><br><span class="line"><span class="keyword">var</span> es2 = ExecutingStatus.Running - <span class="number">1</span>; <span class="comment">// ExecutingStatus.Start</span></span><br></pre></td></tr></table></figure>
<p>这样可以设置类似于“偏移量”的概念。</p>
<p>不过，还可以为其设置枚举类型之间的位运算，这一点我们在后面这一节作详细讲解。</p>
<h2 id="位域枚举类型"><a href="#位域枚举类型" class="headerlink" title="位域枚举类型"></a>位域枚举类型</h2><h3 id="位域枚举类型的定义"><a href="#位域枚举类型的定义" class="headerlink" title="位域枚举类型的定义"></a>位域枚举类型的定义</h3><p>位域枚举类型指的是，当某种类型的所有字段可以被复用的时候，我们可以使用二进制位表示每一种情况，这样可以允许一些“多角色”的情况出现。比如，Linux 操作文件的时候，文件具有可读可写可执行三大操作，这三种操作互不冲突，且文件可以具有多个属性，即某个文件完全可以实现可读和可写，或可读可写可执行都允许的情况。这种枚举类型是一种特殊的枚举类型，它就被称为<strong>位域枚举类型</strong>（Flag Enumeration Type）。</p>
<h3 id="位域枚举类型的使用"><a href="#位域枚举类型的使用" class="headerlink" title="位域枚举类型的使用"></a>位域枚举类型的使用</h3><p>这种现象，我们只需要做两步工作就可以把一个枚举类型该为位域枚举类型：为其添加 <code>FlagsAttribute</code> 特性，并为每一个枚举数值赋值二进制位对应每一种情况的数值结果：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FileTypes</span><br><span class="line">&#123;</span><br><span class="line">    Readable = <span class="number">1</span>,</span><br><span class="line">    Writable = <span class="number">2</span>,</span><br><span class="line">    Executable = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便完成了枚举类型转为位域枚举类型。</p>
<blockquote>
<p><code>FlagsAttribute</code> 特性可写可不写，下面的内容完全都可以用。但加上它可以让编译器辅助我们查找出一些隐藏的错误。</p>
</blockquote>
<p>这种类型有什么好处呢？由于每一个数值都是二进制位表示的，所以我们完全可以使用位运算符来操作它们，获取一个对象的固有枚举类型集。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft = FileTypes.Readable | FileTypes.Writable;</span><br></pre></td></tr></table></figure>
<p>这样就可以表示一个可读或者可写的行为，到时候就可以获取具体的枚举情况，查看它是否具有指定枚举情况。比如，我们需要判断文件是否有可读属性，如果可以读取，就执行读取操作；如果可写，则执行写入操作，等等。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = someFile;</span><br><span class="line"><span class="keyword">if</span> (file.FileTypes.HasFlag(FileTypes.Executable))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execute file.</span></span><br><span class="line">    file.Execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The file cannot be executed.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"The file cannot be executed."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以调用系统自带的 <code>HasFlag</code> 方法来表示当前对象是否具有当前枚举值的行为。</p>
<p>诸如上述的操作。</p>
<p>当然，你可以写另外的一种枚举数值模式，二进制字面量。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FileTypes</span><br><span class="line">&#123;</span><br><span class="line">    None       = <span class="number">0b000</span>,</span><br><span class="line">    Readable   = <span class="number">0b001</span>,</span><br><span class="line">    Writable   = <span class="number">0b010</span>,</span><br><span class="line">    Executable = <span class="number">0b100</span>,</span><br><span class="line">    All        = <span class="number">0b111</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，更易于看懂和理解每一个数值的对应情况，甚至你可以提供特殊的枚举数值，比如文件什么操作都不给，或者什么操作都有。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file.FileTypes == FileTypes.All)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Here all operation can be done.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用位运算来简化操作"><a href="#使用位运算来简化操作" class="headerlink" title="使用位运算来简化操作"></a>使用位运算来简化操作</h3><p>在前文里，我们使用了 <code>|</code> 位或运算符号来合并两种枚举情况，表示或的关系，二进制层面的话，数值则表示为 <code>0b110</code>，即可读可写的两个属性二进制位被置为 1。实际上，所有位运算符都适用于位域枚举类型。</p>
<h4 id="位与运算符-amp"><a href="#位与运算符-amp" class="headerlink" title="位与运算符 &amp;"></a>位与运算符 <code>&amp;</code></h4><p>可以使用位与运算符 <code>&amp;</code> 来表示两者都需要同时满足。它一般用于判断某个位域数值是否被包含在里面。比如，我们可以通过 <code>HasFlag</code> 方法查看当前位域数值是否包含 <code>FileTypes.Executable</code>，也可以通过该符号实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ft &amp; FileTypes.Executable) == FileTypes.Executable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The file can be executed.</span></span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它完全等价于</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ft.HasFlag(FileTypes.Executable))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The file can be executed.</span></span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位或运算符"><a href="#位或运算符" class="headerlink" title="位或运算符 |"></a>位或运算符 <code>|</code></h4><p>在前文已经说过，它用于表示两个枚举类型的或的关系，即同时给两个二进制位赋上值，甚至也可以为一个已经给定一部分二进制位的情况的枚举对象赋值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft1 = FileTypes.Readable | FileTypes.Writable;</span><br><span class="line"><span class="keyword">var</span> ft2 = ft1 | FileTypes.Executable;</span><br></pre></td></tr></table></figure>
<p>当前，请注意的是，二进制实现层面来说，哪怕你已经包含了某个属性，调用 <code>|</code> 运算符也不会清除掉它们。</p>
<h4 id="位异或运算符"><a href="#位异或运算符" class="headerlink" title="位异或运算符 ^"></a>位异或运算符 <code>^</code></h4><p>位异或运算符 <code>^</code> 用于反转一个二进制位。如果这个二进制位想从 1 变为 0，或者 0 变为 1，可以通过这个方式实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft = FileTypes.All ^ FileType.Executable;</span><br></pre></td></tr></table></figure>
<p>这样的话，就可以表示去掉可执行的二进制位的位域值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft = FileTypes.None ^ FileType.Executable;</span><br></pre></td></tr></table></figure>
<p>这样就可以表示一个文件仅仅可被执行。</p>
<h4 id="位取反运算符"><a href="#位取反运算符" class="headerlink" title="位取反运算符 ~"></a>位取反运算符 <code>~</code></h4><p>位取反运算符 <code>~</code> 可以表示把一个二进制位反转，但这种用法并不常见，因为它甚至会把所有其它的二进制位都反转过来，所以显得非常没有意义。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E8%AF%AD%E6%B3%95/">C♯.语法</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E8%AF%AD%E6%B3%95/C%E2%99%AF-%E8%AF%AD%E6%B3%95-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/">C♯.语法.查漏补缺</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/17/async-await-fundamental/" title="Async/await 关键字原理" itemprop="url">Async/await 关键字原理</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-17T08:59:40.000Z" itemprop="datePublished"> 发表于 2019-11-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="async-和-await-是什么？"><a href="#async-和-await-是什么？" class="headerlink" title="async 和 await 是什么？"></a><code>async</code> 和 <code>await</code> 是什么？</h2><p>在我们平时 C# 的使用之中，总会遇到很多超时和耗时操作，比如获取网页的 HTTP 源代码。</p>
<blockquote>
<p>可能你会问：获取源代码有什么用吗？其实获取这个源代码，可以用来解析并生成模板，来处理这个源代码内部的文字信息，可以达到爬虫的效果。比如我想要联网查英语单词的意思，因为没有提供数据库，所以我们可以使用页面自带的返回的效果来找到所有查到的单词都用得到的 div 块，然后去看它们的共同之处，进而通过代码，来获取单词的释义，然后反馈回来。</p>
</blockquote>
<p>那么，这些操作显然都有可能出现，而如果我们在使用 UI 设计的时候调用它们，就很容易出现卡死、导致 UI 无法响应，并卡死的操作。于是，我们出现了这个模式。这个模式用于异步处理这些耗时操作，会在线程池里取出一个空闲的后台线程，并执行这个操作；执行完毕后，将会默认回到主线程继续执行，这样一来，你就会发现，由于单独开了一个线程处理，所以 UI 不卡了。这就是这两个关键字带给我们的使用效果。</p>
<blockquote>
<p>上述说法还有点细节的问题，不要当杠精，我们在下文里会慢慢阐述原理，并重新解释这些内容。</p>
</blockquote>
<h2 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a>书写格式</h2><p>来看一下，我们如何对一个方法使用 <code>async</code> 和 <code>await</code> 模式。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Project</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">FetchHttpFile</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> client.GetStringAsync(<span class="keyword">new</span> Uri(<span class="string">"www.baidu.com"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个写法便是使用了 <code>async</code> 和 <code>await</code> 模式。首先，我们将耗时的操作写到方法名前面。一般按照规范，<code>async</code> 将放到类型前面，挨着类型名称。其次，类型请使用 <code>Task&lt;T&gt;</code> 方式，其中的泛型参数 <code>T</code> 使用这个类型的本应该返回的返回值类型。比如，这个实例想要通过这个模式来获取 HTTP 文件的内容，那么我们将可以使用这个模式来获取。</p>
<h2 id="编译器处理后的样子"><a href="#编译器处理后的样子" class="headerlink" title="编译器处理后的样子"></a>编译器处理后的样子</h2><p>上述的短短十多行代码将会生成下面的编译器处理后的代码。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">using</span> System.Security;</span><br><span class="line"><span class="keyword">using</span> System.Security.Permissions;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">[<span class="meta">assembly: CompilationRelaxations(8)</span>]</span><br><span class="line">[<span class="meta">assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)</span>]</span><br><span class="line">[<span class="meta">assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)</span>]</span><br><span class="line">[<span class="meta">assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyVersion(<span class="meta-string">"0.0.0.0"</span>)</span>]</span><br><span class="line">[<span class="meta">module: UnverifiableCode</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Project</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">StructLayout(LayoutKind.Auto)</span>]</span><br><span class="line">    [<span class="meta">CompilerGenerated</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">struct</span> &lt;FetchHttpFile&gt;d__0 : IAsyncStateMachine</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> AsyncTaskMethodBuilder&lt;<span class="keyword">string</span>&gt; &lt;&gt;t__builder;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TaskAwaiter&lt;<span class="keyword">string</span>&gt; &lt;&gt;u__1;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line">            <span class="keyword">string</span> result;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                TaskAwaiter&lt;<span class="keyword">string</span>&gt; awaiter;</span><br><span class="line">                <span class="keyword">if</span> (num != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    awaiter = <span class="keyword">new</span> HttpClient().GetStringAsync(<span class="keyword">new</span> Uri(<span class="string">"www.baidu.com"</span>)).GetAwaiter();</span><br><span class="line">                    <span class="keyword">if</span> (!awaiter.IsCompleted)</span><br><span class="line">                    &#123;</span><br><span class="line">                        num = (&lt;&gt;<span class="number">1</span>__state = <span class="number">0</span>);</span><br><span class="line">                        &lt;&gt;u__1 = awaiter;</span><br><span class="line">                        &lt;&gt;t__builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiter, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    awaiter = &lt;&gt;u__1;</span><br><span class="line">                    &lt;&gt;u__1 = <span class="keyword">default</span>(TaskAwaiter&lt;<span class="keyword">string</span>&gt;);</span><br><span class="line">                    num = (&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                result = awaiter.GetResult();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception exception)</span><br><span class="line">            &#123;</span><br><span class="line">                &lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">                &lt;&gt;t__builder.SetException(exception);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">            &lt;&gt;t__builder.SetResult(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IAsyncStateMachine.MoveNext()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in MoveNext</span></span><br><span class="line">            <span class="keyword">this</span>.MoveNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetStateMachine</span>(<span class="params">IAsyncStateMachine stateMachine</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            &lt;&gt;t__builder.SetStateMachine(stateMachine);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine</span></span><br><span class="line">            <span class="keyword">this</span>.SetStateMachine(stateMachine);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AsyncStateMachine(typeof(&lt;FetchHttpFile&gt;d__0))</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">FetchHttpFile</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        &lt;FetchHttpFile&gt;d__0 stateMachine = <span class="keyword">default</span>(&lt;FetchHttpFile&gt;d__0);</span><br><span class="line">        stateMachine.&lt;&gt;t__builder = AsyncTaskMethodBuilder&lt;<span class="keyword">string</span>&gt;.Create();</span><br><span class="line">        stateMachine.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">        AsyncTaskMethodBuilder&lt;<span class="keyword">string</span>&gt; &lt;&gt;t__builder = stateMachine.&lt;&gt;t__builder;</span><br><span class="line">        &lt;&gt;t__builder.Start(<span class="keyword">ref</span> stateMachine);</span><br><span class="line">        <span class="keyword">return</span> stateMachine.&lt;&gt;t__builder.Task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以仔细看看，这个代码一下就陡增到 90 多行了。我们下面来分析一下它们。</p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>下面我们来看下这个生成的代码，到底内部执行了哪些操作，又处理了什么。</p>
<h3 id="原方法部分"><a href="#原方法部分" class="headerlink" title="原方法部分"></a>原方法部分</h3><p>先来看原本的方法部分，虽然它会调用内部的执行操作，不过我们先看它是为了逻辑框架上更清晰。</p>
<p>这一部分有点难搞的地方在于，它的类型全部都是没办法看的，因为这些内容基本上都是被编译器自动生成了，所以我们只能翻译一下。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AsyncStateMachine(typeof(StateMachine))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">FetchHttpFile</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stateMachine = <span class="keyword">default</span>(StateMachine); <span class="comment">// StateMachine</span></span><br><span class="line">    stateMachine.builder = AsyncTaskMethodBuilder&lt;<span class="keyword">string</span>&gt;.Create();</span><br><span class="line">    stateMachine.state = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> builder = stateMachine.builder; <span class="comment">// AsyncTaskMethodBuilder&lt;string&gt;</span></span><br><span class="line">    builder.Start(<span class="keyword">ref</span> stateMachine);</span><br><span class="line">    <span class="keyword">return</span> stateMachine.builder.Task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就比较清晰了。首先，它在原本的代码方法体里插入了一个状态机。什么是状态机呢？这一点的详细内容我们稍后再说，这里先大致认为是一个专门记录执行获取 HTTP 文件操作状态的一个对象。然后，</p>
<h3 id="状态机部分"><a href="#状态机部分" class="headerlink" title="状态机部分"></a>状态机部分</h3><p>这段代码稍微困难一些，因为内容非常多。我们只能一块一块地进行解读。</p>
<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>首先是三个字段：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line"><span class="keyword">public</span> AsyncTaskMethodBuilder&lt;<span class="keyword">string</span>&gt; &lt;&gt;t__builder;</span><br><span class="line"><span class="keyword">private</span> TaskAwaiter&lt;<span class="keyword">string</span>&gt; &lt;&gt;u__1;</span><br></pre></td></tr></table></figure>
<p>第一个字段是一个整数类型的变量，它在编译期间生成，用来表示一会儿执行状态机期间的状态；第二个字段叫 <code>builder</code>，是异步任务方法的生成器对象，它带有一个泛型参数 <code>string</code>，就是我们最初异步返回任务类型的方法里那个泛型参数；第三个字段表示一个 awaiter。awaiter 这个词到现在都不好翻译，你只需要知道 await 是异步等待的关键字，那么加入 -er 后缀就是表示这个任务需要异步等待的那一个对象。</p>
<blockquote>
<p>注意，awaiter 是一个对象，它专门用于等待异步任务的完成。</p>
</blockquote>
<h4 id="MoveNext-方法"><a href="#MoveNext-方法" class="headerlink" title="MoveNext 方法"></a><code>MoveNext</code> 方法</h4><p>下面来看下 <code>MoveNext</code> 方法。让我们先把里面一些写起来诡异的字段名改一下写法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">string</span> result;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        TaskAwaiter&lt;<span class="keyword">string</span>&gt; awaiter;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            awaiter = <span class="keyword">new</span> HttpClient().GetStringAsync(<span class="keyword">new</span> Uri(<span class="string">"www.baidu.com"</span>)).GetAwaiter();</span><br><span class="line">            <span class="keyword">if</span> (!awaiter.IsCompleted)</span><br><span class="line">            &#123;</span><br><span class="line">                num = <span class="keyword">this</span>.state = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">this</span>.awaiter = awaiter;</span><br><span class="line">                <span class="keyword">this</span>.builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiter, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            awaiter = <span class="keyword">this</span>.awaiter;</span><br><span class="line">            <span class="keyword">this</span>.awaiter = <span class="keyword">default</span>(TaskAwaiter&lt;<span class="keyword">string</span>&gt;);</span><br><span class="line">            num = (<span class="keyword">this</span>.state = <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = awaiter.GetResult();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">this</span>.builder.SetException(exception);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">this</span>.builder.SetResult(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，它把状态机里生成的字段 <code>state</code> 取出来，赋值给 <code>num</code> 作为后面使用，然后创建了一个结果对象，就是我们需要提取的 HTTP 网页文件源代码的字符串变量 <code>result</code> 此时还没有赋值。</p>
<p>然后，它尝试去执行获取操作，写在 <code>try</code> 块里。在 <code>try</code> 块里，有一个异步等待的对象 <code>awaiter</code>，在当前状态不为 0 的时候，进入 <code>if</code> 条件，然后去获取异步 <code>Task&lt;T&gt;</code> 对象的 awaiter。这个时候，就可以把这个 <code>Task&lt;T&gt;</code> 的 awaiter 获取出来，赋值给这个 <code>try</code> 块里的临时变量了。</p>
<p>然后此时，立马判断这个执行任务是否已经完成。如果没有执行完毕，就会进入内部的 <code>if</code> 块，然后将当前状态和这个临时变量 <code>num</code> 改为 0，并把 awaiter 赋值给当前对象里的字段 <code>awaiter</code> 上去；接着，它会调用字段 <code>builder</code> 对象的 <code>AwaiteUnsafeOnCompleted</code> 方法，这个方法是用来做什么呢？查看资料就可以发现，它实际上是一个处理任务调度的方法，当指定的 awaiter 已经完成的时候，它就会调度任务，去执行处理下一个行为。</p>
<p>不过，在外层条件判断里，还有一个 <code>else</code> 块，它表示当任务已经完成的时候的行为。当任务已经在此处都做完了，就会立马把这些基本的执行行为的信息（诸如 <code>awaiter</code>、<code>state</code> 等等信息）统统赋值一次。</p>
<p>最后，不论是走 <code>if</code> 还是走 <code>else</code> 块，最终都会到 <code>result = awaiter.GetResult()</code> 操作，获取最终结果。注意，这个方法内部的实现较复杂，我们最终阐述一下结果：<strong>这个方法最终会阻塞程序执行，直到结果被得到</strong>。</p>
<p>当然，如果执行期间出现了异常，<code>catch</code> 块就会捕捉到，然后把异常塞进 <code>builder</code> 里去，并且把此时执行状态置为 -2，表示退出。</p>
<p>最后，除了 awaiter 尚未完成和抛出异常时，会立马退出程序之外，都会执行到最后，将状态改为 -2，表示退出，并且把结果塞进 <code>builder</code> 里，状态机的行为便执行完毕。可以从代码里看到，整个行为好像并没有体现出启动后台线程的操作，这些都在 <code>builder</code> 里为我们做好了一切，就在 <code>AwaitUnsafeOnCompleted</code> 方法的执行里。另外，状态机本身是不会抛出不被处理的异常的，哪怕出现异常，都是都被 <code>catch</code> 块处理，然后塞进 <code>builder</code> 里，推后到后续的某个位置才会抛出。</p>
<p>总的来说：<strong><code>async</code>/<code>await</code> 模式会在编译期生成一个状态机，记录当前操作执行状态。在执行过程之中，判断异步任务是否在此时此刻已经执行完毕。如果没有的话，就会把这个任务一并塞进 <code>builder</code> 里等待稍后的执行，但如果完成了的话，就会立马取出其结果，并塞进 <code>builder</code> 里，留着后续调用的时候获取结果；当最终没有完成的任务，将会立马放到最后开始执行，并阻塞当前线程</strong>。</p>
<h4 id="剩下的三个方法"><a href="#剩下的三个方法" class="headerlink" title="剩下的三个方法"></a>剩下的三个方法</h4><p>那么，剩下的三个方法的实现其实就不难理解了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IAsyncStateMachine.MoveNext()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in MoveNext</span></span><br><span class="line">    <span class="keyword">this</span>.MoveNext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DebuggerHidden</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetStateMachine</span>(<span class="params">IAsyncStateMachine stateMachine</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.builder.SetStateMachine(stateMachine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine</span></span><br><span class="line">    <span class="keyword">this</span>.SetStateMachine(stateMachine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>MoveNext</code> 方法用于实现接口对象，而它为什么非要单独用显式实现接口的模式来单独在外部创建对象，并在此实现呢？这是为了更好的封装性。这个方法一般不希望被外部调用，所以这里采用显式实现接口的方式，让外部必须知晓实现模型才能进行转换和调用；而内部调用到的 <code>MoveNext</code> 方法也是一个 <code>private</code> 的方法，这保证了完整的内部封装的模式。</p>
<p>然后在 <code>SetStateMachine</code> 方法里，它直接调用 <code>builder</code> 字段的 <code>SetStateMachine</code> 方法来设置状态机，最后使用显式实现接口的模式达到封装性。</p>
<h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><p>在前文里，我们完整描述了整个 <code>async</code> 方法在编译器里生成的所有内容的执行思路和操作，但依然存在一些逻辑上的漏洞。</p>
<h3 id="1、异步方法真的是异步执行和被调用的吗？"><a href="#1、异步方法真的是异步执行和被调用的吗？" class="headerlink" title="1、异步方法真的是异步执行和被调用的吗？"></a>1、异步方法真的是异步执行和被调用的吗？</h3><p>在调用层面来看，你可以观察到 <code>FetchHttpFile</code> 方法本被标注了 <code>async</code> 关键字，后面被编译器生成代码之后，却不见了。这告诉了我们，<code>async</code> 关键字只是一个关键字，它用于标记方法是可能被异步执行的，但调用期间却是同步调用的，并没有产生任何的后台线程。</p>
<p>不过，在执行的时候，系统会为其单独分配一个后台线程，执行内部“耗时”的操作。</p>
<h3 id="2、讲了这么多，都在说-async-关键字了，那么-await-关键字呢？"><a href="#2、讲了这么多，都在说-async-关键字了，那么-await-关键字呢？" class="headerlink" title="2、讲了这么多，都在说 async 关键字了，那么 await 关键字呢？"></a>2、讲了这么多，都在说 <code>async</code> 关键字了，那么 <code>await</code> 关键字呢？</h3><p>在原本的写法里，我们使用 <code>await</code> 关键字，嵌入到 <code>FetchHttpFile</code> 方法里，最后它生成了一大堆东西。不过 <code>await</code> 在前文并没有得到很好的解释。实际上，在前文里我们是不是提到了一个 <code>Task&lt;T&gt;</code> 对象，来表达一个可能耗时的任务？是的，这便是这个地方执行的关键。<code>await</code> 关键字用于获取这个任务里的 awaiter，然后取出执行结果。注意，在此期间，程序是开了后台线程并执行了这一套工作的，所以只是你看不到罢了。</p>
<p>当获取结果后，主线程才会继续向下执行，在前面没有执行完毕获取结果的操作前，主线程都是被阻塞的，而往往 UI 界面的线程都跑在主线程上，所以 UI 界面此时该卡死还卡死。后续我会介绍如何避免这样的情况发生。</p>
<h3 id="3、异步操作会造成程序死锁吗？"><a href="#3、异步操作会造成程序死锁吗？" class="headerlink" title="3、异步操作会造成程序死锁吗？"></a>3、异步操作会造成程序死锁吗？</h3><p>当线程处理期间，就一定存在死锁的问题需要我们去解决。死锁指的是两个或更多线程在相互调用期间，各自由于都在等待对方执行完毕释放资源，导致程序使用的全部的线程都在等待，引起的卡死的现象。在异步操作里，我们为了保证程序能够完整执行下去，而且还不阻塞主线程，就会使用 <code>async</code> 关键字来让耗时的操作去单独跑在一个线程上（注意，此时依旧我们会等待线程执行完毕反馈结果），然后最后执行完毕后，把结果取出来并显示的行为。这涉及到两个线程了。如果是 UI 线程的话，如果像是上面这么简单的实现，会不会出现死锁呢？</p>
<p>很遗憾，上述例子是会产生死锁的。它满足了整个项目产生死锁的两大充分不必要条件：</p>
<ol>
<li>调用 <code>Wait</code> 方法（一个用于阻塞任务执行的方法）或 <code>Result</code> 属性（相当于 <code>GetResult</code> 方法）的位置处于 UI 线程上；</li>
<li>任务执行在其它的后台线程上，而并不在和 UI 一样的线程上。</li>
</ol>
<p>那么为什么是这两个条件就可能死锁呢？回顾一下线程死锁的四大必要条件：</p>
<ol>
<li><strong>互斥</strong>：资源只能被一个资源使用，其它资源必须等待释放后才能继续使用；</li>
<li><strong>请求和保持</strong>：由于请求资源而阻塞时，对已获得的资源保持不放；</li>
<li><strong>让权等待</strong>：在执行期间，已获得的资源在末使用完之前，都不能被强行剥夺；</li>
<li><strong>循环等待</strong>：若干线程之间有循环的依赖关系。</li>
</ol>
<p>这四个条件是<strong>死锁的必要条件</strong>，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 观察上述两种说法就可以看出，<code>async</code> 执行模式是满足前三点的，而第四点到底是否满足呢？实际上是的，因为主线程（UI）会等待后台线程下载文件，而后台线程又会依赖主线程的执行（不然怎么可能单独跑一个后台线程呢），所以四大条件全部满足，必然是可能会存在死锁现象的发生的。</p>
<h3 id="4、我们应该如何修改代码去阻止可能产生的死锁呢？"><a href="#4、我们应该如何修改代码去阻止可能产生的死锁呢？" class="headerlink" title="4、我们应该如何修改代码去阻止可能产生的死锁呢？"></a>4、我们应该如何修改代码去阻止可能产生的死锁呢？</h3><p>为了避免线程死锁的问题，我们拥有一些合理的解决方案。不过先要我们来看下下面的问题。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Task <span class="title">RunAsync1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Some asynchronized operation.</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">RunAsync2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Some asynchronized operation.</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">RunAsync3</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Some asynchronized operation.</span></span><br><span class="line">    &#125;).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面三个方法里，哪个（或哪些）方法会可能产生死锁？</p>
<p>答案是，只有第 2 个会产生死锁，而第 1 个和第 3 个都不会。原因如下：</p>
<p>第一个压根就没有使用 <code>async</code> 和 <code>await</code> 关键字，这使得编译器并不会给我们产生状态机和一大堆异步执行行为，所以好比任务是同步完成的。既然是在同一个线程上，为什么会死锁呢？</p>
<p>第三个有 <code>async</code> 和 <code>await</code> 关键字，而后续我们配备了 <code>ConfigureAwait</code> 方法，以此来为这个任务的执行分配新的线程，并让后续的执行行为直接全跑在这个线程上。默认的话，<code>ConfigureAwait</code> 的参数是为 <code>true</code> 的，这意味着在后续执行的操作，会重新返回到主线程上。但刚才说过，返回主线程执行后续操作就必然存在死锁的问题，所以我们为其设置 <code>ConfigureAwait(false)</code> 的话，执行的操作就会跑到随机分配的新的线程里去搞定它们，这样一来，甚至 UI 线程都不用返回到主线程去做了，因为它们都在随机分配好的新线程里在做这些东西了。所以这个时候，它们在执行期间就不会产生死锁了。</p>
<blockquote>
<p>实际上，后续怎么返回到上一个执行调用方线程，是通过一个叫做 <code>SynchronizationContext</code> 对象来搞定的，直译就是同步上下文，它记录了线程执行的调用顺序：是谁调用了异步方法的执行，并在什么线程上执行的。这些信息都在这个同步上下文里可以找到。有了这个对象，我们就可以轻松反推找到原来的执行方的线程信息了，所以 C# 采用的是这种操作来返回到主线程。当然，UI 线程使用的是一个叫做 <code>DispatcherSynchronizationContext</code> 的对象来搞的，不过这一点你在初步学习的时候知道有这么一个东西存在就好了。</p>
<p>由于指定了 <code>ConfigureAwait(false)</code>，这意味着通知异步状态机 <code>AsyncMethodStateMachine</code> 并不需要使用设置好的 <code>SynchronizationContext</code>（对于 UI 线程，是 <code>DispatcherSynchronizationContext</code>）执行线程同步，而是使用默认的 <code>SynchronizationContext</code>，而默认行为是随便找个线程执行后面的代码。于是，<code>await Task.Run</code> 后面的代码便不需要返回原线程，也就不会发生第 2 种情况里的死锁问题。 </p>
</blockquote>
<p>所以，当你安装了 <a href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/" target="_blank" rel="noopener">Microsoft.CodeAnalysis.FxCopAnalyzers</a> 编译器后，你就会发现，编译器自动会为你提出警告 CA2007，告诉你请你在使用异步行为的时候在其后面配置 <code>ConfigureAwait(false)</code> 来达到避免死锁的目的。如果你是类库的编写者，注意此问题能够一定程度上防止逗比使用者出现死锁问题后喷你的类库写得不好。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.iasyncstatemachine?view=netframework-4.8" target="_blank" rel="noopener">IAsyncStateMachine 接口</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.asyncstatemachineattribute?view=netframework-4.8" target="_blank" rel="noopener">AsyncStateMachineAttribute 特性</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.taskawaiter?view=netframework-4.8" target="_blank" rel="noopener">TaskAwaiter 结构</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.asynctaskmethodbuilder.awaitunsafeoncompleted?view=netframework-4.8" target="_blank" rel="noopener">AwaitUnsafeOnCompleted<TAwaiter, TStateMachine> 方法</a></li>
<li><a href="https://blog.walterlv.com/post/deadlock-in-task-wait.html" target="_blank" rel="noopener">使用 Task.Wait()? 立即死锁</a>（博文）</li>
<li><a href="https://blog.walterlv.com/post/using-configure-await-to-avoid-deadlocks.html" target="_blank" rel="noopener">使用 ConfigureAwait(bool) 避免死锁</a>（博文）</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E5%85%B3%E9%94%AE%E5%AD%97/">C♯.关键字</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/C♯-编译器生成/">C♯.编译器生成</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/17/clang-04-switch-statement/" title="C 语言语法系列（4）：switch 语句" itemprop="url">C 语言语法系列（4）：switch 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-17T07:38:08.000Z" itemprop="datePublished"> 发表于 2019-11-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="if-的弊端"><a href="#if-的弊端" class="headerlink" title="if 的弊端"></a><code>if</code> 的弊端</h2><p>很多时候，<code>if</code> 给我们的使用带来了方便的地方，但是依旧有点丑的是，我们经常会用到同一个变量分情况讨论的时候，但 <code>if</code> 非要写成 <code>if</code> 串联的模式，这样就很丑。于是，我们引入了新的语法格式：<code>switch</code> 语句。</p>
<h2 id="switch-语句的写法"><a href="#switch-语句的写法" class="headerlink" title="switch 语句的写法"></a><code>switch</code> 语句的写法</h2><p>考虑如下 <code>if</code> 串联写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">    c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">    c = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">5</span>)</span><br><span class="line">    c = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    c = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<p>当我们需要判断相同的一个变量的不同数值时，我们可以考虑使用 <code>switch</code> 语句来书写，它在转换后是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        c = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        c = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        c = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// This one can not be written.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码里看到，它可能比原本的写法更臃肿了，但代码更清晰了。按照 <code>a</code> 分情况讨论。当 <code>a</code> 值为 2 的时候，执行 <code>c = 1</code> 的赋值操作；其它的同理。<code>default</code> 用来控制其它所有情况，类似于 <code>if</code> 里的 <code>else</code> 条件后没有其它判别情况时的执行操作。</p>
<p>还需要注意的是，每一个 <code>case</code> 语句的最后都有一个冒号，而且在每一个部分结束的时候，都有一个 <code>break</code> 语句作为结束（写法必须是 <code>break;</code>，即末尾带分号）。这是两个需要注意的地方。</p>
<p>另外，标签之间必须书写 <code>break</code> 是有道理的。如果不写它的话，语句就会贯穿到下一个部分去执行，所以不是非常好。但有些时候，我们也可以考虑使用这种特性来做事情。比如，我们获取 12 个月每一个月多少天的时候，可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (month)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"31\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"28\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"30\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Month value is not valid.\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// This one can not be written.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们暂且不考虑闰年还是平年，2 月分情况讨论的结果。这样的写法可以看到，像是 1、3、5、7、8、10、12 月，结果都是一样的，所以我们完全不必在中间给它加上 <code>break</code>。</p>
<p>当然，<code>default</code> 不一定要放在最后面。有些时候我们可能期望默认执行的情况和其中某个数值的执行情况是一样的，这个时候我们可以把 <code>default</code> 调整到前面去。</p>
<p>比如，我们需要在记录成绩等级（A 到 F）的时候，默认把其它情况和不及格显示成一样的结果（F），我们就可以这么做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">67</span>;</span><br><span class="line"><span class="keyword">switch</span> (score / <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"F\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"E\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"D\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"C\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"B\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">// Only for 100.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>switch</code> 的小括号里的东西可以是任意一个整数数值的表达式，比如这个例子里的值就是 <code>score / 10</code>，算出来等于 6。</p>
<blockquote>
<p>注意，之前说过，67 和 10 都是整数，所以计算的除法一定得到的结果是整数，故得到的 6.7 会被截断为 6，而且截断不是四舍五入。</p>
</blockquote>
<h2 id="贯穿标签的用法"><a href="#贯穿标签的用法" class="headerlink" title="贯穿标签的用法"></a>贯穿标签的用法</h2><p>在前文里，所有 <code>case</code> 语句 <code>default</code> 都被称为标签。当有些时候，我们迫不得已需要贯穿标签，所以出现了前文的合并同类项的类似格式。但有些时候，我们除了这种贯穿模式之外，还有一种情况可以这么用，即不写 <code>break</code> 语句。</p>
<p>给定 <code>month</code> 数值表示当前月份，求从 1 月份到这个月一共多少天（暂不考虑日期是多少）。那么代码可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (month)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        result += <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// Note this break sentence.</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        result = <span class="number">0</span>; <span class="comment">// We use 0 to let user know his input value is invalid.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以思考一下，为什么这种模式可以不写 <code>break</code> 语句。</p>
<h2 id="缺乏不等模式判断"><a href="#缺乏不等模式判断" class="headerlink" title="缺乏不等模式判断"></a>缺乏不等模式判断</h2><p><code>switch</code> 有一个缺点在于，它没有不等模式的判别，比如我们希望某个数字在 0 到 60 的时候是差， 61 到 80 的时候是中等，81 到 90 的时候是良好，91 到 100 是优秀。这个时候，我们只能使用 <code>if</code> 语句的串联，<code>switch</code> 很抱歉的是，在这一点并没有提供对应的语法判别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (score &lt;= <span class="number">60</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bad\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;= <span class="number">80</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Not bad\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;= <span class="number">90</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Awesome!\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Excellent!!\n"</span>);</span><br></pre></td></tr></table></figure>
<p>上述即可判断。你需要思考一点，为什么 <code>if</code> 判别里写的是 <code>score &lt;= 某数值</code> 呢？比如 61 到 80，不应该写成 <code>score &gt;= 61 &amp;&amp; score &lt;= 80</code> 才对吗？</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/16/hexo-mathjax-recovery/" title="Hexo 里关于 Mathjax 数学公式渲染问题的解决方案" itemprop="url">Hexo 里关于 Mathjax 数学公式渲染问题的解决方案</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-16T13:58:38.000Z" itemprop="datePublished"> 发表于 2019-11-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="为什么会出错？"><a href="#为什么会出错？" class="headerlink" title="为什么会出错？"></a>为什么会出错？</h2><p>因为内部使用的是 <code>marked</code> 的渲染模式，但它给出的渲染方式有点问题，导致最终渲染出现毛病。比如一个矩阵的渲染：</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
        1 & 2 & 3\\
        4 & 5 & 6
    \end{matrix}
\right)</script><p>就很有可能被渲染成</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
        1 & 2 & 3 \ 4 & 5 & 6
    \end{matrix}
\right)</script><p>如果你发现两个渲染结果完全一样，那么你的渲染就有问题；但是如果第一个是正常显示，但第二个不正常的话，那么就需要你仔细对比一下两个渲染的原 LaTeX 代码了。仔细对比就可以发现，第一个渲染正确的代码里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\left(</span><br><span class="line">    \begin&#123;matrix&#125;</span><br><span class="line">        1 &amp; 2 &amp; 3\\</span><br><span class="line">        4 &amp; 5 &amp; 6</span><br><span class="line">    \end&#123;matrix&#125;</span><br><span class="line">\right)</span><br></pre></td></tr></table></figure>
<p>的结尾处用的是双反斜杠 <code>\\</code>，表示换行；而下面错误渲染的公式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\left(</span><br><span class="line">    \begin&#123;matrix&#125;</span><br><span class="line">        1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6</span><br><span class="line">    \end&#123;matrix&#125;</span><br><span class="line">\right)</span><br></pre></td></tr></table></figure>
<p>却是一个反斜杠 <code>\</code>。这便是问题所在。在渲染的期间，不小心在使用正则表达式的时候替换错误了。现在我们来修复它。</p>
<h2 id="尝试修复"><a href="#尝试修复" class="headerlink" title="尝试修复"></a>尝试修复</h2><p>首先，我们需要在博客的文件夹下输入指定的卸载和安装命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br><span class="line">$ npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>进行卸载 <code>marked</code> 渲染和安装 <code>kramed</code> 的渲染。</p>
<blockquote>
<p>可能是我孤陋寡闻，不过我是偶然发现的，<code>mark</code> 和 <code>kram</code> 是一对镜面单词，即 <code>mark</code> 每个字母倒着读就是 <code>kram</code>……我估计设计者也是考虑到这样故意才取这个名的。</p>
</blockquote>
<p>然后，打开 <code>node_modules\kramed\lib\rules\inline.js</code> 文件，找到 <code>escape</code> 元素的正则表达式，替换为如下内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure>
<p>然后顺带把 <code>em</code> 一项也改掉：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure>
<p>然后保存，清除掉原本的数据库信息，然后重新部署和上传就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>当然也可以写简称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo cl</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>hexo s</code> 或 <code>hexo server</code> 全称来临时部署到本机上来查看效果。注意，记得在每一篇文章上添加 <code>mathjax: true</code> 元素表示启用 <code>mathjax</code> 渲染功能。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>不过，貌似复杂的公式依然无法渲染，因为需要导入 <code>package</code> 的功能，似乎一直都不行……所以这一点就算了吧，不过这样其实已经很好了，不是吗？</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Hexo/">Hexo</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/数学/">数学</a><a href="/tags/Hexo/">Hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/15/linear-algebra-operations/" title="矩阵操作" itemprop="url">矩阵操作</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-15T06:30:13.000Z" itemprop="datePublished"> 发表于 2019-11-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>回顾一下矩阵都有哪些基本操作吧！</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="矩阵的加法"><a href="#矩阵的加法" class="headerlink" title="矩阵的加法"></a>矩阵的加法</h3><p>加法就是把两个矩阵直接对应位置求和即可。</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
    1 & 2 & 3\\
    4 & 5 & 6
    \end{matrix}
\right) + \left(
    \begin{matrix}
    2 & 3 & -1\\
    0 & -1 & 5
    \end{matrix}
\right) = \left(
    \begin{matrix}
    3 & 5 & 2\\
    4 & 4 & 11
    \end{matrix}
\right)</script><h3 id="矩阵的减法"><a href="#矩阵的减法" class="headerlink" title="矩阵的减法"></a>矩阵的减法</h3><p>减法类似于加法，只是对应位置用减法罢了。</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
    1 & 2 & 3\\
    4 & 5 & 6
    \end{matrix}
\right) - \left(
    \begin{matrix}
    2 & 3 & -1\\
    0 & -1 & 5
    \end{matrix}
\right) = \left(
    \begin{matrix}
    -1 & -1 & 4\\
    4 & 6 & 1
    \end{matrix}
\right)</script><h3 id="矩阵的点乘法（内乘法）"><a href="#矩阵的点乘法（内乘法）" class="headerlink" title="矩阵的点乘法（内乘法）"></a>矩阵的点乘法（内乘法）</h3><p>矩阵乘法必须要求两个矩阵 $A_{m \times n}$ 和 $B_{n \times p}$ 的矩阵规格，第一个矩阵的列数必须等于第二个矩阵的行数。这是因为求值的过程是按整行和整列的内乘积（对应位相乘，再相加）。</p>
<script type="math/tex; mode=display">
\begin{align}
    \left(
        \begin{matrix}
        1 & 2 & 3\\
        4 & 5 & 6
        \end{matrix}
    \right) \cdot \left(
        \begin{matrix}
        1 & 2\\
        3 & 4\\
        5 & 6
        \end{matrix}
    \right) &= \left(
        \begin{matrix}
        1 \times 1 + 2 \times 3 + 3 \times 5 & 1 \times 2 + 2 \times 4 + 3 \times 6\\
        4 \times 1 + 5 \times 3 + 3 \times 6 & 4 \times 2 + 5 \times 4 + 6 \times 6
        \end{matrix}
    \right)\\
    &= \left(
        \begin{matrix}
        22 & 28\\
        37 & 64
        \end{matrix}
    \right)
\end{align}</script><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p>获取方阵的行列式，是采用降阶实现的。</p>
<script type="math/tex; mode=display">
\begin{align}
    \left|
        \begin{matrix}
        1 & 3\\
        2 & 4
        \end{matrix}
    \right|
    &= 1 \times 4 - 2 \times 3\\
    &= -2
\end{align}</script><p>三阶：</p>
<script type="math/tex; mode=display">
\begin{align}
    \left|
        \begin{matrix}
        1 & 2 & 3\\
        4 & 5 & 6\\
        7 & 8 & 9
        \end{matrix}
    \right| &= 1 \times (-1) ^ {1 + 1} \cdot \left|
        \begin{matrix}
        5 & 6\\
        8 & 9
        \end{matrix}
    \right| + 2 \times (-1) ^ {1 + 2} \cdot \left|
        \begin{matrix}
        4 & 6\\
        7 & 9
        \end{matrix}
    \right| + 3 \times (-1) ^ {1 + 3} \cdot \left|
        \begin{matrix}
        4 & 5\\
        7 & 8
        \end{matrix}
    \right|\\
    &= 1 \times 1 \times (-3) + 2 \times (-1) \times (-6) +3 \times 1 \times (-3)\\
    &= -3 + 12 - 9\\
    &=0
\end{align}</script><h3 id="矩阵的转置矩阵"><a href="#矩阵的转置矩阵" class="headerlink" title="矩阵的转置矩阵"></a>矩阵的转置矩阵</h3><p>将矩阵转置就是行列交换。</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
    1 & 2 & 3\\
    4 & 5 & 6
    \end{matrix}
\right) ^ T = \left(
    \begin{matrix}
    1 & 4\\
    2 & 5\\
    3 & 6
    \end{matrix}
\right)</script><h3 id="方阵的伴随矩阵"><a href="#方阵的伴随矩阵" class="headerlink" title="方阵的伴随矩阵"></a>方阵的伴随矩阵</h3><p>获取矩阵的伴随矩阵很简单，求得每一个位置上的代数余子式，并挨个写到矩阵里，再转置即可。</p>
<p>例如矩阵</p>
<script type="math/tex; mode=display">
A = \left(
    \begin{matrix}
    0 & 3 & -1\\
    1 & -1 & 1\\
    3 & -1 & 2
    \end{matrix}
\right)</script><p>它的每一个代数余子式如下所示：</p>
<script type="math/tex; mode=display">
\begin{matrix}
    A_{11} = (-1) ^ {1 + 1} \left|
        \begin{matrix}
        -1 & 1\\
        -1 & 2
        \end{matrix}
    \right| = -1, & A_{12} = (-1) ^ {1 + 2} \left|
        \begin{matrix}
        1 & 1\\
        3 & 2
        \end{matrix}
    \right| = 1, & A_{13} = (-1) ^ {1 + 3} \left|
        \begin{matrix}
        1 & -1\\
        3 & -1
        \end{matrix}
    \right| = 2,\\
    A_{21} = (-1) ^ {2 + 1} \left|
        \begin{matrix}
        3 & 1\\
        -1 & 2
        \end{matrix}
    \right| = -7, & A_{22} = (-1) ^ {2 + 2} \left|
        \begin{matrix}
        0 & 1\\
        3 & 2
        \end{matrix}
    \right| = -3, & A_{23} = (-1) ^ {2 + 3} \left|
        \begin{matrix}
        0 & 3\\
        3 & -1
        \end{matrix}
    \right| = 9,\\
    A_{31} = (-1) ^ {3 + 1} \left|
        \begin{matrix}
        3 & 1\\
        -1 & 1
        \end{matrix}
    \right| = 4, & A_{32} = (-1) ^ {3 + 2} \left|
        \begin{matrix}
        0 & 1\\
        1 & 1
        \end{matrix}
    \right| = 1, & A_{33} = (-1) ^ {3 + 3} \left|
        \begin{matrix}
        0 & 3\\
        1 & -1
        \end{matrix}
    \right| = -3.\\
\end{matrix}</script><p>所以</p>
<script type="math/tex; mode=display">
\text{adj} \ A = \left(
    \begin{matrix}
    -1 & -7 & 4\\
    1 & -3 & 1\\
    2 & 9 & -3
    \end{matrix}
\right)</script><h3 id="方阵的逆矩阵"><a href="#方阵的逆矩阵" class="headerlink" title="方阵的逆矩阵"></a>方阵的逆矩阵</h3><p>矩阵的除法的主要思路就是求逆矩阵。逆矩阵可以通过矩阵拼接一个同型单位矩阵 $E$ 并执行初等变换后得到。当然，能得到矩阵具有逆矩阵的前提是，这个矩阵的行列式不等于 0，记作 $\det A \neq 0$（中国的高等数学和线性代数的教材里多使用 $|A|$ 来表示 $A$ 的行列式，而不是用 $\det A$）。</p>
<p>矩阵如果能有它的逆矩阵，那么可以通过如下公式得到：</p>
<script type="math/tex; mode=display">
\begin{align}
    \text{inv} \ A &= \frac{\text{adj} \ A}{\det A}\\
    &= \frac1{\det A} \ \text{adj} \ A
\end{align}</script><p>或写作</p>
<script type="math/tex; mode=display">
\begin{align}
    A^{-1} &= \frac{A^*}{|A|}\\
    &= \frac1{|A|} \ A^*
\end{align}</script><p>例如上面的题目</p>
<script type="math/tex; mode=display">
A = \left(
    \begin{matrix}
    0 & 3 & -1\\
    1 & -1 & 1\\
    3 & -1 & 2
    \end{matrix}
\right)</script><p>它的行列式经过计算可得 $\det A = 5 \neq 0$，可逆，然后得到它的伴随矩阵为</p>
<script type="math/tex; mode=display">
\text{adj} \ A = \left(
    \begin{matrix}
    -1 & -7 & 4\\
    1 & -3 & 1\\
    2 & 9 & -3
    \end{matrix}
\right)</script><p>所以，根据公式可以得到</p>
<script type="math/tex; mode=display">
\begin{align}
    \text{inv} \ A &= \frac15 \left(
        \begin{matrix}
        -1 & -7 & 4\\
        1 & -3 & 1\\
        2 & 9 & -3
        \end{matrix}
    \right)\\
    &= \left(
        \begin{matrix}
        -\frac15 & -\frac75 & \frac45\\
        \frac15 & -\frac35 & \frac15\\
        \frac25 & \frac95 & -\frac35
        \end{matrix}
    \right)
\end{align}</script><h3 id="方阵的除法"><a href="#方阵的除法" class="headerlink" title="方阵的除法"></a>方阵的除法</h3><p>如果我们可以得到结果，那么我们可以定义出方阵的除法运算：</p>
<script type="math/tex; mode=display">
A \div B = A \ \text{inv} \ B = C => \text{inv} \ B = C \ \text{inv} \ A</script><p>当然，这种用法显然是不太方便的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/数学/">数学</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/15/clang-03-if-statement/" title="C 语言语法系列（3）：if 语句" itemprop="url">C 语言语法系列（3）：if 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-15T06:07:49.000Z" itemprop="datePublished"> 发表于 2019-11-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="if-关键字的用法"><a href="#if-关键字的用法" class="headerlink" title="if 关键字的用法"></a><code>if</code> 关键字的用法</h2><p>接下来，我将为你讲解的是一种新的执行语法模式：条件判断。</p>
<p>在前文的介绍里，我们可以使用运算符和类型声明的表达式，来获取一些数据的数值，并输出。但整个程序的写法格式是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样仅仅能够写出一些简单的执行语句。今天我们来学习一种跳转模式的语句：<code>if</code> 条件判断。<code>if</code> 条件判断的用法是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execution when condition is true.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execution when condition is false.</span></span><br><span class="line">    <span class="comment">// This block can be omitted when you don't need.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以根据注释内容看到，只要条件满足要求的，将会走第一个大括号的内容；如果不满足要求，将会走第二个大括号的内容。例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以从这里看到，显然 <code>a + b</code> 结果是大于 4 的，所以满足条件，故 <code>c</code> 的结果应为 <code>a + b</code>，输出的结果就是 5。当然，这里就需要你学习一些语法约定和书写格式规范。当 <code>if</code> 和 <code>else</code> 块里只有一句话的时候，大括号是可以省略的，但最好使用缩进格式书写，分清楚层次，这样可以轻松辨别代码的逻辑和控制的部分，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; <span class="number">4</span>)</span><br><span class="line">        c = a + b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        c = a * b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三目运算符：条件运算"><a href="#三目运算符：条件运算" class="headerlink" title="三目运算符：条件运算"></a>三目运算符：条件运算</h2><p>我们可以使用三目运算符 <code>?:</code> 来判别一个结果。类似上文的逻辑，在 <code>?</code> 前面写条件，在 <code>?</code> 和 <code>:</code> 之间写条件成立的时候的结果，而 <code>:</code> 后写条件为假的时候的结果。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = a + b &gt; <span class="number">4</span> ? a + b : a * b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就把之前的 <code>if-else</code> 判断模式简写为这样。它们是等价的。</p>
<h2 id="嵌套-if"><a href="#嵌套-if" class="headerlink" title="嵌套 if"></a>嵌套 <code>if</code></h2><p>之所以之前叫大家将 <code>if</code> 内部的执行内容进行缩进，是因为 <code>if</code> 的执行逻辑是可以嵌套的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a - b == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于上述逻辑，我们可以先看条件判断。由于 <code>a + b</code> 的结果是 5 而不是 3，所以它只能走 <code>else</code> 这一部分的执行内容。于是得到 <code>c</code> 为 0，所以输出结果为 0。</p>
<h2 id="串联-if"><a href="#串联-if" class="headerlink" title="串联 if"></a>串联 <code>if</code></h2><p>有时候，当分支不止一个的时候，我们可以使用把 <code>if</code> 的声明串联的模式来执行一些操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，这种写法太丑了。首先，我们认为一个分号就是一句话，现在引入了块的说法，所以一个大括号就是一句话。那么 <code>a == 2</code> 条件的 <code>else</code> 部分就只有一句话，我们可以省略这一个大括号；而且 <code>c == 3</code> 条件里的 <code>else</code> 分支的大括号也可以被省略，所以就变为这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不过，还是很丑陋。不过我们发现，既然 <code>else</code> 和 <code>if</code> 语句还有 <code>else</code> 完全可以连起来，那么何不把它们直接串联起来呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不就很好看了吗。这个写法就是 <code>if</code> 串联的写法。</p>
<h2 id="嵌套-if-时的三目运算"><a href="#嵌套-if-时的三目运算" class="headerlink" title="嵌套 if 时的三目运算"></a>嵌套 <code>if</code> 时的三目运算</h2><p>上文可以被简写为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b == <span class="number">3</span> ? (a - b == <span class="number">3</span> ? a * b : a / b) : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，三目运算符的查找逻辑是从右到左的。所以它会有先发现到 <code>(a - b == 3 ? a * b : a / b)</code> 表达式是完整的整体，所以这个括号是可以不要的，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = a + b == <span class="number">3</span> ? a - b == <span class="number">3</span> ? a * b : a / b : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/15/linq-08-relational-algrbra-in-linq/" title="LINQ 教程（8）：LINQ 里的关系代数" itemprop="url">LINQ 教程（8）：LINQ 里的关系代数</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-15T01:26:13.000Z" itemprop="datePublished"> 发表于 2019-11-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="什么是关系代数？"><a href="#什么是关系代数？" class="headerlink" title="什么是关系代数？"></a>什么是关系代数？</h2><p>关系代数是数据库里面需要用到的一个重要的理论概念。它针对于表进行加减乘除等等的定义操作。下面我们就一一来看下，关系代数里都有些啥。</p>
<h2 id="关系代数运算"><a href="#关系代数运算" class="headerlink" title="关系代数运算"></a>关系代数运算</h2><h3 id="加法（并集）"><a href="#加法（并集）" class="headerlink" title="加法（并集）"></a>加法（并集）</h3><p>关系代数里，把两个表加起来（$A \cup B$），就好比是求得两个表的并集。注意，在 LINQ 里，两个列表要求获取并集需要两个列表是同元素类型的。比如，我们只能针对于两个 <code>IEnumerable&lt;int&gt;</code> 作运算，尝试把 <code>IEnumerable&lt;int&gt;</code> 和 <code>IEnumerable&lt;char&gt;</code> 作并集是没有意义的。</p>
<p><img src="union.png" alt=""></p>
<p>好在，在 LINQ 里面提供了 <code>Union</code> 方法，可以用来提供作出并集操作：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.Union(list2);</span><br></pre></td></tr></table></figure>
<p>那么，如果 <code>list1</code> 里有 1、2、3，而 <code>list2</code> 里有 2、 3、 5 的话，那么 <code>result</code> 里就有 1、2、3、5 了。</p>
<h3 id="减法（差集）"><a href="#减法（差集）" class="headerlink" title="减法（差集）"></a>减法（差集）</h3><p>将两个表求差（$A \backslash B$ 或 $A - B$），就好比取出被减集合里有，而减集合里没有的元素。</p>
<p><img src="difference.png" alt=""></p>
<p>在 LINQ 里，我们可以使用 <code>Except</code> 方法来获取差集。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.Except(list2);</span><br></pre></td></tr></table></figure>
<p>那么，如果 <code>list1</code> 里有 1、2、3，而 <code>list2</code> 里有 2、 3、 5 的话，那么 <code>result</code> 里就是 1。</p>
<p>可见，减法操作是要区分被减集合和减集合的。</p>
<h3 id="对称差集"><a href="#对称差集" class="headerlink" title="对称差集"></a>对称差集</h3><p>对称差集又表示为 $A - B \cup B - A$，即取两种差集的并集。</p>
<p><img src="symmetrical-difference.png" alt=""></p>
<p>我们可以使用 <code>SymmetricalExcept</code> 方法获取对称差集。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.SymmetricalExcept(list2);</span><br></pre></td></tr></table></figure>
<p>由于最终用到了并集，所以计算过程并不区分调用方和被调用方，即你写成 <code>list2.SymmetricalExcept(list1)</code> 也是一样的。</p>
<h3 id="点乘法（交集）"><a href="#点乘法（交集）" class="headerlink" title="点乘法（交集）"></a>点乘法（交集）</h3><blockquote>
<p>为了区分这里的乘法和笛卡尔积的区别，我们把这里的乘法叫做点乘，而笛卡尔积我们表示为叉乘。</p>
</blockquote>
<p>点乘两个表（$A \cap B$）相当于为两个表作交集处理，取出都有的部分。</p>
<p><img src="intersection.png" alt=""></p>
<p>它使用的是 LINQ 里的 <code>Intersect</code> 方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.Intersect(list2);</span><br></pre></td></tr></table></figure>
<p>那么，如果 <code>list1</code> 里有 1、2、3，而 <code>list2</code> 里有 2、 3、 5 的话，那么 <code>result</code> 里就是 2、3。</p>
<h3 id="叉乘法（笛卡尔积）"><a href="#叉乘法（笛卡尔积）" class="headerlink" title="叉乘法（笛卡尔积）"></a>叉乘法（笛卡尔积）</h3><p>笛卡尔积在前文已经提到过了，它的模式是获取两个表的一一匹配的结果。我们使用的是 <code>SelectMany</code> 来实现的（当然你也可以用查询表达式实现），最终得到的结果通过匿名类型或者元组的方式返回出来，即可达到叉乘效果。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.SelectMany(d1 =&gt; list2.Select(d2 =&gt; (d1, d2)));</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> d1 <span class="keyword">in</span> list1</span><br><span class="line">             <span class="keyword">from</span> d2 <span class="keyword">in</span> list2</span><br><span class="line">             <span class="keyword">select</span> (d1, d2);</span><br></pre></td></tr></table></figure>
<p>这样就可以实现了。</p>
<h3 id="补集"><a href="#补集" class="headerlink" title="补集"></a>补集</h3><p>在 LINQ 的世界里，是不好实现补集一说的，因为全集是不清楚的。如果你要实现它，你可以尝试给出一个全局集合，然后作出补集。不过，这好比是使用全局集合减去当前集合得到的，所以补集完全不必去实现。</p>
<p><img src="complement.png" alt=""></p>
<p>它的公式大概就是 $A^C = \Omega - A$，其中 $\Omega$ 表示全局集合。</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>选择就是横向获取所有满足指定条件的对象。它相当于 <code>Where</code> 筛选方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.Where(v =&gt; v &gt;= <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>这样就选择出了所有大于等于 5 的元素。</p>
<h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>投影就是纵向获取所有指定字段的信息。比如，我有一堆学生，学生包含姓名、学号等信息，我可以尝试使用 <code>Select</code> 方法获取所有学生的学号。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = students.Select(</span><br><span class="line">    student =&gt; <span class="keyword">new</span> &#123; student.Name, student.Age, student.Gender &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样筛选出来的就是所有学生的姓名、年龄和性别三大属性值。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接表（Join）在前面已经讲了很多了，所以这里我们就不再赘述了，不过需要注意的是，它还有很多操作，例如自然连接、非等值连接等等。</p>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>除法理解起来比较困难，所以我们把它放在最后讲，而且我们得分四个例子给大家解释。</p>
<p><img src="division-eg1.png" alt=""></p>
<p>第一个实例给出了 A 和 B 两个表，现在要获取两个表的商。除法运算的模式是，先找到第一个表在第二个表里没有的字段，即这里的甲和乙，然后每一个元组都看一遍。看看所有当前元组对应行上的对应 B 表的丙字段的数值有没有包含。如果包含就取出来。</p>
<p>我们发现，A 表第 1、2、3 行的元组信息里，丙字段的数值都是 3，所以这三个元组的甲乙两个字段的投影便是 A 除以 B 的商。</p>
<p><img src="division-eg2.png" alt=""></p>
<p>第二个例子稍微难一点。B 表多了一个值，那么筛选 A 表元组的时候，就必须要看，是否筛选出来的集合，包含了全部 B 给出的信息值。举个例子，B 表的丙字段是 3 和 6，我们就必须在 A 表里找到所有记录，这些记录的丙字段要包括所有 3 和 6。</p>
<p>我们尝试整理 A 表，发现 A 表记录里甲乙字段值为 4 和 2 的所有记录里，丙字段为 3 和 6，把 B 表给定的丙字段的结果全部包含在内，所以 4 和 2 是一个结果；同理，发现 A 表满足类似要求的还有 1 和 5 的所有信息，它们素有记录里也全部含有 3 和 6（只需要全部包含即可，可以允许有多出来的部分，比如 1 和 5 还包含了丙字段的 7、8、9 的信息）。</p>
<p><img src="division-eg3.png" alt=""></p>
<p>第三个例子和第二个例子类似，发现 A 表里甲乙字段记录为 1 和 5 的信息的所有的丙字段分别为 3、6、7、8、9，完整包含了 3、6、7、8，所以甲乙字段 1 和 5 是这个结果的一个记录。不过这个例子里，只有这一个结果满足要求，所以只有它。</p>
<p><img src="division-eg4.png" alt=""></p>
<p>最后一个例子里，B 表是两个记录，所以我们只能去筛选 A 表里甲字段的信息。发现，能够完整包含 B 表信息的所有数据的，只有甲字段为 1 和 4 的时候，它们的记录分别为 1、2、3 和 4、2、3，完整包含了 B 表乙丙字段的 2 和 3，所以 1 和 4 是这个除法的结果。</p>
<p>不过遗憾的是，LINQ 并不能够很好地实现除法运算，因为它需要保证两个表的信息能够被正确投影，而在 LINQ 里，投影出来的结果一般用匿名类型或元组表示，但匿名类型和元组我们没有基类可以使用，所以我们不能够简单地表达出这些字段或属性的信息，所以即使是想要使用反射，也是非常困难的。而在 SQL 里，例如 <code>R(X, Y)÷S(Y, Z)</code> 的运算用结构化语言 SQL 语句可表达为下列形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> R.X <span class="keyword">from</span> R R1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">( </span><br><span class="line">    <span class="keyword">select</span> S.Y <span class="keyword">from</span> S</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">    ( </span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> R R2</span><br><span class="line">        <span class="keyword">where</span> R2.X=R1.X <span class="keyword">and</span> R2.Y=S.Y </span><br><span class="line">    ) </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>即利用的是双重否定表肯定的语义逻辑。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/">C♯.LINQ</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/C%E2%99%AF-LINQ-%E6%95%99%E7%A8%8B/">C♯.LINQ.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/LINQ/">LINQ</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/14/linq-07-aggregate-functions/" title="LINQ 教程（7）：聚合函数" itemprop="url">LINQ 教程（7）：聚合函数</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-14T12:55:42.000Z" itemprop="datePublished"> 发表于 2019-11-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="什么是聚合函数？"><a href="#什么是聚合函数？" class="headerlink" title="什么是聚合函数？"></a>什么是聚合函数？</h2><p>在 LINQ 的使用过程之中，我们肯定会用到 <code>Select</code>、<code>SelectMany</code>、<code>Where</code> 等方法。不过，这些方法是可以允许串联使用的，也就是说，这些方法可以一直往下通过方法链的方式，往下延伸到想要的地方结束。</p>
<p>不过，有一些 LINQ 提供的函数并不支持这种用途，而它们仅仅用来获取这些数据里的属性信息，例如求得一个整数集合 <code>IEnumerable&lt;int&gt;</code> 的最大值、平均值，或是获取总个数等等。这些函数在调用后，就无法继续往下调用其它的 LINQ 函数，而且它们往往都表示集合内部的属性。我们把这种函数称为<strong>聚合函数</strong>（Aggregate Function）。</p>
<blockquote>
<p>请记住，C# 在一般情况下都会把可执行的操作集称为方法（Method），而不是函数（Function）。但在一些特殊术语词汇和用途上，它们更被习惯性地称为函数。例如构造函数、析构函数以及聚合函数等，这些词汇一般不用“方法”一词。</p>
</blockquote>
<p>那么，LINQ 为我们提供了哪一些聚合函数呢？我们下面就来看看它们。</p>
<h2 id="聚合函数使用一览"><a href="#聚合函数使用一览" class="headerlink" title="聚合函数使用一览"></a>聚合函数使用一览</h2><p>先假设我们有一个集合：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> <span class="keyword">value</span> <span class="keyword">in</span> values</span><br><span class="line">                <span class="keyword">where</span> <span class="keyword">value</span> &gt;= <span class="number">6</span></span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>
<p>当然了，这个集合下面用不用都无关紧要，仅仅是为了表达出一些常见的聚合函数的用法。</p>
<h3 id="Max-和-Min-方法"><a href="#Max-和-Min-方法" class="headerlink" title="Max 和 Min 方法"></a><code>Max</code> 和 <code>Min</code> 方法</h3><p>显然，这两个方法用来求 <code>IEnumerable&lt;数值类型&gt;</code> 的最大值的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = selection.Max(); <span class="comment">// Get the maximum value.</span></span><br><span class="line"><span class="keyword">int</span> min = selection.Min(); <span class="comment">// Get the minimum one.</span></span><br></pre></td></tr></table></figure>
<p>它还有一堆重载方法。都是看的集合内元素的类型，进而去确定与之匹配的重载方法。</p>
<h3 id="Average-方法"><a href="#Average-方法" class="headerlink" title="Average 方法"></a><code>Average</code> 方法</h3><p>这个用法和求最大最小值没有差别。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result = selection.Average();</span><br></pre></td></tr></table></figure>
<p>当然，请注意，这个返回值一定是 <code>double</code> 类型的。虽然 C# 提供了 <code>decimal</code> 类型，会更加精确，但 LINQ 里的求平均值用的是 <code>double</code>。</p>
<p>另外，它也有一堆重载方法。也是和上面的思路一样。</p>
<h3 id="Count-方法和-Any-无参方法"><a href="#Count-方法和-Any-无参方法" class="headerlink" title="Count 方法和 Any 无参方法"></a><code>Count</code> 方法和 <code>Any</code> 无参方法</h3><p>这个方法用于获取一个 <code>IEnumerable&lt;T&gt;</code> 集合里到底有多少个元素。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = selection.Count();</span><br></pre></td></tr></table></figure>
<p>注意，由于 LINQ 的实现用的是扩展方法，所以 <code>Count</code> 在这里是一个方法名，而不是属性，所以必须要加上这一对小括号。另外，如果你需要使用这个数值来判断一个集合是否有元素的话，一般可以写成</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> existAnyElement = selection.Count() != <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>不过，我建议你使用 <code>Any</code> 方法（无参的这个重载），来判断集合是否有元素。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> existAnyElement = selection.Any();</span><br></pre></td></tr></table></figure>
<h3 id="存在量词-Any-函数和全称量词-All函数"><a href="#存在量词-Any-函数和全称量词-All函数" class="headerlink" title="存在量词 Any 函数和全称量词 All函数"></a>存在量词 <code>Any</code> 函数和全称量词 <code>All</code>函数</h3><p>接着是两个比较常用的聚合函数，它们用于判断集合里是否有元素满足指定条件，或者是全部元素都满足指定条件。</p>
<p>举个例子。我们要查询集合里是否所有元素都小于 7，它的写法是这样的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> allLessThanEight = selection.All(v =&gt; v &lt;= <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>而如果查找集合里是否存在任意一个元素，它的数值小于 8，那么写作</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> anyValueLessThanEight = selection.Any(v =&gt; v &lt;= <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意不要把 Lambda 运算符 <code>=&gt;</code> 和小于等于符号 <code>&lt;=</code> 以及大于等于符号 <code>&gt;=</code> 看混了。</p>
</blockquote>
<p>刚才也说过，<code>Any</code> 的无参重载表示的是这个集合是否包含元素。所以这里就不提及了。</p>
<h3 id="Concat-函数"><a href="#Concat-函数" class="headerlink" title="Concat 函数"></a><code>Concat</code> 函数</h3><p>这个函数用于拼接两个元素类型一致的 <code>IEnumerable&lt;T&gt;</code> 集合。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; l1 = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span> &#125;;</span><br><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; l2 = <span class="keyword">new</span> Stack&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the function `Concat`.</span></span><br><span class="line"><span class="keyword">var</span> result = l1.Concat(l2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the result.</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> v <span class="keyword">in</span> result)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，两个集合即使类型不是一致的，但如果都实现了 <code>IEnumerable&lt;T&gt;</code> 接口的话，那么第 1、2 行给出的写法就一定奏效（隐式转换），然后调用 <code>Concat</code> 方法一定是可以的。但是，迭代器将会取决于具体类型的实现。比如例子给出的实现里，第二个则用的是一个栈（先进后出集合），所以最终拼接并遍历出来的结果顺序必然是 3、8、1、6、5、0、9、2、7、4，即后五个新加入的元素的顺序应倒过来。</p>
</blockquote>
<h3 id="Cast-函数"><a href="#Cast-函数" class="headerlink" title="Cast 函数"></a><code>Cast</code> 函数</h3><p>如果我们有一个 <code>IEnumerable</code> 集合，知道它的元素的类型，却发现我们无法使用 LINQ 函数，怎么办？我们可以调用该方法将其转换为泛型集合 <code>IEnumerable&lt;T&gt;</code> 对象。例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable helloStr = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"Hello"</span>, <span class="string">","</span>, <span class="string">" "</span>, <span class="string">"world"</span>, <span class="string">"!"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the function `Cast`.</span></span><br><span class="line">IEnumerable&lt;<span class="keyword">string</span>&gt; result = helloStr.Cast&lt;<span class="keyword">string</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>注意，为这个方法添加泛型参数，来表示这个集合需要转换为这个类型。当然，如果你尝试把它转换为其它类型，那么只会出现报错，提示转换失败；而且，<code>IEnumerable</code> 接口在迭代的时候，每一个元素都是 <code>object</code> 类型。如果内部存放的是值类型的话，将会产生拆箱操作。</p>
<h3 id="Distinct-函数"><a href="#Distinct-函数" class="headerlink" title="Distinct 函数"></a><code>Distinct</code> 函数</h3><p>这个函数类似于 SQL 语句里的 <code>distinct</code> 关键字，它用来筛选集合里的重复数据。重复的项将会只保留一个，但前提是，这个集合的元素类型必须是可以比较相等操作的（即要么它本身实现了 <code>IEquatable&lt;T&gt;</code> 或 <code>IEquatable</code> 接口，要么就手动规定比较规则，即使用 <code>IEqualityComparer&lt;T&gt;</code> 或 <code>IEqualityComparer</code> 接口）。</p>
<p>例如，我们要对一个集合去重，那么写法如下。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; values = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the function `Distinct`.</span></span><br><span class="line"><span class="comment">// `result` will include only three values: 3, 2 and 1.</span></span><br><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; result = values.Distinct();</span><br></pre></td></tr></table></figure>
<h3 id="Range-函数（静态函数）"><a href="#Range-函数（静态函数）" class="headerlink" title="Range 函数（静态函数）"></a><code>Range</code> 函数（静态函数）</h3><p>这个函数用于生成一个 <code>IEnumerable&lt;int&gt;</code> 集合，且集合从指定数值增大，一次一个单位。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; values = Enumerable.Range(<span class="number">0</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<p>这样将会获取 0 到 8，一共 9 个元素。第一个参数表示起始数值，第二个参数表示一共要取出多少个元素。</p>
<p>注意，这个函数是静态函数，所以调用的时候，请使用 <code>Enumerable.Range</code> 的方式调用。</p>
<h3 id="Repeat-函数（静态函数）"><a href="#Repeat-函数（静态函数）" class="headerlink" title="Repeat 函数（静态函数）"></a><code>Repeat</code> 函数（静态函数）</h3><p><code>Repeat</code> 函数和 <code>Range</code> 不同，它虽然也是静态函数，但生成的集合并不是按序增大的，而是重复的。比如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">string</span>&gt; strings = Enumerable.Repeat(<span class="string">"I like programming."</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p>这样将会生成一个拥有 15 个元素的、且元素全都是 <code>I like programming</code> 字符串的字符串列表。</p>
<h3 id="Take-和-Skip-函数"><a href="#Take-和-Skip-函数" class="headerlink" title="Take 和 Skip 函数"></a><code>Take</code> 和 <code>Skip</code> 函数</h3><p><code>Take</code> 函数用于获取集合的前多少个元素（类似于 SQL 的 <code>top</code> 关键字），而 <code>Skip</code> 函数则用于跳过指定个数的元素。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; values = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; r1 = values.Take(<span class="number">3</span>); <span class="comment">// 3, 2, 1</span></span><br><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; r2 = values.Skip(<span class="number">3</span>).Take(<span class="number">2</span>); <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>Skip</code> 函数返回值依然是 <code>IEnumerable&lt;int&gt;</code> 类型，这样做的好处是可以继续使用成员访问运算符向下继续串联代码，而使用它所得到的集合，一定是从跳过了指定个数的元素后，作为第一项开始的新集合 <code>IEnumerable&lt;int&gt;</code>。换句话说，<code>values.Skip(3)</code> 将会返回的是 1、2、2、2、3、3、1、2、2 序列。</p>
<h3 id="ToArray-和-ToList-函数"><a href="#ToArray-和-ToList-函数" class="headerlink" title="ToArray 和 ToList 函数"></a><code>ToArray</code> 和 <code>ToList</code> 函数</h3><p>这两个函数用于将集合转换为数组 <code>T[]</code> 和列表集合 <code>List&lt;T&gt;</code>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = <span class="keyword">new</span> Queue&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"hello"</span>, <span class="string">","</span>, <span class="string">" "</span>, <span class="string">"world"</span>, <span class="string">"!"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>[] r1 = values.ToArray();</span><br><span class="line">List&lt;<span class="keyword">string</span>&gt; r2 = values.ToList();</span><br></pre></td></tr></table></figure>
<p>当然，LINQ 还提供了 <code>ToDictionary</code> 和 <code>ToHashSet</code> 函数，用于转字典和哈希表对象。这种转换就不在这里提及了，因为用得比较少，而且学习起来不太难。</p>
<p>还有一个 <code>ToLookUp</code> 方法，用于生成仅用于 LINQ 的类似于字典的分组表集合，这种集合专门用来存放分组数据，表示一对多的映射关系。</p>
<h3 id="First、FirstOrDefault、Single-和-SingleOrDefault-函数"><a href="#First、FirstOrDefault、Single-和-SingleOrDefault-函数" class="headerlink" title="First、FirstOrDefault、Single 和 SingleOrDefault 函数"></a><code>First</code>、<code>FirstOrDefault</code>、<code>Single</code> 和 <code>SingleOrDefault</code> 函数</h3><p><code>First</code> 方法有两个重载。一个是无参的，表示取出集合的第一个元素；第二个是有一个 Lambda 表达式参数的，表示获取满足指定条件的第一个元素。但是，这两个方法都有一个问题。当元素全部不满足要求的时候，运行将会抛出 <code>InvalidOperationException</code> 异常。</p>
<p>显然，这样做是容易出错的，于是我们提供了新方法：<code>FirstOrDefault</code>，它的操作和上一个一样，但当找不到元素的时候的行为不同。<code>FirstOrDefault</code> 方法在找不到满足要求的元素的时候，将会返回和元素的类型完全一样的这个类型的默认数值。比如一个集合是 <code>int</code> 类型的元素构成的，那么当找不到元素时，将会返回 <code>default(int)</code>，即 0。</p>
<p><code>Single</code> 和 <code>SingleOrDefault</code> 方法的行为则不同。它们除了计算整个集合满足要求的元素以外，还要要求整个集合只能有一个元素满足要求。<code>Single</code> 方法调用时，如果集合有超过一个元素满足该要求，则会直接抛出异常，而 <code>SingleOrDefault</code> 方法被调用时，如何有集合超过一个元素满足要求时，则会返回和集合元素类型一致的类型的默认值 <code>default(T)</code>。</p>
<h3 id="Last-和-LastOrDefault-函数"><a href="#Last-和-LastOrDefault-函数" class="headerlink" title="Last 和 LastOrDefault 函数"></a><code>Last</code> 和 <code>LastOrDefault</code> 函数</h3><p>当然了，这两个函数和上述用法基本一样，只是用来获取集合最后一个满足要求的元素。当然，找不到的话，<code>Last</code> 会产生 <code>InvalidOperationException</code>，而 <code>LastOrDefault</code> 将会返回默认数值 <code>default(T)</code>。</p>
<h3 id="ElementAt-函数"><a href="#ElementAt-函数" class="headerlink" title="ElementAt 函数"></a><code>ElementAt</code> 函数</h3><p>这个函数你完全可以理解为 <code>IEnumerable&lt;T&gt;</code> 集合类型的索引器。这里就不举例子了。</p>
<h3 id="Aggregate-函数"><a href="#Aggregate-函数" class="headerlink" title="Aggregate 函数"></a><code>Aggregate</code> 函数</h3><p>最后讲一个比较常见的聚合函数。把 aggregate 这个单词直译过来，实际上就是“聚合”的意思。真·聚合函数！</p>
<p>这个函数将每一次集合遍历过程的时候，通过指定的公式进行计算和处理，并得到最终的结果的行为就是这个函数的使用方式了。它有三个重载。</p>
<p>第一个重载是非常简单的，除了扩展方法的 <code>IEnumerable&lt;T&gt;</code> 集合自己，只需要给出一个额外参数，这个参数是一个 Lambda 表达式，表示一个聚合公式，把所有元素按照这个公式计算的结果聚合起来。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"hello"</span>, <span class="string">","</span>, <span class="string">" "</span>, <span class="string">"world"</span>, <span class="string">"!"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = values.Aggregate((s, v) =&gt; <span class="string">$"<span class="subst">&#123;s&#125;</span><span class="subst">&#123;v&#125;</span>"</span>);</span><br><span class="line">Console.WriteLine(result);</span><br></pre></td></tr></table></figure>
<p>可以看懂这个聚合函数的意义吗？这个函数将字符串序列按照顺序依次拼接，得到字符串结果。Lambda 表达式里的 <code>s</code> 表示临时变量，用于积累元素处理期间的数据的，而这个 <code>v</code> 就是集合在每一次遍历过程之中的元素。我们把用来积累的变量 <code>s</code> 往后添加 <code>v</code>，就凑成了字符串拼接后的新字符串，然后再往后添加下一个字符串，直到集合遍历完成。当然最终这个结果就是一个完整的字符串了。</p>
<p>第二个重载需要加入一个初始值 <code>seed</code> 参数。即可以改写一下上面的写法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.Aggregate(<span class="string">"Sunnie, "</span>, (s, v) =&gt; <span class="string">$"<span class="subst">&#123;s&#125;</span><span class="subst">&#123;v&#125;</span>"</span>);</span><br></pre></td></tr></table></figure>
<p>第三个重载，则在最后增加一个参数，用于指定聚合的处理情况。如下代码所示。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.Aggregate(<span class="string">"Sunnie, "</span>, (s, v) =&gt; <span class="string">$"<span class="subst">&#123;s&#125;</span><span class="subst">&#123;v&#125;</span>"</span>, v =&gt; v.ToUpper());</span><br></pre></td></tr></table></figure>
<p>这个聚合操作，将会把所有聚合的元素全部先转为大写，然后输出。自然结果就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNNIE, HELLO, WORLD!</span><br></pre></td></tr></table></figure>
<p>是不是很神奇呢？</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/">C♯.LINQ</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/C%E2%99%AF-LINQ-%E6%95%99%E7%A8%8B/">C♯.LINQ.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/LINQ/">LINQ</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>




  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页 ↓</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="Sunnie-Shine" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>



  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/C♯/" title="C♯">C♯<sup>20</sup></a></li>
			
		
			
				<li><a href="/tags/LINQ/" title="LINQ">LINQ<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/数学/" title="数学">数学<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/数独/" title="数独">数独<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-编译器生成/" title="C♯.编译器生成">C♯.编译器生成<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/安卓/" title="安卓">安卓<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ASP/" title="ASP">ASP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SQL/" title="SQL">SQL<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/诗词/" title="诗词">诗词<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GDI/" title="GDI+">GDI+<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/并发/" title="并发">并发<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://sunniesudoku.cn/" target="_blank" title="向向的数独文档库">向向的数独文档库</a>
            
          </li>
        
          <li>
            
            	<a href="http://tieba.baidu.com/f?kw=%CA%FD%B6%C0" target="_blank" title="数独贴吧">数独贴吧</a>
            
          </li>
        
          <li>
            
            	<a href="https://space.bilibili.com/23736703" target="_blank" title="Bilibili">Bilibili</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m Sunnie. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/Sunnie-Shine" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/Sunnie-Shine" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
	</div>
			
		

		<p class="copyright">
		Copyright © 2019 
		
		<a href="/about" target="_blank" title="向向">向向</a>
		
		<br />
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a>
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript"
  async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
