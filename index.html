
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>向向的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="向向">
    

    
    <meta name="description" content="This is my blog...">
<meta property="og:type" content="website">
<meta property="og:title" content="向向的博客">
<meta property="og:url" content="https:&#x2F;&#x2F;sunnie-shine.github.io&#x2F;index.html">
<meta property="og:site_name" content="向向的博客">
<meta property="og:description" content="This is my blog...">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="向向的博客" title="向向的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="向向的博客">向向的博客</a></h1>
				<h2 class="blog-motto">Console.WriteLine(&#34;Hello, ^_^&#34;);</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">全部文档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:Sunnie-Shine.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/csharp-nrt/" title="C# 8 里的可空引用类型" itemprop="url">C# 8 里的可空引用类型</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T12:48:55.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="可空引用类型"><a href="#可空引用类型" class="headerlink" title="可空引用类型"></a>可空引用类型</h2><p>在前文里，我们介绍过可空值类型 <code>Nullable&lt;T&gt;</code> 的相关内容，可以发现值类型是可以使用 <code>Nullable&lt;T&gt;</code> 使之为 <code>null</code> 的，不过引用类型基于指针这一点来说，肯定是需要 <code>null</code> 这种机制的。</p>
<p>不过……是的，你没有看错，从 C# 8 开始，引用类型也开始支持可空了。但是，引用类型不是一直都可以为 <code>null</code> 吗？它默认数值不就是为 <code>null</code> 吗？是的，但 C# 8 “暴力地”破坏了这一个要求，为了防止尽可能少出现 <code>NullReferenceException</code> 这种可怕的异常，我们产生了一个新的语法规则：强制引用类型不可空。然后如果非得让引用类型为空的话，请采用 <code>T?</code> 的写法，和值类型可空的写法一样，比如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>? s = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>但需要你注意的是，这种写法需要基于可空引用类型的环境。你需要先打开你的项目配置文件 <code>.csproj</code>，然后添加一项：<code>&lt;Nullable&gt;Enable&lt;/Nullable&gt;</code> 即可使用这个特性。</p>
<blockquote>
<p>类似地，<strong>可空引用类型</strong>（Nullable Reference Type）一般被简称为 NRT。</p>
</blockquote>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>我们通过和可空值类型完全一样的语法 <code>T?</code> 来声明一个类型可空：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>? s = <span class="literal">null</span>; <span class="comment">// A string can be null.</span></span><br><span class="line">s = <span class="string">"Hello"</span>; <span class="comment">// Okay.</span></span><br><span class="line">s = <span class="literal">null</span>; <span class="comment">// Okay.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> t = <span class="literal">null</span>; <span class="comment">// Will get a complier warning.</span></span><br></pre></td></tr></table></figure>
<p>但请注意，可空引用类型仅仅是语法上看起来和可空值类型一样，但实际上，可空引用类型并没有类似于 <code>Nullable&lt;T&gt;</code> 的类型，它在运行时是和原本的类型完全一样的，只是从编译器层面约束和限制了我们无法赋 <code>null</code> 值的要求。说白了，<code>string?</code> 和 <code>string</code> 依旧用的是同一个数据类型，只是编译器在看到你的类型后带 <code>?</code> 后会被判定为“可空”，于是这个类型你就可以放 <code>null</code> 进去；但没有这个符号，你就没办法赋 <code>null</code> 值，否则将会产生 CS86 系列警告。</p>
<p>那么，对应的一些语法，我们就得注意了：</p>
<h3 id="后缀运算符"><a href="#后缀运算符" class="headerlink" title="! 后缀运算符"></a><code>!</code> 后缀运算符</h3><p>为了保证一些特定情况下，我们需要赋值不为空，但编译器依然认为你赋的是 <code>null</code> 值时，我们可以采用 <code>!</code> 后缀运算符来强制编译器取消告警。</p>
<p>举一个例子，例如我们写了一个字符串转结构体的 <code>Parse</code> 方法，其中返回值是一个可空的类型，</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span> =&gt; (X, Y) = (x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> X &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Y &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point? Parse(<span class="keyword">string</span> str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// `(a, b)` form is correct,</span></span><br><span class="line">        <span class="comment">// so we use regular expression to get `a` and `b`.</span></span><br><span class="line">        <span class="keyword">var</span> regex = <span class="keyword">new</span> Regex(<span class="string">@"\(\d+,\s*\d+\)"</span>);</span><br><span class="line">        <span class="keyword">var</span> match = regex.Match(str);</span><br><span class="line">        <span class="keyword">if</span> (match.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Parse successfully.</span></span><br><span class="line">            <span class="keyword">var</span> valRegex = <span class="keyword">new</span> Regex(<span class="string">@"\d+"</span>);</span><br><span class="line">            <span class="keyword">var</span> matches = regex.Matches(match.Value);</span><br><span class="line">            <span class="keyword">var</span> s1 = matches[<span class="number">0</span>].Value;</span><br><span class="line">            <span class="keyword">var</span> s2 = matches[<span class="number">1</span>].Value;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Return the correct answer.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="keyword">int</span>.Parse(s1), <span class="keyword">int</span>.Parse(s2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Parse failed, it will return null value</span></span><br><span class="line">            <span class="comment">// to tell user the parsing operation has failed.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我在调用期间使用了这个方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p = Point.Parse(<span class="string">"(1, 3)"</span>);</span><br></pre></td></tr></table></figure>
<p>此时，将会产生一个编译器警告，提示你转换后的结果可能是 <code>null</code>。客观来讲，这确实是对的，因为返回值是可空类型的，而我们用一个不可为空的类型接受这个可空类型时，显然范围变小了，确实需要报错。</p>
<p>但是，我们完全可以发现，这个转换是有效且正确的，因为我们的正则表达式转换出来的结果一定可以得到 <code>X = 1</code> 和 <code>Y = 3</code> 的结果，这是令人烦躁的，所以我们只需要在转换结果后添加一个感叹号 <code>!</code> 来告诉编译器，这里的非空结果是预料之中的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p = Point.Parse(<span class="string">"(1, 3)"</span>)!;</span><br></pre></td></tr></table></figure>
<p>但需要你注意的是，如果在此时我们使用 <code>var</code> 类型来表示 <code>p</code> 的话，这两个语句都会得到什么结果呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = Point.Parse(<span class="string">"(1, 3)"</span>);  <span class="comment">// `p` is Point? type.</span></span><br><span class="line"><span class="keyword">var</span> q = Point.Parse(<span class="string">"(1, 3)"</span>)!; <span class="comment">// `q` is Point type.</span></span><br></pre></td></tr></table></figure>
<p>你答对了吗？</p>
<blockquote>
<p><code>!</code> 后缀运算符在 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/null-forgiving" target="_blank" rel="noopener">MSDN</a> 里称为<strong>null 包容运算符</strong>（Null-forgiving Operator），而在 Visual Studio 2019 下，这个运算符称为<strong>null 警告禁用运算符</strong>（Null-suppress Operator）。</p>
</blockquote>
<h3 id="as-的默认值"><a href="#as-的默认值" class="headerlink" title="as 的默认值"></a><code>as</code> 的默认值</h3><p>在 <a href="https://sunnie-shine.github.io/2019/11/06/csharplang-01-is-as-operator/">is 和 as</a> 一文中，我们提到了 <code>as</code> 的默认值。当引用类型时，转换无效时会返回 <code>null</code>。考虑如下情况。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> o = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">string</span> i = o <span class="keyword">as</span> <span class="keyword">string</span>; <span class="comment">// Hmmm</span></span><br></pre></td></tr></table></figure>
<p>可以看到，第二句话里，我们尝试将我们认为的 <code>o</code> 转为 <code>string</code> 类型。但这是不可能的，因为 <code>o</code> 装的是一个 <code>Point</code>，所以 <code>as</code> 转换失败后会返回 <code>null</code>。但显然，<code>string</code> 后没有问号，所以并不可空。那么这里一定会出现编译器的警告。那么，这下怎么办呢？</p>
<p>如果我们能保证这个转换是成立的，我们应当使用 <code>!</code> 后缀运算符来修饰结果，表示这个结果此时肯定不可空，是在我们预料之中的。但我们随时随地都可以加这个符号来取消警告。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> o = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">string</span> i = (o <span class="keyword">as</span> <span class="keyword">string</span>)!; <span class="comment">// What the hell?</span></span><br></pre></td></tr></table></figure>
<p>显然，这个转换是错误的，但我们确实取消了编译器的警告，那么，我们此时如果随意地使用这个 <code>i</code>，就会出现问题。比如我们取字符串的第 3 个字符：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = i[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>显然，这是会错的。所以，这产生了语义层面的 bug。我们应当尽量少使用 <code>!</code> 符号，而更多用在正确的地方。而且，哪怕原本类型就是 <code>string</code>，编译器依然会报错。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> o = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">string</span> s = o <span class="keyword">as</span> <span class="keyword">string</span>; <span class="comment">// Complier warning...</span></span><br></pre></td></tr></table></figure>
<p>这是因为编译器仅检查类型，它发现 <code>o</code> 是 <code>object</code> 时，就不会再往下查看具体 <code>o</code> 装的是什么类型的数据了，于是在使用 <code>as</code> 转换时，完全可能产生 <code>null</code> 结果，所以报错。此时我们不得不使用 <code>!</code> 后缀运算符：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> o = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">string</span> s = (o <span class="keyword">as</span> <span class="keyword">string</span>)!;</span><br></pre></td></tr></table></figure>
<p>但请注意，刚才说过，如果这里使用 <code>var</code> 来表示类型的话，如果不加 <code>!</code> 后缀运算符，将会被识别为 <code>string?</code> 而不是 <code>string</code>。</p>
<h3 id="使用特性来减少-后缀运算符的使用"><a href="#使用特性来减少-后缀运算符的使用" class="headerlink" title="使用特性来减少 ! 后缀运算符的使用"></a>使用特性来减少 <code>!</code> 后缀运算符的使用</h3><p>前文说过，<code>!</code> 的用法是认为决定的，所以这完全取决于人的使用方式，故我们无法做到编译器层面的完全禁止。而有一些情况，我们完全可以不去使用它们，以此让编译器为我们产生错误信息，来更好地约束我们的代码思维。此时，我们需要用到如下的一些特性。</p>
<h4 id="NotNullWhenAttribute"><a href="#NotNullWhenAttribute" class="headerlink" title="NotNullWhenAttribute"></a><code>NotNullWhenAttribute</code></h4><p>考虑如下 API。我们把刚才的 <code>Point</code> 类的 <code>Parse</code> 方法转换为 <code>TryParse</code> 方法，让它返回 <code>bool</code> 数值，而结果从参数返回。那么</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Parse</span>(<span class="params"><span class="keyword">string</span> str, <span class="keyword">out</span> Point? result</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// `(a, b)` form is correct,</span></span><br><span class="line">    <span class="comment">// so we use regular expression to get `a` and `b`.</span></span><br><span class="line">    <span class="keyword">var</span> regex = <span class="keyword">new</span> Regex(<span class="string">@"\(\d+,\s*\d+\)"</span>);</span><br><span class="line">    <span class="keyword">var</span> match = regex.Match(str);</span><br><span class="line">    <span class="keyword">if</span> (match.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Parse successfully.</span></span><br><span class="line">        <span class="keyword">var</span> valRegex = <span class="keyword">new</span> Regex(<span class="string">@"\d+"</span>);</span><br><span class="line">        <span class="keyword">var</span> matches = regex.Matches(match.Value);</span><br><span class="line">        <span class="keyword">var</span> s1 = matches[<span class="number">0</span>].Value;</span><br><span class="line">        <span class="keyword">var</span> s2 = matches[<span class="number">1</span>].Value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the correct answer.</span></span><br><span class="line">        result = <span class="keyword">new</span> Point(<span class="keyword">int</span>.Parse(s1), <span class="keyword">int</span>.Parse(s2));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Parse failed, it will return null value</span></span><br><span class="line">        <span class="comment">// to tell user the parsing operation has failed.</span></span><br><span class="line">        result = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要变化一点点内容即可。</p>
<p>现在，新的问题来了。我们调用的方式是</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point p;</span><br><span class="line"><span class="keyword">if</span> (TryParse(<span class="string">"(1, 3)"</span>, <span class="keyword">out</span> <span class="keyword">var</span> result))</span><br><span class="line">    p = result;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    p = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这样显然是不会有问题的，首先，返回为 <code>true</code> 时，意味着 <code>result</code> 此时肯定不为 <code>null</code>，所以可以安全赋值过去，但编译器由于发现 <code>result</code> 是 <code>Point?</code> 的，所以会报错。于是此时我们不得不使用 <code>!</code>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point p;</span><br><span class="line"><span class="keyword">if</span> (TryParse(<span class="string">"(1, 3)"</span>, <span class="keyword">out</span> <span class="keyword">var</span> result))</span><br><span class="line">    p = result!;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    p = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这样是没有错误的。但我们发现，这种写法是受到返回值的约束。当返回值为 <code>true</code>，这个 <code>out</code> 参数肯定是不为空的。所以我们可以把 API 改变一下。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Parse</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">string</span> str, [NotNullWhen(returnValue: <span class="literal">true</span></span>)] <span class="keyword">out</span> Point? result)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Same as before.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在第二个参数前面加上特性：<code>[NotNullWhen(returnValue: true)]</code>，那么这个 <code>result</code> 在编译器层面就会认为，当返回值为 <code>true</code> 时，这个参数值一定不会为空。所以，我们一旦用了这个模式书写代码，那么调用方就不用写 <code>!</code> 了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point p;</span><br><span class="line"><span class="keyword">if</span> (TryParse(<span class="string">"(1, 3)"</span>, <span class="keyword">out</span> <span class="keyword">var</span> result))</span><br><span class="line">    p = result; <span class="comment">// Correct now.</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    p = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="AllowNullAttribute-和-DisallowNullAttribute"><a href="#AllowNullAttribute-和-DisallowNullAttribute" class="headerlink" title="AllowNullAttribute 和 DisallowNullAttribute"></a><code>AllowNullAttribute</code> 和 <code>DisallowNullAttribute</code></h4><p>下面我们来看另外一个特性。这个特性表示我们给的数值是允许为 <code>null</code> 的。它一般用在属性的 setter，或参数上。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">AllowNull</span>]</span><br><span class="line">    <span class="keyword">set</span> &#123; name = Name ?? <span class="string">"DefaultName"</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，这个 setter 原本应该赋值为 <code>string</code> 的，但编译器此时允许你为其赋 <code>null</code> 进去。</p>
<p>当然了，<code>DisallowNull</code> 就是反过来的，不为 <code>null</code>。</p>
<h4 id="MaybeNullAttribute"><a href="#MaybeNullAttribute" class="headerlink" title="MaybeNullAttribute"></a><code>MaybeNullAttribute</code></h4><p>思考一下，当我们使用一个泛型是很普通的类型时，如果它为 <code>null</code> 了怎么办？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T FirstOrDefault&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;T&gt; source, Precicate&lt;T&gt; predicate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这个例子，它是 <a href="https://source.dot.net/#System.Linq/System/Linq/First.cs,8087366974af11d2,references" target="_blank" rel="noopener">Linq</a> 代码里的一个部分。这个方法是用于查找一个类型为 <code>T</code> 的集合 <code>source</code> 里，第一个满足 <code>predicate</code> 给定条件的项。当找到结果后，返回值为这个值；但没有找到结果的时候，返回值将为这个类型的默认值：值类型则是对应的默认结果，而引用类型则默认为 <code>null</code>。</p>
<p>按道理来讲，这里返回值就应当为可空的类型，所以我们应该设为 <code>T?</code> 类似的写法，来强制规定返回值可空。但很遗憾的是，这么做编译器会报错。这个编译器报错的大概意思是：“由于值类型和引用类型的行为不同，我们无法设置这一要求，请设置约束来规定这个泛型参数 <code>T</code> 是值类型还是引用类型”。</p>
<p>编译器的说法是有道理的。因为我们的值类型和引用类型的行为不同，值类型的可空，是将其翻译为另外一个类型 <code>Nullable&lt;T&gt;</code>，而引用类型则完全没有变化类型，只是告诉编译器它可空而已。如果我们“妄自”添加问号在类型上面的话，值类型和引用类型的处理方式都不同，那么后续交给程序，它并不知道这个类型此时是值类型还是引用类型，那后续有应该该怎么做呢？这是很复杂的一个问题。所以，我们临时给出的解决方案是，为这个返回值添加一个特性：<code>MaybeNullAttribute</code> 来表示这个返回值是可空的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">return: MaybeNull</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T FirstOrDefault&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;T&gt; source, Precicate&lt;T&gt; predicate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，编译器就能明白，此处的这个泛型返回值对应的类型，会依据值类型和引用类型分情况处理。引用类型下，就会产生警告。实际上，这个方法调用的是另外一个方法：<code>TryGetFirst</code>。它的源代码我也复制出来。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">return: MaybeNull</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TSource TryGetFirst&lt;T&gt;(</span><br><span class="line">    <span class="keyword">this</span> IEnumerable&lt;T&gt;? source, Predicate&lt;T&gt;? predicate, <span class="keyword">out</span> <span class="keyword">bool</span> found)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (predicate <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.predicate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">is</span> OrderedEnumerable&lt;T&gt; ordered)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Check the type is OrderedEnumerable&lt;T&gt; or not.</span></span><br><span class="line">        <span class="comment">// If so, the code will be simplified a bit.</span></span><br><span class="line">        <span class="keyword">return</span> ordered.TryGetFirst(predicate, <span class="keyword">out</span> found);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate on source.</span></span><br><span class="line">    <span class="keyword">foreach</span> (T element <span class="keyword">in</span> source)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If satisfying the predicate...</span></span><br><span class="line">        <span class="keyword">if</span> (predicate(element))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Return the result.</span></span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Failed to find.</span></span><br><span class="line">    found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">default</span>!; <span class="comment">// The value may be null when the value is a reference type.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希望你能感受一下，这个特性在代码里起到的作用。</p>
<h4 id="NotNullAttribute"><a href="#NotNullAttribute" class="headerlink" title="NotNullAttribute"></a><code>NotNullAttribute</code></h4><p>下面来介绍一个用法和刚才这个差不多的特性。这个特性一般用在 <code>ref</code> 参数上，表示参数在传参时不可以赋值为 <code>null</code>，虽然它此时是可以为 <code>null</code> 的类型。</p>
<p>在 .NET 提供的数据结构的代码里，某个数据结构需要进行扩容，此时为了保证容量，会调用下面这样的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Messages has the default value (null) when EnsureCapacity is called:</span></span><br><span class="line">EnsureCapacity&lt;<span class="keyword">string</span>&gt;(<span class="keyword">ref</span> storage, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// Messages is not null.</span></span><br><span class="line">EnsureCapacity&lt;<span class="keyword">string</span>&gt;(storage, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>如果原本是一个数组的话，我们可以为 API 设计为这样：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> EnsureCapacity&lt;T&gt;([NotNull] <span class="keyword">ref</span> T[]? storage, <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时来告诉编译器，在传参时，是不允许为 <code>null</code> 赋值过去的，但最后 <code>storage</code> 可以为 <code>null</code>，并是否为 <code>null</code> 将在 API 设计的代码里决定，而不是外界。</p>
<h4 id="NotNullIfNotNullAttribute"><a href="#NotNullIfNotNullAttribute" class="headerlink" title="NotNullIfNotNullAttribute"></a><code>NotNullIfNotNullAttribute</code></h4><p>最后一个特性是最鬼畜的特性。这个特性其实和 <code>NotNullWhenAttribute</code> 的用法非常相似，只是有一点区别：<code>NotNullWhenAttribute</code> 依赖于返回值来决定是否为空，而这里说的这个特性，依赖于其它参数。其中参数是什么，那么它的可空性和返回值的可空性是一样的。</p>
<p>考虑如下代码。我们假设要写一个 DNS 解析的服务。我们需要返回一个根域名服务器的地址，用字符串表示，而参数表示当前主机的地址。但如果参数为空，显然返回值就应为空，因为主机都没有，那么对应的根域名服务器肯定也就为空了，返回值此时的可空行为是和参数 <code>url</code> 是一样的，所以我们为返回值设定 <code>NotNullIfNotNullAttribute</code> 特性，来告诉编译器，返回值在参数 <code>url</code> 不为空的时候不为空。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">return: NotNullIfNotNull(<span class="meta-string">"url"</span>)</span>]</span><br><span class="line"><span class="keyword">string</span>? GetTopLevelDomainFromFullUrl(<span class="keyword">string</span>? url);</span><br></pre></td></tr></table></figure>
<p>虽然有点绕，但意思应该是清晰的。</p>
<h3 id="关于泛型的可空性"><a href="#关于泛型的可空性" class="headerlink" title="关于泛型的可空性"></a>关于泛型的可空性</h3><p>在前文我们提到了泛型的可空性。由于值类型和引用类型的可空行为不同，所以我们恐怕无法单纯添加一个问号就解决这一点。在 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/nullable-attributes#generic-definitions-and-nullability" target="_blank" rel="noopener">MSDN</a> 的原文里，原文是这么说的：</p>
<blockquote>
<p>Correctly communicating the null state of generic types and generic methods requires special care. This stems from the fact that a nullable value type and a nullable reference type are fundamentally different. An <code>int?</code> is a synonym for <code>Nullable&lt;int&gt;</code>, whereas <code>string?</code> is <code>string</code> with an attribute added by the compiler. The result is that the compiler can’t generate correct code for <code>T?</code> without knowing if <code>T</code> is a <code>class</code> or a <code>struct</code>.</p>
<p>This doesn’t mean you can’t use a nullable type (either value type or reference type) as the type argument for a closed generic type. Both <code>List</code> and <code>List</code> are valid instantiations of <code>List</code>.</p>
<p>What it does mean is that you can’t use <code>T?</code> in a generic class or method declaration without constraints. For example, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault#System_Linq_Enumerable_FirstOrDefault__1_System_Collections_Generic_IEnumerable___0__" target="_blank" rel="noopener">Enumerable.FirstOrDefault(IEnumerable)</a> won’t be changed to return <code>T?</code>. You can overcome this limitation by adding either the <code>struct</code> or <code>class</code> constraint. With either of those constraints, the compiler knows how to generate code for both <code>T</code> and <code>T?</code>.</p>
<p>You may want to restrict the types used for a generic type argument to be non-nullable types. You can do that by adding the <code>notnull</code> constraint on that type argument. When that constraint is applied, the type argument must not be a nullable type.</p>
</blockquote>
<p>我把这段话大致翻译了一下，我希望你能看懂中文。:P</p>
<blockquote>
<p>对于一个泛型类型和泛型方法的 null 的状态的正确处理是我们肯定会关心的地方。这个“梗”的诞生源于值类型和引用类型处理的方式完全不同。一个 <code>int?</code> 类型被翻译转为 <code>Nullable&lt;int&gt;</code>，但 <code>string?</code> 在编译器层面仅仅是添加了一个特性标记来标注它是个可空的 <code>string</code> 类型而已，因此类型并没发生变化。所以，编译器根本不可能在它本身并不知道 <code>T</code> 是一个值类型还是引用类型之前，就生成完全正确的代码。</p>
<p>但这并不意味着，我们不能在一个闭合的泛型类型参数上使用可空类型了（这里的可空类型指的是值类型或引用类型的两种可空情况的其一）。换句话说，<code>List&lt;string?&gt;</code> 和 <code>List&lt;int?&gt;</code> 在初始化 <code>List&lt;T&gt;</code> 集合的时候，都是完全被允许的。</p>
<p>但是，我们也确实无法在没有任何泛型约束的状态下指定一个泛型类或泛型方法的泛型参数 <code>T</code> 上随意指定它可空（即 <code>T?</code>）。比如，<a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault#System_Linq_Enumerable_FirstOrDefault__1_System_Collections_Generic_IEnumerable___0__" target="_blank" rel="noopener">Enumerable.FirstOrDefault(IEnumerable)</a>（上文里我们才看过的那个代码）就不可能允许直接返回一个 <code>T?</code>。但你完全可以克服这一点限制，通过为泛型参数添加一个值类型或引用类型的约束（写法是 <code>where T : struct</code> 或 <code>where T : class</code>），这样的话，编译器就肯定知道，接下来泛型类型 <code>T</code> 应如何去处理这个可空情况，即 <code>T?</code> 了。</p>
<p>你可能会想去限制某处的泛型参数不要为可空的类型，而且值类型和引用类型都可能。现在我们提供了一个泛型约束关键字 <code>notnull</code> 来表示这种特殊情况，只要我们为其设置 <code>where T : notnull</code> 泛型约束，那么此时的 <code>T</code> 就一定是一个不可以为空的类型了，而且值类型或引用类型均是允许的，只要它们不可空。</p>
</blockquote>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>很抱歉，这篇文章太长了。但我希望你能明白，可空值类型和可空引用类型的真正使用方式和操作，我可不希望你用错了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E8%AF%AD%E6%B3%95/">C♯.语法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/C♯-8/">C♯ 8</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/clang-07-for-loop/" title="C 语言语法系列（7）：for 语句" itemprop="url">C 语言语法系列（7）：for 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T12:35:56.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="for-（循环）语句"><a href="#for-（循环）语句" class="headerlink" title="for （循环）语句"></a><code>for</code> （循环）语句</h2><h3 id="for-语句的标准写法"><a href="#for-语句的标准写法" class="headerlink" title="for 语句的标准写法"></a><code>for</code> 语句的标准写法</h3><p>变量循环其实就是 <code>while</code> 和 <code>do-while</code> 语句的一种特别写法，为了方便人的理解，才创立的这样的循环操作，它是 <code>while</code> 的语法糖。</p>
<p>写法是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i; <span class="comment">// Note here, `i` is not `i++`.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code> 的括号里有三个语句，并且分别使用<strong>分号</strong>分开。原因在于它的写法会被编译为 <code>while</code> 语句，所以其实这些语句在 <code>while</code> 之中也都是需要加分号的，所以用分号隔开。两个分号把括号内的内容分隔成了三个部分，按顺序分别叫做<strong>初始值</strong>、<strong>条件</strong>、<strong>增量</strong>，即按变量来看的初始情况值，变量作循环需要满足的条件（或叫每做完一次循环后的判断条件），和每一次循环完成后变量需要变化的量。</p>
<p>它的解释是这样的：先赋初始值、然后判断条件、条件成立时执行循环里面的操作、然后对变量增加增量、然后判断条件、然后条件成立时只需循环里面的操作、然后对变量增加增量、然后判断条件，这样的操作。</p>
<p>比如上面的写法就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">i = 1</span><br><span class="line">i &lt; 100: 真</span><br><span class="line">sum += i: sum = 1</span><br><span class="line">i++: i = 2</span><br><span class="line">i &lt; 100: 真</span><br><span class="line">sum += i: sum = 3</span><br><span class="line">i++: i = 3</span><br><span class="line">i &lt; 100: 真</span><br><span class="line">sum += i: sum = 6</span><br><span class="line">i++: i = 4</span><br><span class="line">i &lt; 100: 真</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>另外，<code>sum = 0</code> 语句还可以直接写在 <code>for</code> 里。这也是可以的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, sum;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>, sum = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，变量赋初始值的时候，多个变量得用逗号隔开了。而且，标准 C 语言规定，变量的声明是不能写在 <code>for</code> 的里面的，比如这样是不可以的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种写法在 C99 标准里可以使用，而基本的 ANSI C 标准（C89）则不允许这么使用。</p>
</blockquote>
<h3 id="残缺-for"><a href="#残缺-for" class="headerlink" title="残缺 for"></a>残缺 <code>for</code></h3><p><code>for</code> 循环的分号内的东西可有可无，比如不需要的时候就可以不写，不过呢，分号不能省略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 1, sum = 0;</span><br><span class="line">for(; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样和上面的语句是等价的。毕竟赋初值可以在前面写，也可以后面写。</p>
<p>还可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">100</span>;)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样还是等效的。</p>
<h3 id="带有逗号表达式的-for"><a href="#带有逗号表达式的-for" class="headerlink" title="带有逗号表达式的 for"></a>带有逗号表达式的 <code>for</code></h3><p>在说这一点前，就不得不讲一个东西：逗号表达式。</p>
<h4 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h4><p>逗号表达式发明出来的唯一用途就只是放在 <code>for</code> 里，因为 <code>for</code> 需要用分号分隔所有部分（初值、条件和增量），所以如果想要同时给多个变量赋初始值的时候，或者是给多个变量设定增量的时候，就可以使用它，而不影响分号。</p>
<p>但是，因为它是在 C 语言里存在的语法点，所以也可以使用在其他场合，虽然这一点并不多大意义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">b = (a = <span class="number">3</span> * <span class="number">5</span>, a * <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>在赋值操作后，<code>a = 3 * 5, a * 4</code> 就是一个逗号表达式。它由两个部分构成：<code>a = 3 * 5</code> 和 <code>a * 4</code>。逗号表达式的计算是放在所有操作都执行完了才会执行的地方，这里是因为它有括号，所以会执行。</p>
<p>运算法则是这样的，从左到右依次计算，逗号表达式里面每一个用逗号分开的部分都会计算一次，并取最后一个部分，作为整体表达式的数值。比如这里，从左至右，先让 <code>a</code> 获得一个数值是 15，然后计算 <code>a * 4</code>，得到 60，这个 60 就是整体表达式的数值，最后赋值给 <code>b</code>，所以 <code>a = 15</code>、<code>b = 60</code>。</p>
<p>不过，由于它最后才会被计算，所以如果没有括号的话，就得小心了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c;</span><br><span class="line">c = a++, ++b, b++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%d%d"</span>, a, b, c);</span><br></pre></td></tr></table></figure>
<p>答案竟然是 <code>231</code>！你敢信？我们来看看为什么。</p>
<p>首先，C 语言规定，它的计算顺序是放在最后的，换句话说，赋值啥的所有操作全部在它前面。所以赋值会被先执行，也就是这句话等于是以下三句话的简写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = a++;</span><br><span class="line">++b;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure>
<p>只是合并了而已。而这句话你也看得出，逗号表达式虽然要取出最后一个逗号部分作为表达式的数值，但因为运算的关系，<code>a++</code> 已经先被赋值给 <code>c</code> 了，所以最终逗号表达式整体数值结果其实并没有什么用途，故这里其实只是相当于合并书写的一种操作罢了。</p>
<p>那么，<code>c = a++</code> 得到 <code>c</code> 的值应为 1，因为 <code>++</code> 在后。而 <code>a</code> 最终是会变为 2 的。然后 <code>b</code> 则会因为后面两句话，而增大两个单位。所以 <code>b</code> 应为 3。所以 $a = 2$、$b = 3$、$c = 1$。</p>
<h4 id="逗号表达式嵌套到-for-里"><a href="#逗号表达式嵌套到-for-里" class="headerlink" title="逗号表达式嵌套到 for 里"></a>逗号表达式嵌套到 <code>for</code> 里</h4><p>知道这一点之后，我们来看怎么嵌套。</p>
<p>我们知道，为 1 到 100 求和时，除了为作为循环的变量 <code>i</code> 赋值外，还需要为 <code>sum</code> 给定初始值，否则 <code>sum</code> 从一个根本就不知道是多少的数开始增加，是错误的。</p>
<p>所以我们可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, sum;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>, sum = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，简化写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, sum;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>, sum = <span class="number">0</span>; i &lt;= <span class="number">100</span>; sum += i++);</span><br></pre></td></tr></table></figure>
<p>也是 OK 的。注意，这次 <code>for</code> 因为没有大括号的关系，循环的部分就只有 <code>for</code> 带上这个小括号这一部分而已。所以加上了分号，表示它在这里截断，<code>for</code> 的语句只能到这里。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/csharp-default-interface/" title="C# 8 里的默认接口实现" itemprop="url">C# 8 里的默认接口实现</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T01:37:49.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="接口基础知识"><a href="#接口基础知识" class="headerlink" title="接口基础知识"></a>接口基础知识</h2><p>接口是一种面向对象编程 OOP 的语法机制，它和抽象类不同的地方在于，它需要你完全实现接口里给出的全部方法集合。</p>
<p>比如如下给定一个坐标对对象 <code>Point</code>，实现代码全部给出：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> row, <span class="keyword">int</span> column</span>)</span> =&gt; (Row, Column) = (row, column);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Row &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Column &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; (Row, Column).ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这些写法比较新，用的是 C# 6 提供的更多成员的 Lambda 实现模式以及 C# 7 给的元组模式来对位赋值，以及值元组类型 <code>ValueTuple&lt;...&gt;</code>。</p>
<p>显然，这个 API 太过于简单，我们还没有实现更多的东西。由于坐标对对象明显可以比较相等（只要行列的数值都相同，就可以认为坐标对对象是一样的），但我们为了后续可以告诉其它程序员，这个 API 可以提供比较和字典比较这些操作，我们需要实现 <code>IEquatable&lt;T&gt;</code> 接口来保证对象可以使用比较判断。</p>
<p>接着，设置好所有的重写方法和操作符重载：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Point : IEquatable&lt;Point&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> row, <span class="keyword">int</span> column</span>)</span> =&gt; (Row, Column) = (row, column);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Row &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Column &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span>? obj</span>)</span> =&gt; obj <span class="keyword">is</span> Point p &amp;&amp; Equals(p);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">Point other</span>)</span> =&gt; Row == other.Row &amp;&amp; Column == other.Column;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; (Row, Column).ToString();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span> =&gt; Row ^ Column;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point left, Point right) =&gt; left.Equals(right);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(Point left, Point right) =&gt; !left.Equals(right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先大致不用去看具体实现，因为我们这里的侧重点不是实现，而是接口。</p>
<p>当然，如果你不希望对方调用这个 <code>Equals</code> 方法的话，请把实现的方法改为显式实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> IEquatable&lt;Point&gt;.Equals(Point other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Row == other.Row &amp;&amp; Column == other.Column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>接口名.方法名</code> 来表示实现的接口，并且返回值前强制不加 <code>public</code>，因为接口里的方法在实现起来必然是 <code>public</code> 的，完全不必写出来。</p>
<h2 id="什么是默认接口实现？"><a href="#什么是默认接口实现？" class="headerlink" title="什么是默认接口实现？"></a>什么是默认接口实现？</h2><p>当我们需要的接口具有通用性，但又不是非要实现的话，我们就可以使用默认实现，类似于类里的虚方法。比如，我们完全可以使用给定的 <code>GetHashCode</code> 方法来判断对象是否数值上相等，于是我们就可以写一个接口，又不必实现，只需要这么写：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface IEquatableDefault&lt;in T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Default interface implementation.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">[MaybeNull] T other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> GetHashCode() == other.GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，我们就不必再每次都实现接口的方法了。把原来的 API 修改一下即可：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Point : IEquatableDefault&lt;Point&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> row, <span class="keyword">int</span> column</span>)</span> =&gt; (Row, Column) = (row, column);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Row &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Column &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span>? obj</span>)</span> =&gt; obj <span class="keyword">is</span> Point p &amp;&amp; Equals(p);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">Point other</span>)</span> =&gt; ((IEquatableDefault&lt;Point&gt;)<span class="keyword">this</span>).Equals(other);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; (Row, Column).ToString();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span> =&gt; Row ^ Column;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point left, Point right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ((IEquatableDefault&lt;Point&gt;)left).Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(Point left, Point right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !((IEquatableDefault&lt;Point&gt;)left).Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但请注意，接口默认的实现规则使得必须先把调用对象转为对应接口对象，然后才能调用。这是因为对象使用的默认方法实现，而实现机制要求你需要转换回接口，才能使用该方法，类似于显式实现的接口。</p>
<h2 id="重新实现接口"><a href="#重新实现接口" class="headerlink" title="重新实现接口"></a>重新实现接口</h2><h3 id="类重新实现基接口的成员"><a href="#类重新实现基接口的成员" class="headerlink" title="类重新实现基接口的成员"></a>类重新实现基接口的成员</h3><p>在前文给出的实现机制下，我们显然发现，这个 <code>GetHashCode</code> 写起来有点不太对，因为它直接异或运算得到的结果来比较，这一点不是很好。所以我们尝试去把原本接口里实现的方式进行修改。</p>
<p>我们尝试在 <code>Point</code> 里加入显式接口实现：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> IEquatableDefault&lt;Point&gt;.Equals(Point other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Row == other.Row &amp;&amp; Column == other.Column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一点和虚方法的重写不同，它不需要添加 <code>override</code> 关键字，因为它是属于接口层面的实现（之前的接口实现从来就没有写过 <code>override</code> 关键字，所以此时这里也是一样）。</p>
<p>然后，它就替换掉原本接口里的默认实现了。也就是说，如果我们尝试调用原本 API 的 <code>Equals</code> 方法，由于它调用的是接口的 <code>Equals</code> 方法的实现，而此时已经被重写，所以调用的实际上是上面这个重写后的显式接口实现的方法。</p>
<p>那么，原本接口内的方法就变成了类似于虚方法的机制了，当然，这只是”类似于“。</p>
<h3 id="接口重新实现基接口的成员"><a href="#接口重新实现基接口的成员" class="headerlink" title="接口重新实现基接口的成员"></a>接口重新实现基接口的成员</h3><p>下面来看另外一种情况。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface IEquatableDefault&lt;T&gt; : IEquatable&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> IEquatable&lt;T&gt;.Equals([AllowNull] T other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> GetHashCode() == other.GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的实现模式就可以把基类的 <code>Equals</code> 方法实现掉。不过这样的实现模式就不允许在类里重写方法了。因为显式接口实现是不允许重写的，否则将会产生如下的报错：</p>
<p><img src="error-info.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CS0539:</span><br><span class="line">&apos;Point.Equals(Point)&apos; in explicit interface declaration</span><br><span class="line">is not found among members of the interface that can be implemented.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从报错的编码就可以看出，实际上它并不是一种新的错误类型，而是之前的错误类型：不允许重写显式实现的方法。当你显式实现了一个接口里并不含有的方法时，就会产生这个错误，例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">I</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clx</span> : <span class="title">I</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> I.X() <span class="comment">// CS0539</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便会产生 CS0539 错误。而从上面的文章示例可以看出，由于你显式实现的原接口 <code>IEquatable&lt;T&gt;</code> 的方法，所以类里就无法进行重写，因为这个显式实现并非 <code>IEquatableDefault&lt;T&gt;</code> 类里的元素（或者说，这个显式实现具有良好的封装性）。</p>
</blockquote>
<h2 id="使用其它访问修饰符成员的支持"><a href="#使用其它访问修饰符成员的支持" class="headerlink" title="使用其它访问修饰符成员的支持"></a>使用其它访问修饰符成员的支持</h2><p>当然，这一次默认接口实现的特性还添加了对其它访问修饰符成员的支持。你可以在接口里自行声明 <code>private</code>、<code>private protected</code>、<code>protected</code>、<code>protected internal</code>、<code>internal</code> 或 <code>public</code> 的默认接口成员的实现。不过，用法和前文介绍的默认接口实现的机制基本上一样，除了一点，就是访问修饰符的级别而已。</p>
<h2 id="静态成员的支持"><a href="#静态成员的支持" class="headerlink" title="静态成员的支持"></a>静态成员的支持</h2><p>除此之外，默认接口实现还支持静态成员。举个例子。类似于上文的 <code>Point</code> 对象，我们完全可以默认实现一个 <code>Parse</code> 执行的静态方法。</p>
<p>比方说，我们可以写一个模块，专门用于实现 <code>Point</code> 类型用字符串转换的解析操作，我们可以这么设计接口的 API。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPointParsable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">Parse</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> match = <span class="keyword">new</span> Regex(<span class="string">@"\(\d+,\s*\d+\)"</span>).Match(str);</span><br><span class="line">        <span class="keyword">if</span> (match.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> digitPair = <span class="keyword">new</span> Regex(<span class="string">@"\d+"</span>).Matches(match.Value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Point(</span><br><span class="line">                <span class="keyword">int</span>.Parse(digitPair[<span class="number">0</span>].Value),</span><br><span class="line">                <span class="keyword">int</span>.Parse(digitPair[<span class="number">1</span>].Value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"Parse failed."</span>, <span class="keyword">nameof</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">TryParse</span>(<span class="params"><span class="keyword">string</span> str, [NotNullWhen(<span class="literal">true</span></span>)] <span class="keyword">out</span> Point? result)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = Parse(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="keyword">default</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过调用的时候就只能这么书写了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pt = IPointParsable.Parse(<span class="string">"(3, 5)"</span>);</span><br></pre></td></tr></table></figure>
<p>即使用 <code>接口名.静态方法名</code> 来调用。这一点确实有点让人不爽，还不如把方法直接写进结构里，哪怕在前期使用单独的静态类加静态方法，也可以使用 <code>静态类名.静态方法名</code> 依然可以解决，所以这个功能目前来说还不是很有用处。</p>
<h2 id="实现和重抽象化成员"><a href="#实现和重抽象化成员" class="headerlink" title="* 实现和重抽象化成员"></a>* 实现和重抽象化成员</h2><p>在官方给出的提案里，是提到了<strong>重写基默认接口成员的方法</strong>（Override）和<strong>重抽象</strong>（Re-abstraction）的内容，不过在目前的 C# 8 里全部尚不可以使用。所以这个坑就只能等到语法层面更新的时候才能继续往下写了。现在先给出一点概念。</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写基接口成员的方法，官方给出的方案是通过 <code>override</code> 的方式提供显式和隐式实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">"IA.M"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IB</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">void</span> IA.M() =&gt; Console.WriteLine(<span class="string">"IB.M"</span>); <span class="comment">// explicitly named</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IC</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">"IC.M"</span>); <span class="comment">// implicitly named</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上述示例里，<code>IA</code> 接口里有一个实现，在派生接口里，都得到了重写实现，它们都加上了 <code>override</code> 关键字，即使是显式实现的。</p>
<blockquote>
<p>不过从前文可以得知，目前想要实现基接口里的成员，必须使用显式接口实现，隐式目前还不支持。</p>
</blockquote>
<h3 id="重抽象"><a href="#重抽象" class="headerlink" title="重抽象"></a>重抽象</h3><p>你甚至支持在派生接口里重新把原本实现的操作再次抽象掉，这样在继续派生的话，就必须给出实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> &#123; WriteLine(<span class="string">"IA.M"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IB</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="keyword">void</span> IA.M();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">C</span> : <span class="title">IB</span> &#123; &#125; <span class="comment">// error: class 'C' does not implement 'IA.M'.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过，目前的重抽象是否被允许，还是一个遗留问题（Open issue），甚至 <code>IB</code> 接口里的显式实现到底应该写作 <code>abstract override</code> 还是 <code>abstract</code> 现在还没有给出结论。</p>
</blockquote>
<h3 id="菱形结构"><a href="#菱形结构" class="headerlink" title="菱形结构"></a>菱形结构</h3><p>当允许了上述的逻辑时，就必然会产生菱形结构：即某个类型继承自两个不同的接口，但两个不同的接口又同时实现了同一个接口的行为，且实现方式不同。</p>
<p>那么此时，这个所谓的“某个类型”到底是取哪一个接口的实现行为才应该是合理的呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(IA)&#125;</span>.<span class="subst">&#123;<span class="keyword">nameof</span>(Method)&#125;</span>()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IB</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IA.Method() =&gt; Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(IB)&#125;</span>.<span class="subst">&#123;<span class="keyword">nameof</span>(Method)&#125;</span>()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IC</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IA.Method() =&gt; Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(IC)&#125;</span>.<span class="subst">&#123;<span class="keyword">nameof</span>(Method)&#125;</span>()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class</span> : <span class="title">IB</span>, <span class="title">IC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ???</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，<code>Class</code> 里会报错，报错信息是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CS8705:</span><br><span class="line">Interface memeber &apos;IA.Method()&apos; does not have a most specific implementation.</span><br><span class="line">Neither &apos;IB.IA.Method()&apos;, nor &apos;IC.IA.Method()&apos; are most specific.</span><br></pre></td></tr></table></figure>
<p>提示信息的意思是，你现在使用的 <code>Class</code> 类实现了两个相似的接口 <code>IB</code> 和 <code>IC</code>，而它们全部显式实现了 <code>IA</code> 接口里的 <code>Method</code> 方法。但问题在于，它们都是显式接口实现，这都不是“真正实现”的方法。这样确实也防止了菱形结构的模棱两可的情况。</p>
<h3 id="该不该加-virtual-关键字？"><a href="#该不该加-virtual-关键字？" class="headerlink" title="该不该加 virtual 关键字？"></a>该不该加 <code>virtual</code> 关键字？</h3><p>前文用到的实现哪怕加入了 <code>override</code> 关键字来表达重写，但依旧不知道是否需要添加 <code>virtual</code> 关键字支持。从目前来说，在 IDE 里你完全可以添加 <code>virtual</code> 关键字，但实际上这个关键字加了当没加。因为加不加，都可以允许你显式实现接口成员，因此没有区别。但以后就不一定了，因为可能会出现 <code>override</code> 的情况，这样就可能出现前文提到了隐式实现模式和重抽象，这一点就完全可能会出现和体现 <code>virtual</code> 的功能了。</p>
<h3 id="指定基接口调用和实现"><a href="#指定基接口调用和实现" class="headerlink" title="指定基接口调用和实现"></a>指定基接口调用和实现</h3><p>在重写和重抽象的时候，我们可以使用 <code>base</code> 关键字指明你调用的是哪个基接口的对象的成员，不过目前也不支持，貌似等到 C# 9 才会出现了。目前有两种调用机制：<code>base(接口名).成员名</code> 和 <code>base&lt;接口名&gt;.成员名</code>。 </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://sunnie-shine.github.io/2019/11/08/common-01-nullable-types/#可空引用类型">可空引用类型</a>（博文）</li>
<li><a href="https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/default-interface-methods.md" target="_blank" rel="noopener">默认接口实现的提案</a>（GitHub “CSharplang” repo 里的提案）</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/misc/cs0539" target="_blank" rel="noopener">CS0539 错误</a></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E8%AF%AD%E6%B3%95/">C♯.语法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/C♯-8/">C♯ 8</a><a href="/tags/TODO/">TODO</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/clang-06-do-while-loop/" title="C 语言语法系列（6）：do-while 语句" itemprop="url">C 语言语法系列（6）：do-while 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T01:13:18.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="改下上一个例子的代码"><a href="#改下上一个例子的代码" class="headerlink" title="改下上一个例子的代码"></a>改下上一个例子的代码</h2><p>在求得 1 到 100 的和的计算结果的时候，我们明显知道 <code>i</code> 第一次的初始数值（即 1）是不可能超过 100 的，所以第一次完全不必判断这个条件。</p>
<p>正是因为这样，我们便产生了 <code>do-while</code> 语句。在提及代码的写法格式之前，我们先来看一下它的执行逻辑，如下图所示。</p>
<p><img src="do-while-loop-example.png" alt=""></p>
<h2 id="do-while-（循环）语句"><a href="#do-while-（循环）语句" class="headerlink" title="do-while （循环）语句"></a><code>do-while</code> （循环）语句</h2><p>下面我们来看一下 <code>do-while</code> 语句的执行逻辑和代码规范。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    S += i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>这种写法把条件进行了后置处理，所以执行 <code>S += i++;</code> 操作是无条件都会执行至少一次的。然后执行后才会判断数值 <code>i</code> 是否不超过 100。</p>
<p>不过，此时的大括号最好就不要省略了，虽然编译器依旧允许你这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    S += i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>甚至</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> S += i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> S += i++; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>这两种写法虽然没什么问题，不过不建议这么书写是因为代码不太好看。</p>
<p>一定要注意，语法格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    loopExecutingSentence;</span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>
<p>里面的末端，写了括号和条件 <code>condition</code> 后，还要加上分号，标记整体是一个语句的结束。</p>
<h2 id="while-和-do-while-的异同"><a href="#while-和-do-while-的异同" class="headerlink" title="while 和 do-while 的异同"></a><code>while</code> 和 <code>do-while</code> 的异同</h2><p>从两种书写格式来看，<code>while</code> 的条件是前置的，而 <code>do-while</code> 的条件则是后置的，这使得条件判断的位置不同。C 语言的执行是从上到下的，所以遇到这些条件的机会和方式不同，<code>while</code> 是不论如何都会先判断条件，当条件成立的时候执行对应大括号里的内容，但条件如果不满足，则不会执行内部的语句。所以 <code>while</code> 语句的重复执行部分很有可能一次都不会去执行；但 <code>do-while</code> 不一样，它的条件被放到后面，这使得重复执行的代码不论如何都会先被执行一次，然后才会判断条件。所以 <code>do-while</code> 语句的重复执行部分最少都会执行一次。</p>
<p>除此之外，它们并无什么不同。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/clang-05-while-loop/" title="C 语言语法系列（5）：while 语句" itemprop="url">C 语言语法系列（5）：while 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T00:21:22.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="循环是什么？"><a href="#循环是什么？" class="headerlink" title="循环是什么？"></a>循环是什么？</h2><p>在我们写代码的时候，难免遇到重复的操作。例如我想尝试从 1 到 100 求和。但显然，数学公式可以解决这一点：</p>
<script type="math/tex; mode=display">
S_n = \frac{n(n - 1)}2</script><p>显然，这种模式完全可以解决这个问题。不过，从代码的角度来看，我们也可以尝试让电脑计算 100 次求和的操作，这样依然可以解决，而且电脑运算得很快，所以我们完全可以忽略 100 次重复计算和一次计算公式得到结果的时间差。这个时间差我们完全感觉不到。</p>
<p>那么，如何进行重复性的运算呢？我们先理清楚执行思路：</p>
<p><img src="while-loop-example.png" alt=""></p>
<p>如图所示，我们首先为 <code>i</code> 和 <code>S</code> 赋值，这些数值在后续都会使用到，这个称为初始值。然后，我们尝试先判断一次是否这个数字 <code>i</code> 超过了 100。如果没有超过，我们就执行第一次把 <code>i</code> 累加到 <code>S</code> 之中。可见 <code>S</code> 表示整个计算的和值结果。接着，<code>i</code> 增大一个单位。于是，我们重新作一次判断，看此时的 <code>i</code> 是否超过了 100（超过 100 就不计算在内了）。如果没有超过，就重复操作，继续把 <code>i</code> 的新数值累加到 <code>S</code> 之中，并再次增大 <code>i</code> 一个单位；如果 <code>i</code> 已经超过了 100，整个计算的活动行为就结束了。于是我们此时输出 <code>S</code> 的结果，并退出程序，整个程序执行完毕。</p>
<p>看得出来，这个逻辑是比较清楚的。</p>
<h2 id="while-（循环）语句"><a href="#while-（循环）语句" class="headerlink" title="while （循环）语句"></a><code>while</code> （循环）语句</h2><p>说完基本的计算思路，下面我们来说说它的代码的语法格式。</p>
<h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p><code>while</code> 语句可以解决上述的写法。我们尝试来看一下整体的逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        S += i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们依旧尝试为 <code>i</code> 和 <code>S</code> 进行初始赋值，然后直接进入循环部分。当 <code>i</code> 不超过 100 的时候，就进行累加，并且要增大 <code>i</code> 变量的数值。最后执行完毕后，输出 <code>S</code> 的结果即可。</p>
<p>由此可见，这个类型的执行逻辑还是比较清晰的。有一点看起来像是瑕疵的地方在于，我们明明知道 <code>i</code> 此时初始数值是 1，没有超过 100，而为什么非要在最开始就写上判断条件 <code>i &lt;= 100</code> 来判断是否小于等于 100 呢？这不是废话吗？</p>
<p>实际上，这个程序当你输入了一个无效的数值时，比如 107，这个时候根本不可能计算从 107 到 100 的和（我们的目的是从 1 增大到 100，而 107 超过了 100），所以直接就退出了循环。另外，<code>while</code> 语句的格式要求把条件放到最开始，所以我们不得不这么做。</p>
<p>所以，总的来说，<code>while</code> 语句的写法是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    loopExecutingSentence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>while</code> 旁边写执行的元素的判断条件，然后在大括号里写上执行反复操作的语句。</p>
<blockquote>
<p><code>while</code> 语句也经常被称为 <code>while</code> 循环。</p>
</blockquote>
<h3 id="作出优化"><a href="#作出优化" class="headerlink" title="作出优化"></a>作出优化</h3><p>显然，在前文我们学习了自增自减运算符的前后缀书写方式的计算问题。当 <code>++</code> 写在变量之后，则表示变量在使用完成后最后增大一个单位。这使得我们原本需要写成两句话的语句可以写成一句话：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S += i++;</span><br></pre></td></tr></table></figure>
<p>这个写法等价于先执行 <code>sum += i;</code> 语句，然后执行 <code>i++;</code> 语句增大 <code>i</code> 变量一个单位。</p>
<p>所以，<code>while</code> 语句和 <code>if</code> 执行的模式完全一样，如果重复执行的语句只有一个语句，则可以省略大括号，所以上述写法融入到 <code>while</code> 里则可以写成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>)</span><br><span class="line">    S += i++;</span><br></pre></td></tr></table></figure>
<h2 id="另外一个示例"><a href="#另外一个示例" class="headerlink" title="另外一个示例"></a>另外一个示例</h2><p>下面我们来看另外一则示例。我们还是用求和的思路来讲解，不过我们稍作改动。如果我们要计算从 1 到某个数的和，不过问题变为了”请求出从 1 到 $n$ 的所有整数的和 $S$ 在<strong>第一次</strong>超过 2400 的时候，此时的 $n$ 的值“。这个问题怎么解决呢？</p>
<p>实际上，可能你想得很复杂。我们知道，<code>while</code> 语句的写法是一个条件加上重复运算的语句，所以这个题目完全可以只修改执行的条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (S &lt;= <span class="number">2400</span>) <span class="comment">// Note here.</span></span><br><span class="line">    S += i++;</span><br></pre></td></tr></table></figure>
<p>注意条件改为了 <code>S &lt;= 2400</code>，其它的地方都没变化。最后只需要输出 <code>i</code> 的结果就可以了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/18/csharplang-complement-04-enum/" title="C# 语法查漏补缺系列（4）：枚举类型" itemprop="url">C# 语法查漏补缺系列（4）：枚举类型</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-18T11:47:37.000Z" itemprop="datePublished"> 发表于 2019-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="枚举类型是什么？"><a href="#枚举类型是什么？" class="headerlink" title="枚举类型是什么？"></a>枚举类型是什么？</h2><p>在搞懂枚举类型之前，我们先要搞清楚，什么是<strong>枚举</strong>（Enumeration）。枚举是一种机制，它将整数用更容易理解的自定义词汇表达，来表现数据的灵活性。最常见的枚举的使用就是表示执行程序的状态了。比如，程序分启动、运行、退出三种大状态，所以我们可以把它们三个情况用 <code>Start</code>、<code>Running</code> 和 <code>End</code> 三个单词表达出来。但计算机并不识别单词，所以我们不得不用数字表达，于是，我们便建立起了数字和单词的关系和映射。</p>
<p>在使用的时候，我们就不必使用枯燥的数字来表示一个运行状态了。这就是枚举的产生。当然，<strong>枚举类型</strong>（Enumeration Type）就是这个枚举的名称，比如程序状态类型 <code>ExecutingStatus</code>。</p>
<h2 id="枚举类型的使用"><a href="#枚举类型的使用" class="headerlink" title="枚举类型的使用"></a>枚举类型的使用</h2><h3 id="枚举类型的语法"><a href="#枚举类型的语法" class="headerlink" title="枚举类型的语法"></a>枚举类型的语法</h3><p>在 C# 里，枚举类型是这么书写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符] enum 枚举类型名[ : 整数类型]</span><br><span class="line">&#123;</span><br><span class="line">    枚举值1[ = 值1],</span><br><span class="line">    枚举值2[ = 值2],</span><br><span class="line">    枚举值3[ = 值3],</span><br><span class="line">    ...</span><br><span class="line">    枚举值n[ = 值n,]</span><br><span class="line">&#125;[;]</span><br></pre></td></tr></table></figure>
<p>其中所有的中括号内的东西都可以不写。比如，程序执行状态的类型 <code>ExecutingStatus</code> 就可以表达为</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutingStatus : <span class="keyword">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    Start, <span class="comment">// Default value is 0.</span></span><br><span class="line">    Running, <span class="comment">// Default value is Start + 1.</span></span><br><span class="line">    End, <span class="comment">// Default value is Running + 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你不写第一个变量的枚举的等价数值时，系统默认为你分配为 0，当然你也可以给出一个非 0 数据来表示起始数值。但尽量使用 0，因为枚举如果没有 0 的话，后面写代码就可能会产生很隐蔽的错误，这一点我们稍后说明。另外，后面的任意一个数据不给等价数值的时候，默认是它前一个枚举类型的数值再加上 1 的结果。比如这里的三个枚举值分别就是 0、1、2。</p>
<p>另外，如果枚举类型的数值用得不是很大，我们为了节约内存，甚至可以为其设置枚举类型的数值范围，方法是在枚举类型名后跟上一个冒号，加上指定类型的范围的整数类型名称（可以是 <code>byte</code>、<code>sbyte</code>、<code>int</code>、<code>short</code>、<code>long</code>、<code>uint</code>、<code>ushort</code>、<code>ulong</code> 这些类型）。</p>
<p>由于整个大括号的关系，整体末尾的分号可以不写。</p>
<p>那么，我们就可以使用枚举类型了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (thread.CurrentStatus == ExecutingStatus.Running)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Means the current status is running.</span></span><br><span class="line">    <span class="comment">// We can do something such as abort the execution.</span></span><br><span class="line">    thread.Abort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上面这种用法（只是一个举例），如果当前线程还在跑的话，我们就中止这个线程。</p>
<h3 id="枚举类型的原理"><a href="#枚举类型的原理" class="headerlink" title="枚举类型的原理"></a>枚举类型的原理</h3><p>就枚举类型这一点来说，它可能比 Java 做得好。Java 的枚举类型是通过类实现的，这样使得枚举这种轻量级的东西变得非常“臃肿”。而 C# 里，枚举类型用的是值类型。在 C# 里，值类型认为是一些基础的、原子的类型（即元素不可拆分）。而这种类型通过调用栈来分配内存，使得比类的内存分配要快一点，而且要轻量级一些。</p>
<p>实际上，枚举可以在某种程度上认为是整数类型的等价封装。因为 C# 只是提供了一种将有意义的标识符来替换掉原本枯燥的数字，所以可以这么认为。</p>
<h3 id="枚举类型、数值和字符串三者的转换"><a href="#枚举类型、数值和字符串三者的转换" class="headerlink" title="枚举类型、数值和字符串三者的转换"></a>枚举类型、数值和字符串三者的转换</h3><p>枚举类型在编译期之前，可以使用显隐式转换，转换为对应的数值类型。比如，前文我们把 <code>ExecutingStatus</code> 类型设置为 <code>byte</code> 类型的数值范围，因为它只有三个字段，所以我们完全可以用 <code>byte</code> 内的元素搞定这些数值的枚举情况。</p>
<p>而从另外一个角度出发，这种类型的所有字段数值都将可以被转换为 <code>byte</code> 类型的数据。所以，C# 语法层面提供了隐式转换和显式转换两种模式。</p>
<p>当你想要把一个数值转换为枚举类型的时候，这个时候由于转换结果不定（比如我尝试把 3 转换为 <code>ExecutingStatus</code> 类型时，由于枚举里不存在该数值，所以这种转换是不安全的），所以 C# 提供的是显式转换，即需要写出转换类型符号来转换到指定类型）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutingStatus es = (ExecutingStatus)<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>显然，这样的转换是没有意义的。不过，在执行这句话的时候，是不会产生错误的；而相反，反而在使用的时候，它才会报错。</p>
<p>而且，枚举类型转数值的时候，依然用的是显式转换。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)ExecutingStatus.Running;</span><br></pre></td></tr></table></figure>
<p>所以，如果遇到想把上述枚举类型转为一个字符类型 <code>char</code> 的时候，你就必须写成这样：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="keyword">byte</span>)ExecutingStatus.Running;</span><br></pre></td></tr></table></figure>
<p>因为枚举类型是不允许直接转换为其它类型的，所以你需要先转换为 <code>byte</code> 后，然后再用 <code>byte</code> 转为 <code>char</code> 的强制转换来实现。当然，这种用法很少见。</p>
<p>另外，如果你想要把枚举类型的文本标识符获取到的话，可以使用 <code>ToString</code> 方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> s = ExecutingStatus.Running.ToString();</span><br></pre></td></tr></table></figure>
<p>但如果你需要把字符串等价的枚举类型字段转换过去的话，就得使用 <code>Enum.Parse</code> 或 <code>Enum.TryParse</code> 方法了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Way of usage 1:</span></span><br><span class="line">ExecutingStatus es1</span><br><span class="line">    = (ExecutingStatus)Enum.Parse(<span class="keyword">typeof</span>(ExecutingStatus), <span class="string">"Start"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 2:</span></span><br><span class="line">ExecutingStatus es2 = Enum.Parse&lt;ExecutingStatus&gt;(<span class="string">"Start"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 3:</span></span><br><span class="line"><span class="keyword">if</span> (Enum.TryParse(<span class="keyword">typeof</span>(ExecutingStatus), <span class="string">"Start"</span>, <span class="keyword">out</span> <span class="keyword">object</span> o))</span><br><span class="line">&#123;</span><br><span class="line">    ExecutingStatus es3 = (ExecutingStatus)o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 4:</span></span><br><span class="line"><span class="comment">// Same as type 3, but using pattern matching to get es3 value.</span></span><br><span class="line"><span class="keyword">if</span> (Enum.TryParse(<span class="keyword">typeof</span>(ExecutingStatus), <span class="string">"Start"</span>, <span class="keyword">out</span> <span class="keyword">object</span> o)</span><br><span class="line">    &amp;&amp; o <span class="keyword">is</span> ExecutingStatus es4)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es4` is assigned successfully.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 5:</span></span><br><span class="line"><span class="keyword">if</span> (Enum.TryParse&lt;ExecutingStatus&gt;(<span class="string">"Start"</span>, <span class="keyword">out</span> ExecutingStatus es5))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es5` is assigned successfully.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这五种书写格式都可以读取字符串，但前面两种当字符串书写不正确的时候，会抛出转换失败的异常，后面三种则不会。但第三种、第四种模式都会通过拆箱，因为是把 <code>object</code> 引用类型拆箱为 <code>ExecutingStatus</code> 值类型。第五种则使用的是泛型转换，这样的话 <code>es5</code> 的类型一定是和泛型参数类型一样的类型。</p>
<blockquote>
<p>所以你可以从这里看到，由于类型是一样的，所以泛型参数和 <code>out</code> 参数的类型里的任意一个都可以不写，即要么</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Enum.TryParse(<span class="string">"Start"</span>, <span class="keyword">out</span> ExecutingStatus es5))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es5` is assigned successfully.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要么</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Enum.TryParse&lt;ExecutingStatus&gt;(<span class="string">"Start"</span>, <span class="keyword">out</span> <span class="keyword">var</span> es5))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es5` is assigned successfully.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种写法均可。</p>
</blockquote>
<p>以上就介绍了枚举类型转数字和字符串，以及数字和字符串转枚举类型的方法。</p>
<h3 id="枚举类型的运算符重载"><a href="#枚举类型的运算符重载" class="headerlink" title="枚举类型的运算符重载"></a>枚举类型的运算符重载</h3><p>这才是最骚的，C# 由于和 Java 机制不同的关系，C# 具有操作符重载的说法。在语法层面上，C# 提供了枚举类型和整数的加减法重载。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es1 = ExecutingStatus.Running + <span class="number">1</span>; <span class="comment">// ExecutingStatus.End</span></span><br><span class="line"><span class="keyword">var</span> es2 = ExecutingStatus.Running - <span class="number">1</span>; <span class="comment">// ExecutingStatus.Start</span></span><br></pre></td></tr></table></figure>
<p>这样可以设置类似于“偏移量”的概念。</p>
<p>不过，还可以为其设置枚举类型之间的位运算，这一点我们在后面这一节作详细讲解。</p>
<h2 id="位域枚举类型"><a href="#位域枚举类型" class="headerlink" title="位域枚举类型"></a>位域枚举类型</h2><h3 id="位域枚举类型的定义"><a href="#位域枚举类型的定义" class="headerlink" title="位域枚举类型的定义"></a>位域枚举类型的定义</h3><p>位域枚举类型指的是，当某种类型的所有字段可以被复用的时候，我们可以使用二进制位表示每一种情况，这样可以允许一些“多角色”的情况出现。比如，Linux 操作文件的时候，文件具有可读可写可执行三大操作，这三种操作互不冲突，且文件可以具有多个属性，即某个文件完全可以实现可读和可写，或可读可写可执行都允许的情况。这种枚举类型是一种特殊的枚举类型，它就被称为<strong>位域枚举类型</strong>（Flag Enumeration Type）。</p>
<h3 id="位域枚举类型的使用"><a href="#位域枚举类型的使用" class="headerlink" title="位域枚举类型的使用"></a>位域枚举类型的使用</h3><p>这种现象，我们只需要做两步工作就可以把一个枚举类型该为位域枚举类型：为其添加 <code>FlagsAttribute</code> 特性，并为每一个枚举数值赋值二进制位对应每一种情况的数值结果：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FileTypes</span><br><span class="line">&#123;</span><br><span class="line">    Readable = <span class="number">1</span>,</span><br><span class="line">    Writable = <span class="number">2</span>,</span><br><span class="line">    Executable = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便完成了枚举类型转为位域枚举类型。</p>
<blockquote>
<p><code>FlagsAttribute</code> 特性可写可不写，下面的内容完全都可以用。但加上它可以让编译器辅助我们查找出一些隐藏的错误。</p>
</blockquote>
<p>这种类型有什么好处呢？由于每一个数值都是二进制位表示的，所以我们完全可以使用位运算符来操作它们，获取一个对象的固有枚举类型集。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft = FileTypes.Readable | FileTypes.Writable;</span><br></pre></td></tr></table></figure>
<p>这样就可以表示一个可读或者可写的行为，到时候就可以获取具体的枚举情况，查看它是否具有指定枚举情况。比如，我们需要判断文件是否有可读属性，如果可以读取，就执行读取操作；如果可写，则执行写入操作，等等。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = someFile;</span><br><span class="line"><span class="keyword">if</span> (file.FileTypes.HasFlag(FileTypes.Executable))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execute file.</span></span><br><span class="line">    file.Execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The file cannot be executed.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"The file cannot be executed."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以调用系统自带的 <code>HasFlag</code> 方法来表示当前对象是否具有当前枚举值的行为。</p>
<p>诸如上述的操作。</p>
<p>当然，你可以写另外的一种枚举数值模式，二进制字面量。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FileTypes</span><br><span class="line">&#123;</span><br><span class="line">    None       = <span class="number">0b000</span>,</span><br><span class="line">    Readable   = <span class="number">0b001</span>,</span><br><span class="line">    Writable   = <span class="number">0b010</span>,</span><br><span class="line">    Executable = <span class="number">0b100</span>,</span><br><span class="line">    All        = <span class="number">0b111</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，更易于看懂和理解每一个数值的对应情况，甚至你可以提供特殊的枚举数值，比如文件什么操作都不给，或者什么操作都有。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file.FileTypes == FileTypes.All)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Here all operation can be done.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用位运算来简化操作"><a href="#使用位运算来简化操作" class="headerlink" title="使用位运算来简化操作"></a>使用位运算来简化操作</h3><p>在前文里，我们使用了 <code>|</code> 位或运算符号来合并两种枚举情况，表示或的关系，二进制层面的话，数值则表示为 <code>0b110</code>，即可读可写的两个属性二进制位被置为 1。实际上，所有位运算符都适用于位域枚举类型。</p>
<h4 id="位与运算符-amp"><a href="#位与运算符-amp" class="headerlink" title="位与运算符 &amp;"></a>位与运算符 <code>&amp;</code></h4><p>可以使用位与运算符 <code>&amp;</code> 来表示两者都需要同时满足。它一般用于判断某个位域数值是否被包含在里面。比如，我们可以通过 <code>HasFlag</code> 方法查看当前位域数值是否包含 <code>FileTypes.Executable</code>，也可以通过该符号实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ft &amp; FileTypes.Executable) == FileTypes.Executable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The file can be executed.</span></span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它完全等价于</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ft.HasFlag(FileTypes.Executable))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The file can be executed.</span></span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位或运算符"><a href="#位或运算符" class="headerlink" title="位或运算符 |"></a>位或运算符 <code>|</code></h4><p>在前文已经说过，它用于表示两个枚举类型的或的关系，即同时给两个二进制位赋上值，甚至也可以为一个已经给定一部分二进制位的情况的枚举对象赋值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft1 = FileTypes.Readable | FileTypes.Writable;</span><br><span class="line"><span class="keyword">var</span> ft2 = ft1 | FileTypes.Executable;</span><br></pre></td></tr></table></figure>
<p>当前，请注意的是，二进制实现层面来说，哪怕你已经包含了某个属性，调用 <code>|</code> 运算符也不会清除掉它们。</p>
<h4 id="位异或运算符"><a href="#位异或运算符" class="headerlink" title="位异或运算符 ^"></a>位异或运算符 <code>^</code></h4><p>位异或运算符 <code>^</code> 用于反转一个二进制位。如果这个二进制位想从 1 变为 0，或者 0 变为 1，可以通过这个方式实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft = FileTypes.All ^ FileType.Executable;</span><br></pre></td></tr></table></figure>
<p>这样的话，就可以表示去掉可执行的二进制位的位域值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft = FileTypes.None ^ FileType.Executable;</span><br></pre></td></tr></table></figure>
<p>这样就可以表示一个文件仅仅可被执行。</p>
<h4 id="位取反运算符"><a href="#位取反运算符" class="headerlink" title="位取反运算符 ~"></a>位取反运算符 <code>~</code></h4><p>位取反运算符 <code>~</code> 可以表示把一个二进制位反转，但这种用法并不常见，因为它甚至会把所有其它的二进制位都反转过来，所以显得非常没有意义。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E8%AF%AD%E6%B3%95/">C♯.语法</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E8%AF%AD%E6%B3%95/C%E2%99%AF-%E8%AF%AD%E6%B3%95-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/">C♯.语法.查漏补缺</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/17/async-await-fundamental/" title="Async/await 关键字原理" itemprop="url">Async/await 关键字原理</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-17T08:59:40.000Z" itemprop="datePublished"> 发表于 2019-11-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="async-和-await-是什么？"><a href="#async-和-await-是什么？" class="headerlink" title="async 和 await 是什么？"></a><code>async</code> 和 <code>await</code> 是什么？</h2><p>在我们平时 C# 的使用之中，总会遇到很多超时和耗时操作，比如获取网页的 HTTP 源代码。</p>
<blockquote>
<p>可能你会问：获取源代码有什么用吗？其实获取这个源代码，可以用来解析并生成模板，来处理这个源代码内部的文字信息，可以达到爬虫的效果。比如我想要联网查英语单词的意思，因为没有提供数据库，所以我们可以使用页面自带的返回的效果来找到所有查到的单词都用得到的 div 块，然后去看它们的共同之处，进而通过代码，来获取单词的释义，然后反馈回来。</p>
</blockquote>
<p>那么，这些操作显然都有可能出现，而如果我们在使用 UI 设计的时候调用它们，就很容易出现卡死、导致 UI 无法响应，并卡死的操作。于是，我们出现了这个模式。这个模式用于异步处理这些耗时操作，会在线程池里取出一个空闲的后台线程，并执行这个操作；执行完毕后，将会默认回到主线程继续执行，这样一来，你就会发现，由于单独开了一个线程处理，所以 UI 不卡了。这就是这两个关键字带给我们的使用效果。</p>
<blockquote>
<p>上述说法还有点细节的问题，不要当杠精，我们在下文里会慢慢阐述原理，并重新解释这些内容。</p>
</blockquote>
<h2 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a>书写格式</h2><p>来看一下，我们如何对一个方法使用 <code>async</code> 和 <code>await</code> 模式。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Project</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">FetchHttpFile</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> client.GetStringAsync(<span class="keyword">new</span> Uri(<span class="string">"www.baidu.com"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个写法便是使用了 <code>async</code> 和 <code>await</code> 模式。首先，我们将耗时的操作写到方法名前面。一般按照规范，<code>async</code> 将放到类型前面，挨着类型名称。其次，类型请使用 <code>Task&lt;T&gt;</code> 方式，其中的泛型参数 <code>T</code> 使用这个类型的本应该返回的返回值类型。比如，这个实例想要通过这个模式来获取 HTTP 文件的内容，那么我们将可以使用这个模式来获取。</p>
<h2 id="编译器处理后的样子"><a href="#编译器处理后的样子" class="headerlink" title="编译器处理后的样子"></a>编译器处理后的样子</h2><p>上述的短短十多行代码将会生成下面的编译器处理后的代码。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.CompilerServices;</span><br><span class="line"><span class="keyword">using</span> System.Runtime.InteropServices;</span><br><span class="line"><span class="keyword">using</span> System.Security;</span><br><span class="line"><span class="keyword">using</span> System.Security.Permissions;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">[<span class="meta">assembly: CompilationRelaxations(8)</span>]</span><br><span class="line">[<span class="meta">assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)</span>]</span><br><span class="line">[<span class="meta">assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)</span>]</span><br><span class="line">[<span class="meta">assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)</span>]</span><br><span class="line">[<span class="meta">assembly: AssemblyVersion(<span class="meta-string">"0.0.0.0"</span>)</span>]</span><br><span class="line">[<span class="meta">module: UnverifiableCode</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Project</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">StructLayout(LayoutKind.Auto)</span>]</span><br><span class="line">    [<span class="meta">CompilerGenerated</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">struct</span> &lt;FetchHttpFile&gt;d__0 : IAsyncStateMachine</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> AsyncTaskMethodBuilder&lt;<span class="keyword">string</span>&gt; &lt;&gt;t__builder;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TaskAwaiter&lt;<span class="keyword">string</span>&gt; &lt;&gt;u__1;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">int</span> num = &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line">            <span class="keyword">string</span> result;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                TaskAwaiter&lt;<span class="keyword">string</span>&gt; awaiter;</span><br><span class="line">                <span class="keyword">if</span> (num != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    awaiter = <span class="keyword">new</span> HttpClient().GetStringAsync(<span class="keyword">new</span> Uri(<span class="string">"www.baidu.com"</span>)).GetAwaiter();</span><br><span class="line">                    <span class="keyword">if</span> (!awaiter.IsCompleted)</span><br><span class="line">                    &#123;</span><br><span class="line">                        num = (&lt;&gt;<span class="number">1</span>__state = <span class="number">0</span>);</span><br><span class="line">                        &lt;&gt;u__1 = awaiter;</span><br><span class="line">                        &lt;&gt;t__builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiter, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    awaiter = &lt;&gt;u__1;</span><br><span class="line">                    &lt;&gt;u__1 = <span class="keyword">default</span>(TaskAwaiter&lt;<span class="keyword">string</span>&gt;);</span><br><span class="line">                    num = (&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                result = awaiter.GetResult();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception exception)</span><br><span class="line">            &#123;</span><br><span class="line">                &lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">                &lt;&gt;t__builder.SetException(exception);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &lt;&gt;<span class="number">1</span>__state = <span class="number">-2</span>;</span><br><span class="line">            &lt;&gt;t__builder.SetResult(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IAsyncStateMachine.MoveNext()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in MoveNext</span></span><br><span class="line">            <span class="keyword">this</span>.MoveNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">DebuggerHidden</span>]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetStateMachine</span>(<span class="params">IAsyncStateMachine stateMachine</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            &lt;&gt;t__builder.SetStateMachine(stateMachine);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine</span></span><br><span class="line">            <span class="keyword">this</span>.SetStateMachine(stateMachine);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AsyncStateMachine(typeof(&lt;FetchHttpFile&gt;d__0))</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">FetchHttpFile</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        &lt;FetchHttpFile&gt;d__0 stateMachine = <span class="keyword">default</span>(&lt;FetchHttpFile&gt;d__0);</span><br><span class="line">        stateMachine.&lt;&gt;t__builder = AsyncTaskMethodBuilder&lt;<span class="keyword">string</span>&gt;.Create();</span><br><span class="line">        stateMachine.&lt;&gt;<span class="number">1</span>__state = <span class="number">-1</span>;</span><br><span class="line">        AsyncTaskMethodBuilder&lt;<span class="keyword">string</span>&gt; &lt;&gt;t__builder = stateMachine.&lt;&gt;t__builder;</span><br><span class="line">        &lt;&gt;t__builder.Start(<span class="keyword">ref</span> stateMachine);</span><br><span class="line">        <span class="keyword">return</span> stateMachine.&lt;&gt;t__builder.Task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以仔细看看，这个代码一下就陡增到 90 多行了。我们下面来分析一下它们。</p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>下面我们来看下这个生成的代码，到底内部执行了哪些操作，又处理了什么。</p>
<h3 id="原方法部分"><a href="#原方法部分" class="headerlink" title="原方法部分"></a>原方法部分</h3><p>先来看原本的方法部分，虽然它会调用内部的执行操作，不过我们先看它是为了逻辑框架上更清晰。</p>
<p>这一部分有点难搞的地方在于，它的类型全部都是没办法看的，因为这些内容基本上都是被编译器自动生成了，所以我们只能翻译一下。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AsyncStateMachine(typeof(StateMachine))</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">FetchHttpFile</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stateMachine = <span class="keyword">default</span>(StateMachine); <span class="comment">// StateMachine</span></span><br><span class="line">    stateMachine.builder = AsyncTaskMethodBuilder&lt;<span class="keyword">string</span>&gt;.Create();</span><br><span class="line">    stateMachine.state = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> builder = stateMachine.builder; <span class="comment">// AsyncTaskMethodBuilder&lt;string&gt;</span></span><br><span class="line">    builder.Start(<span class="keyword">ref</span> stateMachine);</span><br><span class="line">    <span class="keyword">return</span> stateMachine.builder.Task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就比较清晰了。首先，它在原本的代码方法体里插入了一个状态机。什么是状态机呢？这一点的详细内容我们稍后再说，这里先大致认为是一个专门记录执行获取 HTTP 文件操作状态的一个对象。然后，</p>
<h3 id="状态机部分"><a href="#状态机部分" class="headerlink" title="状态机部分"></a>状态机部分</h3><p>这段代码稍微困难一些，因为内容非常多。我们只能一块一块地进行解读。</p>
<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>首先是三个字段：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> &lt;&gt;<span class="number">1</span>__state;</span><br><span class="line"><span class="keyword">public</span> AsyncTaskMethodBuilder&lt;<span class="keyword">string</span>&gt; &lt;&gt;t__builder;</span><br><span class="line"><span class="keyword">private</span> TaskAwaiter&lt;<span class="keyword">string</span>&gt; &lt;&gt;u__1;</span><br></pre></td></tr></table></figure>
<p>第一个字段是一个整数类型的变量，它在编译期间生成，用来表示一会儿执行状态机期间的状态；第二个字段叫 <code>builder</code>，是异步任务方法的生成器对象，它带有一个泛型参数 <code>string</code>，就是我们最初异步返回任务类型的方法里那个泛型参数；第三个字段表示一个 awaiter。awaiter 这个词到现在都不好翻译，你只需要知道 await 是异步等待的关键字，那么加入 -er 后缀就是表示这个任务需要异步等待的那一个对象。</p>
<blockquote>
<p>注意，awaiter 是一个对象，它专门用于等待异步任务的完成。</p>
</blockquote>
<h4 id="MoveNext-方法"><a href="#MoveNext-方法" class="headerlink" title="MoveNext 方法"></a><code>MoveNext</code> 方法</h4><p>下面来看下 <code>MoveNext</code> 方法。让我们先把里面一些写起来诡异的字段名改一下写法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MoveNext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">string</span> result;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        TaskAwaiter&lt;<span class="keyword">string</span>&gt; awaiter;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            awaiter = <span class="keyword">new</span> HttpClient().GetStringAsync(<span class="keyword">new</span> Uri(<span class="string">"www.baidu.com"</span>)).GetAwaiter();</span><br><span class="line">            <span class="keyword">if</span> (!awaiter.IsCompleted)</span><br><span class="line">            &#123;</span><br><span class="line">                num = <span class="keyword">this</span>.state = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">this</span>.awaiter = awaiter;</span><br><span class="line">                <span class="keyword">this</span>.builder.AwaitUnsafeOnCompleted(<span class="keyword">ref</span> awaiter, <span class="keyword">ref</span> <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            awaiter = <span class="keyword">this</span>.awaiter;</span><br><span class="line">            <span class="keyword">this</span>.awaiter = <span class="keyword">default</span>(TaskAwaiter&lt;<span class="keyword">string</span>&gt;);</span><br><span class="line">            num = (<span class="keyword">this</span>.state = <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = awaiter.GetResult();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception exception)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">this</span>.builder.SetException(exception);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">this</span>.builder.SetResult(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，它把状态机里生成的字段 <code>state</code> 取出来，赋值给 <code>num</code> 作为后面使用，然后创建了一个结果对象，就是我们需要提取的 HTTP 网页文件源代码的字符串变量 <code>result</code> 此时还没有赋值。</p>
<p>然后，它尝试去执行获取操作，写在 <code>try</code> 块里。在 <code>try</code> 块里，有一个异步等待的对象 <code>awaiter</code>，在当前状态不为 0 的时候，进入 <code>if</code> 条件，然后去获取异步 <code>Task&lt;T&gt;</code> 对象的 awaiter。这个时候，就可以把这个 <code>Task&lt;T&gt;</code> 的 awaiter 获取出来，赋值给这个 <code>try</code> 块里的临时变量了。</p>
<p>然后此时，立马判断这个执行任务是否已经完成。如果没有执行完毕，就会进入内部的 <code>if</code> 块，然后将当前状态和这个临时变量 <code>num</code> 改为 0，并把 awaiter 赋值给当前对象里的字段 <code>awaiter</code> 上去；接着，它会调用字段 <code>builder</code> 对象的 <code>AwaiteUnsafeOnCompleted</code> 方法，这个方法是用来做什么呢？查看资料就可以发现，它实际上是一个处理任务调度的方法，当指定的 awaiter 已经完成的时候，它就会调度任务，去执行处理下一个行为。</p>
<p>不过，在外层条件判断里，还有一个 <code>else</code> 块，它表示当任务已经完成的时候的行为。当任务已经在此处都做完了，就会立马把这些基本的执行行为的信息（诸如 <code>awaiter</code>、<code>state</code> 等等信息）统统赋值一次。</p>
<p>最后，不论是走 <code>if</code> 还是走 <code>else</code> 块，最终都会到 <code>result = awaiter.GetResult()</code> 操作，获取最终结果。注意，这个方法内部的实现较复杂，我们最终阐述一下结果：<strong>这个方法最终会阻塞程序执行，直到结果被得到</strong>。</p>
<p>当然，如果执行期间出现了异常，<code>catch</code> 块就会捕捉到，然后把异常塞进 <code>builder</code> 里去，并且把此时执行状态置为 -2，表示退出。</p>
<p>最后，除了 awaiter 尚未完成和抛出异常时，会立马退出程序之外，都会执行到最后，将状态改为 -2，表示退出，并且把结果塞进 <code>builder</code> 里，状态机的行为便执行完毕。可以从代码里看到，整个行为好像并没有体现出启动后台线程的操作，这些都在 <code>builder</code> 里为我们做好了一切，就在 <code>AwaitUnsafeOnCompleted</code> 方法的执行里。另外，状态机本身是不会抛出不被处理的异常的，哪怕出现异常，都是都被 <code>catch</code> 块处理，然后塞进 <code>builder</code> 里，推后到后续的某个位置才会抛出。</p>
<p>总的来说：<strong><code>async</code>/<code>await</code> 模式会在编译期生成一个状态机，记录当前操作执行状态。在执行过程之中，判断异步任务是否在此时此刻已经执行完毕。如果没有的话，就会把这个任务一并塞进 <code>builder</code> 里等待稍后的执行，但如果完成了的话，就会立马取出其结果，并塞进 <code>builder</code> 里，留着后续调用的时候获取结果；当最终没有完成的任务，将会立马放到最后开始执行，并阻塞当前线程</strong>。</p>
<h4 id="剩下的三个方法"><a href="#剩下的三个方法" class="headerlink" title="剩下的三个方法"></a>剩下的三个方法</h4><p>那么，剩下的三个方法的实现其实就不难理解了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IAsyncStateMachine.MoveNext()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in MoveNext</span></span><br><span class="line">    <span class="keyword">this</span>.MoveNext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DebuggerHidden</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetStateMachine</span>(<span class="params">IAsyncStateMachine stateMachine</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.builder.SetStateMachine(stateMachine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine</span></span><br><span class="line">    <span class="keyword">this</span>.SetStateMachine(stateMachine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>MoveNext</code> 方法用于实现接口对象，而它为什么非要单独用显式实现接口的模式来单独在外部创建对象，并在此实现呢？这是为了更好的封装性。这个方法一般不希望被外部调用，所以这里采用显式实现接口的方式，让外部必须知晓实现模型才能进行转换和调用；而内部调用到的 <code>MoveNext</code> 方法也是一个 <code>private</code> 的方法，这保证了完整的内部封装的模式。</p>
<p>然后在 <code>SetStateMachine</code> 方法里，它直接调用 <code>builder</code> 字段的 <code>SetStateMachine</code> 方法来设置状态机，最后使用显式实现接口的模式达到封装性。</p>
<h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><p>在前文里，我们完整描述了整个 <code>async</code> 方法在编译器里生成的所有内容的执行思路和操作，但依然存在一些逻辑上的漏洞。</p>
<h3 id="1、异步方法真的是异步执行和被调用的吗？"><a href="#1、异步方法真的是异步执行和被调用的吗？" class="headerlink" title="1、异步方法真的是异步执行和被调用的吗？"></a>1、异步方法真的是异步执行和被调用的吗？</h3><p>在调用层面来看，你可以观察到 <code>FetchHttpFile</code> 方法本被标注了 <code>async</code> 关键字，后面被编译器生成代码之后，却不见了。这告诉了我们，<code>async</code> 关键字只是一个关键字，它用于标记方法是可能被异步执行的，但调用期间却是同步调用的，并没有产生任何的后台线程。</p>
<p>不过，在执行的时候，系统会为其单独分配一个后台线程，执行内部“耗时”的操作。</p>
<h3 id="2、讲了这么多，都在说-async-关键字了，那么-await-关键字呢？"><a href="#2、讲了这么多，都在说-async-关键字了，那么-await-关键字呢？" class="headerlink" title="2、讲了这么多，都在说 async 关键字了，那么 await 关键字呢？"></a>2、讲了这么多，都在说 <code>async</code> 关键字了，那么 <code>await</code> 关键字呢？</h3><p>在原本的写法里，我们使用 <code>await</code> 关键字，嵌入到 <code>FetchHttpFile</code> 方法里，最后它生成了一大堆东西。不过 <code>await</code> 在前文并没有得到很好的解释。实际上，在前文里我们是不是提到了一个 <code>Task&lt;T&gt;</code> 对象，来表达一个可能耗时的任务？是的，这便是这个地方执行的关键。<code>await</code> 关键字用于获取这个任务里的 awaiter，然后取出执行结果。注意，在此期间，程序是开了后台线程并执行了这一套工作的，所以只是你看不到罢了。</p>
<p>当获取结果后，主线程才会继续向下执行，在前面没有执行完毕获取结果的操作前，主线程都是被阻塞的，而往往 UI 界面的线程都跑在主线程上，所以 UI 界面此时该卡死还卡死。后续我会介绍如何避免这样的情况发生。</p>
<h3 id="3、异步操作会造成程序死锁吗？"><a href="#3、异步操作会造成程序死锁吗？" class="headerlink" title="3、异步操作会造成程序死锁吗？"></a>3、异步操作会造成程序死锁吗？</h3><p>当线程处理期间，就一定存在死锁的问题需要我们去解决。死锁指的是两个或更多线程在相互调用期间，各自由于都在等待对方执行完毕释放资源，导致程序使用的全部的线程都在等待，引起的卡死的现象。在异步操作里，我们为了保证程序能够完整执行下去，而且还不阻塞主线程，就会使用 <code>async</code> 关键字来让耗时的操作去单独跑在一个线程上（注意，此时依旧我们会等待线程执行完毕反馈结果），然后最后执行完毕后，把结果取出来并显示的行为。这涉及到两个线程了。如果是 UI 线程的话，如果像是上面这么简单的实现，会不会出现死锁呢？</p>
<p>很遗憾，上述例子是会产生死锁的。它满足了整个项目产生死锁的两大充分不必要条件：</p>
<ol>
<li>调用 <code>Wait</code> 方法（一个用于阻塞任务执行的方法）或 <code>Result</code> 属性（相当于 <code>GetResult</code> 方法）的位置处于 UI 线程上；</li>
<li>任务执行在其它的后台线程上，而并不在和 UI 一样的线程上。</li>
</ol>
<p>那么为什么是这两个条件就可能死锁呢？回顾一下线程死锁的四大必要条件：</p>
<ol>
<li><strong>互斥</strong>：资源只能被一个资源使用，其它资源必须等待释放后才能继续使用；</li>
<li><strong>请求和保持</strong>：由于请求资源而阻塞时，对已获得的资源保持不放；</li>
<li><strong>让权等待</strong>：在执行期间，已获得的资源在末使用完之前，都不能被强行剥夺；</li>
<li><strong>循环等待</strong>：若干线程之间有循环的依赖关系。</li>
</ol>
<p>这四个条件是<strong>死锁的必要条件</strong>，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 观察上述两种说法就可以看出，<code>async</code> 执行模式是满足前三点的，而第四点到底是否满足呢？实际上是的，因为主线程（UI）会等待后台线程下载文件，而后台线程又会依赖主线程的执行（不然怎么可能单独跑一个后台线程呢），所以四大条件全部满足，必然是可能会存在死锁现象的发生的。</p>
<h3 id="4、我们应该如何修改代码去阻止可能产生的死锁呢？"><a href="#4、我们应该如何修改代码去阻止可能产生的死锁呢？" class="headerlink" title="4、我们应该如何修改代码去阻止可能产生的死锁呢？"></a>4、我们应该如何修改代码去阻止可能产生的死锁呢？</h3><p>为了避免线程死锁的问题，我们拥有一些合理的解决方案。不过先要我们来看下下面的问题。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Task <span class="title">RunAsync1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Some asynchronized operation.</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">RunAsync2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Some asynchronized operation.</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> Task <span class="title">RunAsync3</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Some asynchronized operation.</span></span><br><span class="line">    &#125;).ConfigureAwait(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面三个方法里，哪个（或哪些）方法会可能产生死锁？</p>
<p>答案是，只有第 2 个会产生死锁，而第 1 个和第 3 个都不会。原因如下：</p>
<p>第一个压根就没有使用 <code>async</code> 和 <code>await</code> 关键字，这使得编译器并不会给我们产生状态机和一大堆异步执行行为，所以好比任务是同步完成的。既然是在同一个线程上，为什么会死锁呢？</p>
<p>第三个有 <code>async</code> 和 <code>await</code> 关键字，而后续我们配备了 <code>ConfigureAwait</code> 方法，以此来为这个任务的执行分配新的线程，并让后续的执行行为直接全跑在这个线程上。默认的话，<code>ConfigureAwait</code> 的参数是为 <code>true</code> 的，这意味着在后续执行的操作，会重新返回到主线程上。但刚才说过，返回主线程执行后续操作就必然存在死锁的问题，所以我们为其设置 <code>ConfigureAwait(false)</code> 的话，执行的操作就会跑到随机分配的新的线程里去搞定它们，这样一来，甚至 UI 线程都不用返回到主线程去做了，因为它们都在随机分配好的新线程里在做这些东西了。所以这个时候，它们在执行期间就不会产生死锁了。</p>
<blockquote>
<p>实际上，后续怎么返回到上一个执行调用方线程，是通过一个叫做 <code>SynchronizationContext</code> 对象来搞定的，直译就是同步上下文，它记录了线程执行的调用顺序：是谁调用了异步方法的执行，并在什么线程上执行的。这些信息都在这个同步上下文里可以找到。有了这个对象，我们就可以轻松反推找到原来的执行方的线程信息了，所以 C# 采用的是这种操作来返回到主线程。当然，UI 线程使用的是一个叫做 <code>DispatcherSynchronizationContext</code> 的对象来搞的，不过这一点你在初步学习的时候知道有这么一个东西存在就好了。</p>
<p>由于指定了 <code>ConfigureAwait(false)</code>，这意味着通知异步状态机 <code>AsyncMethodStateMachine</code> 并不需要使用设置好的 <code>SynchronizationContext</code>（对于 UI 线程，是 <code>DispatcherSynchronizationContext</code>）执行线程同步，而是使用默认的 <code>SynchronizationContext</code>，而默认行为是随便找个线程执行后面的代码。于是，<code>await Task.Run</code> 后面的代码便不需要返回原线程，也就不会发生第 2 种情况里的死锁问题。 </p>
</blockquote>
<p>所以，当你安装了 <a href="https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/" target="_blank" rel="noopener">Microsoft.CodeAnalysis.FxCopAnalyzers</a> 编译器后，你就会发现，编译器自动会为你提出警告 CA2007，告诉你请你在使用异步行为的时候在其后面配置 <code>ConfigureAwait(false)</code> 来达到避免死锁的目的。如果你是类库的编写者，注意此问题能够一定程度上防止逗比使用者出现死锁问题后喷你的类库写得不好。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.iasyncstatemachine?view=netframework-4.8" target="_blank" rel="noopener">IAsyncStateMachine 接口</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.asyncstatemachineattribute?view=netframework-4.8" target="_blank" rel="noopener">AsyncStateMachineAttribute 特性</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.taskawaiter?view=netframework-4.8" target="_blank" rel="noopener">TaskAwaiter 结构</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.asynctaskmethodbuilder.awaitunsafeoncompleted?view=netframework-4.8" target="_blank" rel="noopener">AwaitUnsafeOnCompleted<TAwaiter, TStateMachine> 方法</a></li>
<li><a href="https://blog.walterlv.com/post/deadlock-in-task-wait.html" target="_blank" rel="noopener">使用 Task.Wait()? 立即死锁</a>（博文）</li>
<li><a href="https://blog.walterlv.com/post/using-configure-await-to-avoid-deadlocks.html" target="_blank" rel="noopener">使用 ConfigureAwait(bool) 避免死锁</a>（博文）</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E5%85%B3%E9%94%AE%E5%AD%97/">C♯.关键字</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/C♯-编译器生成/">C♯.编译器生成</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/17/clang-04-switch-statement/" title="C 语言语法系列（4）：switch 语句" itemprop="url">C 语言语法系列（4）：switch 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-17T07:38:08.000Z" itemprop="datePublished"> 发表于 2019-11-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="if-的弊端"><a href="#if-的弊端" class="headerlink" title="if 的弊端"></a><code>if</code> 的弊端</h2><p>很多时候，<code>if</code> 给我们的使用带来了方便的地方，但是依旧有点丑的是，我们经常会用到同一个变量分情况讨论的时候，但 <code>if</code> 非要写成 <code>if</code> 串联的模式，这样就很丑。于是，我们引入了新的语法格式：<code>switch</code> 语句。</p>
<h2 id="switch-语句的写法"><a href="#switch-语句的写法" class="headerlink" title="switch 语句的写法"></a><code>switch</code> 语句的写法</h2><p>考虑如下 <code>if</code> 串联写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">    c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">    c = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">5</span>)</span><br><span class="line">    c = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    c = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<p>当我们需要判断相同的一个变量的不同数值时，我们可以考虑使用 <code>switch</code> 语句来书写，它在转换后是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        c = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        c = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        c = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// This one can not be written.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码里看到，它可能比原本的写法更臃肿了，但代码更清晰了。按照 <code>a</code> 分情况讨论。当 <code>a</code> 值为 2 的时候，执行 <code>c = 1</code> 的赋值操作；其它的同理。<code>default</code> 用来控制其它所有情况，类似于 <code>if</code> 里的 <code>else</code> 条件后没有其它判别情况时的执行操作。</p>
<p>还需要注意的是，每一个 <code>case</code> 语句的最后都有一个冒号，而且在每一个部分结束的时候，都有一个 <code>break</code> 语句作为结束（写法必须是 <code>break;</code>，即末尾带分号）。这是两个需要注意的地方。</p>
<p>另外，标签之间必须书写 <code>break</code> 是有道理的。如果不写它的话，语句就会贯穿到下一个部分去执行，所以不是非常好。但有些时候，我们也可以考虑使用这种特性来做事情。比如，我们获取 12 个月每一个月多少天的时候，可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (month)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"31\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"28\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"30\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Month value is not valid.\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// This one can not be written.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们暂且不考虑闰年还是平年，2 月分情况讨论的结果。这样的写法可以看到，像是 1、3、5、7、8、10、12 月，结果都是一样的，所以我们完全不必在中间给它加上 <code>break</code>。</p>
<p>当然，<code>default</code> 不一定要放在最后面。有些时候我们可能期望默认执行的情况和其中某个数值的执行情况是一样的，这个时候我们可以把 <code>default</code> 调整到前面去。</p>
<p>比如，我们需要在记录成绩等级（A 到 F）的时候，默认把其它情况和不及格显示成一样的结果（F），我们就可以这么做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">67</span>;</span><br><span class="line"><span class="keyword">switch</span> (score / <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"F\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"E\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"D\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"C\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"B\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">// Only for 100.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>switch</code> 的小括号里的东西可以是任意一个整数数值的表达式，比如这个例子里的值就是 <code>score / 10</code>，算出来等于 6。</p>
<blockquote>
<p>注意，之前说过，67 和 10 都是整数，所以计算的除法一定得到的结果是整数，故得到的 6.7 会被截断为 6，而且截断不是四舍五入。</p>
</blockquote>
<h2 id="贯穿标签的用法"><a href="#贯穿标签的用法" class="headerlink" title="贯穿标签的用法"></a>贯穿标签的用法</h2><p>在前文里，所有 <code>case</code> 语句 <code>default</code> 都被称为标签。当有些时候，我们迫不得已需要贯穿标签，所以出现了前文的合并同类项的类似格式。但有些时候，我们除了这种贯穿模式之外，还有一种情况可以这么用，即不写 <code>break</code> 语句。</p>
<p>给定 <code>month</code> 数值表示当前月份，求从 1 月份到这个月一共多少天（暂不考虑日期是多少）。那么代码可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (month)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        result += <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// Note this break sentence.</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        result = <span class="number">0</span>; <span class="comment">// We use 0 to let user know his input value is invalid.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以思考一下，为什么这种模式可以不写 <code>break</code> 语句。</p>
<h2 id="缺乏不等模式判断"><a href="#缺乏不等模式判断" class="headerlink" title="缺乏不等模式判断"></a>缺乏不等模式判断</h2><p><code>switch</code> 有一个缺点在于，它没有不等模式的判别，比如我们希望某个数字在 0 到 60 的时候是差， 61 到 80 的时候是中等，81 到 90 的时候是良好，91 到 100 是优秀。这个时候，我们只能使用 <code>if</code> 语句的串联，<code>switch</code> 很抱歉的是，在这一点并没有提供对应的语法判别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (score &lt;= <span class="number">60</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bad\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;= <span class="number">80</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Not bad\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;= <span class="number">90</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Awesome!\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Excellent!!\n"</span>);</span><br></pre></td></tr></table></figure>
<p>上述即可判断。你需要思考一点，为什么 <code>if</code> 判别里写的是 <code>score &lt;= 某数值</code> 呢？比如 61 到 80，不应该写成 <code>score &gt;= 61 &amp;&amp; score &lt;= 80</code> 才对吗？</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>




  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页 ↓</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="Sunnie-Shine" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>



  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/C♯/" title="C♯">C♯<sup>22</sup></a></li>
			
		
			
				<li><a href="/tags/LINQ/" title="LINQ">LINQ<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/SQL/" title="SQL">SQL<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/数学/" title="数学">数学<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/数独/" title="数独">数独<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-编译器生成/" title="C♯.编译器生成">C♯.编译器生成<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-8/" title="C♯ 8">C♯ 8<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/ASP/" title="ASP">ASP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/诗词/" title="诗词">诗词<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/安卓/" title="安卓">安卓<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/并发/" title="并发">并发<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/TODO/" title="TODO">TODO<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GDI/" title="GDI+">GDI+<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://sunniesudoku.cn/" target="_blank" title="向向的数独文档库">向向的数独文档库</a>
            
          </li>
        
          <li>
            
            	<a href="http://tieba.baidu.com/f?kw=%CA%FD%B6%C0" target="_blank" title="数独贴吧">数独贴吧</a>
            
          </li>
        
          <li>
            
            	<a href="https://space.bilibili.com/23736703" target="_blank" title="Bilibili">Bilibili</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m Sunnie. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/Sunnie-Shine" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/Sunnie-Shine" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
	</div>
			
		

		<p class="copyright">
		Copyright © 2019 
		
		<a href="/about" target="_blank" title="向向">向向</a>
		
		<br />
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a>
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript"
  async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
