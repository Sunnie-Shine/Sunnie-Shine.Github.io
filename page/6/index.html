
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>向向的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="向向">
    

    
    <meta name="description" content="This is my blog...">
<meta property="og:type" content="website">
<meta property="og:title" content="向向的博客">
<meta property="og:url" content="https:&#x2F;&#x2F;sunnie-shine.github.io&#x2F;page&#x2F;6&#x2F;index.html">
<meta property="og:site_name" content="向向的博客">
<meta property="og:description" content="This is my blog...">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="向向的博客" title="向向的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="向向的博客">向向的博客</a></h1>
				<h2 class="blog-motto">Console.WriteLine(&#34;Hello, ^_^&#34;);</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">全部文档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:Sunnie-Shine.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/csharp-default-interface/" title="C# 8 里的默认接口实现" itemprop="url">C# 8 里的默认接口实现</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T01:37:49.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="接口基础知识"><a href="#接口基础知识" class="headerlink" title="接口基础知识"></a>接口基础知识</h2><p>接口是一种面向对象编程 OOP 的语法机制，它和抽象类不同的地方在于，它需要你完全实现接口里给出的全部方法集合。</p>
<p>比如如下给定一个坐标对对象 <code>Point</code>，实现代码全部给出：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> row, <span class="keyword">int</span> column</span>)</span> =&gt; (Row, Column) = (row, column);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Row &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Column &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; (Row, Column).ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这些写法比较新，用的是 C# 6 提供的更多成员的 Lambda 实现模式以及 C# 7 给的元组模式来对位赋值，以及值元组类型 <code>ValueTuple&lt;...&gt;</code>。</p>
<p>显然，这个 API 太过于简单，我们还没有实现更多的东西。由于坐标对对象明显可以比较相等（只要行列的数值都相同，就可以认为坐标对对象是一样的），但我们为了后续可以告诉其它程序员，这个 API 可以提供比较和字典比较这些操作，我们需要实现 <code>IEquatable&lt;T&gt;</code> 接口来保证对象可以使用比较判断。</p>
<p>接着，设置好所有的重写方法和操作符重载：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Point : IEquatable&lt;Point&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> row, <span class="keyword">int</span> column</span>)</span> =&gt; (Row, Column) = (row, column);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Row &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Column &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span>? obj</span>)</span> =&gt; obj <span class="keyword">is</span> Point p &amp;&amp; Equals(p);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">Point other</span>)</span> =&gt; Row == other.Row &amp;&amp; Column == other.Column;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; (Row, Column).ToString();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span> =&gt; Row ^ Column;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point left, Point right) =&gt; left.Equals(right);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(Point left, Point right) =&gt; !left.Equals(right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先大致不用去看具体实现，因为我们这里的侧重点不是实现，而是接口。</p>
<p>当然，如果你不希望对方调用这个 <code>Equals</code> 方法的话，请把实现的方法改为显式实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> IEquatable&lt;Point&gt;.Equals(Point other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Row == other.Row &amp;&amp; Column == other.Column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>接口名.方法名</code> 来表示实现的接口，并且返回值前强制不加 <code>public</code>，因为接口里的方法在实现起来必然是 <code>public</code> 的，完全不必写出来。</p>
<h2 id="什么是默认接口实现？"><a href="#什么是默认接口实现？" class="headerlink" title="什么是默认接口实现？"></a>什么是默认接口实现？</h2><p>当我们需要的接口具有通用性，但又不是非要实现的话，我们就可以使用默认实现，类似于类里的虚方法。比如，我们完全可以使用给定的 <code>GetHashCode</code> 方法来判断对象是否数值上相等，于是我们就可以写一个接口，又不必实现，只需要这么写：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface IEquatableDefault&lt;in T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Default interface implementation.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">[MaybeNull] T other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> GetHashCode() == other.GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，我们就不必再每次都实现接口的方法了。把原来的 API 修改一下即可：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Point : IEquatableDefault&lt;Point&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> row, <span class="keyword">int</span> column</span>)</span> =&gt; (Row, Column) = (row, column);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Row &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Column &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span>? obj</span>)</span> =&gt; obj <span class="keyword">is</span> Point p &amp;&amp; Equals(p);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">Point other</span>)</span> =&gt; ((IEquatableDefault&lt;Point&gt;)<span class="keyword">this</span>).Equals(other);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; (Row, Column).ToString();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span> =&gt; Row ^ Column;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point left, Point right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ((IEquatableDefault&lt;Point&gt;)left).Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(Point left, Point right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !((IEquatableDefault&lt;Point&gt;)left).Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但请注意，接口默认的实现规则使得必须先把调用对象转为对应接口对象，然后才能调用。这是因为对象使用的默认方法实现，而实现机制要求你需要转换回接口，才能使用该方法，类似于显式实现的接口。</p>
<h2 id="重新实现接口"><a href="#重新实现接口" class="headerlink" title="重新实现接口"></a>重新实现接口</h2><h3 id="类重新实现基接口的成员"><a href="#类重新实现基接口的成员" class="headerlink" title="类重新实现基接口的成员"></a>类重新实现基接口的成员</h3><p>在前文给出的实现机制下，我们显然发现，这个 <code>GetHashCode</code> 写起来有点不太对，因为它直接异或运算得到的结果来比较，这一点不是很好。所以我们尝试去把原本接口里实现的方式进行修改。</p>
<p>我们尝试在 <code>Point</code> 里加入显式接口实现：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> IEquatableDefault&lt;Point&gt;.Equals(Point other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Row == other.Row &amp;&amp; Column == other.Column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一点和虚方法的重写不同，它不需要添加 <code>override</code> 关键字，因为它是属于接口层面的实现（之前的接口实现从来就没有写过 <code>override</code> 关键字，所以此时这里也是一样）。</p>
<p>然后，它就替换掉原本接口里的默认实现了。也就是说，如果我们尝试调用原本 API 的 <code>Equals</code> 方法，由于它调用的是接口的 <code>Equals</code> 方法的实现，而此时已经被重写，所以调用的实际上是上面这个重写后的显式接口实现的方法。</p>
<p>那么，原本接口内的方法就变成了类似于虚方法的机制了，当然，这只是”类似于“。</p>
<h3 id="接口重新实现基接口的成员"><a href="#接口重新实现基接口的成员" class="headerlink" title="接口重新实现基接口的成员"></a>接口重新实现基接口的成员</h3><p>下面来看另外一种情况。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface IEquatableDefault&lt;T&gt; : IEquatable&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> IEquatable&lt;T&gt;.Equals([AllowNull] T other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> GetHashCode() == other.GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的实现模式就可以把基类的 <code>Equals</code> 方法实现掉。不过这样的实现模式就不允许在类里重写方法了。因为显式接口实现是不允许重写的，否则将会产生如下的报错：</p>
<p><img src="error-info.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CS0539:</span><br><span class="line">&apos;Point.Equals(Point)&apos; in explicit interface declaration</span><br><span class="line">is not found among members of the interface that can be implemented.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从报错的编码就可以看出，实际上它并不是一种新的错误类型，而是之前的错误类型：不允许重写显式实现的方法。当你显式实现了一个接口里并不含有的方法时，就会产生这个错误，例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">I</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clx</span> : <span class="title">I</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> I.X() <span class="comment">// CS0539</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便会产生 CS0539 错误。而从上面的文章示例可以看出，由于你显式实现的原接口 <code>IEquatable&lt;T&gt;</code> 的方法，所以类里就无法进行重写，因为这个显式实现并非 <code>IEquatableDefault&lt;T&gt;</code> 类里的元素（或者说，这个显式实现具有良好的封装性）。</p>
</blockquote>
<h2 id="使用其它访问修饰符成员的支持"><a href="#使用其它访问修饰符成员的支持" class="headerlink" title="使用其它访问修饰符成员的支持"></a>使用其它访问修饰符成员的支持</h2><p>当然，这一次默认接口实现的特性还添加了对其它访问修饰符成员的支持。你可以在接口里自行声明 <code>private</code>、<code>private protected</code>、<code>protected</code>、<code>protected internal</code>、<code>internal</code> 或 <code>public</code> 的默认接口成员的实现。不过，用法和前文介绍的默认接口实现的机制基本上一样，除了一点，就是访问修饰符的级别而已。</p>
<h2 id="静态成员的支持"><a href="#静态成员的支持" class="headerlink" title="静态成员的支持"></a>静态成员的支持</h2><p>除此之外，默认接口实现还支持静态成员。举个例子。类似于上文的 <code>Point</code> 对象，我们完全可以默认实现一个 <code>Parse</code> 执行的静态方法。</p>
<p>比方说，我们可以写一个模块，专门用于实现 <code>Point</code> 类型用字符串转换的解析操作，我们可以这么设计接口的 API。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPointParsable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">Parse</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> match = <span class="keyword">new</span> Regex(<span class="string">@"\(\d+,\s*\d+\)"</span>).Match(str);</span><br><span class="line">        <span class="keyword">if</span> (match.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> digitPair = <span class="keyword">new</span> Regex(<span class="string">@"\d+"</span>).Matches(match.Value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Point(</span><br><span class="line">                <span class="keyword">int</span>.Parse(digitPair[<span class="number">0</span>].Value),</span><br><span class="line">                <span class="keyword">int</span>.Parse(digitPair[<span class="number">1</span>].Value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"Parse failed."</span>, <span class="keyword">nameof</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">TryParse</span>(<span class="params"><span class="keyword">string</span> str, [NotNullWhen(<span class="literal">true</span></span>)] <span class="keyword">out</span> Point? result)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = Parse(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="keyword">default</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过调用的时候就只能这么书写了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pt = IPointParsable.Parse(<span class="string">"(3, 5)"</span>);</span><br></pre></td></tr></table></figure>
<p>即使用 <code>接口名.静态方法名</code> 来调用。这一点确实有点让人不爽，还不如把方法直接写进结构里，哪怕在前期使用单独的静态类加静态方法，也可以使用 <code>静态类名.静态方法名</code> 依然可以解决，所以这个功能目前来说还不是很有用处。</p>
<h2 id="实现和重抽象化成员"><a href="#实现和重抽象化成员" class="headerlink" title="* 实现和重抽象化成员"></a>* 实现和重抽象化成员</h2><p>在官方给出的提案里，是提到了<strong>重写基默认接口成员的方法</strong>（Override）和<strong>重抽象</strong>（Re-abstraction）的内容，不过在目前的 C# 8 里全部尚不可以使用。所以这个坑就只能等到语法层面更新的时候才能继续往下写了。现在先给出一点概念。</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写基接口成员的方法，官方给出的方案是通过 <code>override</code> 的方式提供显式和隐式实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">"IA.M"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IB</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">void</span> IA.M() =&gt; Console.WriteLine(<span class="string">"IB.M"</span>); <span class="comment">// explicitly named</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IC</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">"IC.M"</span>); <span class="comment">// implicitly named</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上述示例里，<code>IA</code> 接口里有一个实现，在派生接口里，都得到了重写实现，它们都加上了 <code>override</code> 关键字，即使是显式实现的。</p>
<blockquote>
<p>不过从前文可以得知，目前想要实现基接口里的成员，必须使用显式接口实现，隐式目前还不支持。</p>
</blockquote>
<h3 id="重抽象"><a href="#重抽象" class="headerlink" title="重抽象"></a>重抽象</h3><p>你甚至支持在派生接口里重新把原本实现的操作再次抽象掉，这样在继续派生的话，就必须给出实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> &#123; WriteLine(<span class="string">"IA.M"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IB</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="keyword">void</span> IA.M();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">C</span> : <span class="title">IB</span> &#123; &#125; <span class="comment">// error: class 'C' does not implement 'IA.M'.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过，目前的重抽象是否被允许，还是一个遗留问题（Open issue），甚至 <code>IB</code> 接口里的显式实现到底应该写作 <code>abstract override</code> 还是 <code>abstract</code> 现在还没有给出结论。</p>
</blockquote>
<h3 id="菱形结构"><a href="#菱形结构" class="headerlink" title="菱形结构"></a>菱形结构</h3><p>当允许了上述的逻辑时，就必然会产生菱形结构：即某个类型继承自两个不同的接口，但两个不同的接口又同时实现了同一个接口的行为，且实现方式不同。</p>
<p>那么此时，这个所谓的“某个类型”到底是取哪一个接口的实现行为才应该是合理的呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(IA)&#125;</span>.<span class="subst">&#123;<span class="keyword">nameof</span>(Method)&#125;</span>()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IB</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IA.Method() =&gt; Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(IB)&#125;</span>.<span class="subst">&#123;<span class="keyword">nameof</span>(Method)&#125;</span>()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IC</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IA.Method() =&gt; Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(IC)&#125;</span>.<span class="subst">&#123;<span class="keyword">nameof</span>(Method)&#125;</span>()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class</span> : <span class="title">IB</span>, <span class="title">IC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ???</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，<code>Class</code> 里会报错，报错信息是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CS8705:</span><br><span class="line">Interface memeber &apos;IA.Method()&apos; does not have a most specific implementation.</span><br><span class="line">Neither &apos;IB.IA.Method()&apos;, nor &apos;IC.IA.Method()&apos; are most specific.</span><br></pre></td></tr></table></figure>
<p>提示信息的意思是，你现在使用的 <code>Class</code> 类实现了两个相似的接口 <code>IB</code> 和 <code>IC</code>，而它们全部显式实现了 <code>IA</code> 接口里的 <code>Method</code> 方法。但问题在于，它们都是显式接口实现，这都不是“真正实现”的方法。这样确实也防止了菱形结构的模棱两可的情况。</p>
<h3 id="该不该加-virtual-关键字？"><a href="#该不该加-virtual-关键字？" class="headerlink" title="该不该加 virtual 关键字？"></a>该不该加 <code>virtual</code> 关键字？</h3><p>前文用到的实现哪怕加入了 <code>override</code> 关键字来表达重写，但依旧不知道是否需要添加 <code>virtual</code> 关键字支持。从目前来说，在 IDE 里你完全可以添加 <code>virtual</code> 关键字，但实际上这个关键字加了当没加。因为加不加，都可以允许你显式实现接口成员，因此没有区别。但以后就不一定了，因为可能会出现 <code>override</code> 的情况，这样就可能出现前文提到了隐式实现模式和重抽象，这一点就完全可能会出现和体现 <code>virtual</code> 的功能了。</p>
<h3 id="指定基接口调用和实现"><a href="#指定基接口调用和实现" class="headerlink" title="指定基接口调用和实现"></a>指定基接口调用和实现</h3><p>在重写和重抽象的时候，我们可以使用 <code>base</code> 关键字指明你调用的是哪个基接口的对象的成员，不过目前也不支持，貌似等到 C# 9 才会出现了。目前有两种调用机制：<code>base(接口名).成员名</code> 和 <code>base&lt;接口名&gt;.成员名</code>。 </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://sunnie-shine.github.io/2019/11/08/common-01-nullable-types/#可空引用类型">可空引用类型</a>（博文）</li>
<li><a href="https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/default-interface-methods.md" target="_blank" rel="noopener">默认接口实现的提案</a>（GitHub “CSharplang” repo 里的提案）</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/misc/cs0539" target="_blank" rel="noopener">CS0539 错误</a></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E8%AF%AD%E6%B3%95/">C♯.语法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/C♯-8/">C♯ 8</a><a href="/tags/TODO/">TODO</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/clang-06-do-while-loop/" title="C 语言语法系列（6）：do-while 语句" itemprop="url">C 语言语法系列（6）：do-while 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T01:13:18.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="改下上一个例子的代码"><a href="#改下上一个例子的代码" class="headerlink" title="改下上一个例子的代码"></a>改下上一个例子的代码</h2><p>在求得 1 到 100 的和的计算结果的时候，我们明显知道 <code>i</code> 第一次的初始数值（即 1）是不可能超过 100 的，所以第一次完全不必判断这个条件。</p>
<p>正是因为这样，我们便产生了 <code>do-while</code> 语句。在提及代码的写法格式之前，我们先来看一下它的执行逻辑，如下图所示。</p>
<p><img src="do-while-loop-example.png" alt=""></p>
<h2 id="do-while-（循环）语句"><a href="#do-while-（循环）语句" class="headerlink" title="do-while （循环）语句"></a><code>do-while</code> （循环）语句</h2><p>下面我们来看一下 <code>do-while</code> 语句的执行逻辑和代码规范。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    S += i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>这种写法把条件进行了后置处理，所以执行 <code>S += i++;</code> 操作是无条件都会执行至少一次的。然后执行后才会判断数值 <code>i</code> 是否不超过 100。</p>
<p>不过，此时的大括号最好就不要省略了，虽然编译器依旧允许你这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    S += i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>甚至</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> S += i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> S += i++; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>这两种写法虽然没什么问题，不过不建议这么书写是因为代码不太好看。</p>
<p>一定要注意，语法格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    loopExecutingSentence;</span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>
<p>里面的末端，写了括号和条件 <code>condition</code> 后，还要加上分号，标记整体是一个语句的结束。</p>
<h2 id="while-和-do-while-的异同"><a href="#while-和-do-while-的异同" class="headerlink" title="while 和 do-while 的异同"></a><code>while</code> 和 <code>do-while</code> 的异同</h2><p>从两种书写格式来看，<code>while</code> 的条件是前置的，而 <code>do-while</code> 的条件则是后置的，这使得条件判断的位置不同。C 语言的执行是从上到下的，所以遇到这些条件的机会和方式不同，<code>while</code> 是不论如何都会先判断条件，当条件成立的时候执行对应大括号里的内容，但条件如果不满足，则不会执行内部的语句。所以 <code>while</code> 语句的重复执行部分很有可能一次都不会去执行；但 <code>do-while</code> 不一样，它的条件被放到后面，这使得重复执行的代码不论如何都会先被执行一次，然后才会判断条件。所以 <code>do-while</code> 语句的重复执行部分最少都会执行一次。</p>
<p>除此之外，它们并无什么不同。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/clang-05-while-loop/" title="C 语言语法系列（5）：while 语句" itemprop="url">C 语言语法系列（5）：while 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T00:21:22.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="循环是什么？"><a href="#循环是什么？" class="headerlink" title="循环是什么？"></a>循环是什么？</h2><p>在我们写代码的时候，难免遇到重复的操作。例如我想尝试从 1 到 100 求和。但显然，数学公式可以解决这一点：</p>
<script type="math/tex; mode=display">
S_n = \frac{n(n - 1)}2</script><p>显然，这种模式完全可以解决这个问题。不过，从代码的角度来看，我们也可以尝试让电脑计算 100 次求和的操作，这样依然可以解决，而且电脑运算得很快，所以我们完全可以忽略 100 次重复计算和一次计算公式得到结果的时间差。这个时间差我们完全感觉不到。</p>
<p>那么，如何进行重复性的运算呢？我们先理清楚执行思路：</p>
<p><img src="while-loop-example.png" alt=""></p>
<p>如图所示，我们首先为 <code>i</code> 和 <code>S</code> 赋值，这些数值在后续都会使用到，这个称为初始值。然后，我们尝试先判断一次是否这个数字 <code>i</code> 超过了 100。如果没有超过，我们就执行第一次把 <code>i</code> 累加到 <code>S</code> 之中。可见 <code>S</code> 表示整个计算的和值结果。接着，<code>i</code> 增大一个单位。于是，我们重新作一次判断，看此时的 <code>i</code> 是否超过了 100（超过 100 就不计算在内了）。如果没有超过，就重复操作，继续把 <code>i</code> 的新数值累加到 <code>S</code> 之中，并再次增大 <code>i</code> 一个单位；如果 <code>i</code> 已经超过了 100，整个计算的活动行为就结束了。于是我们此时输出 <code>S</code> 的结果，并退出程序，整个程序执行完毕。</p>
<p>看得出来，这个逻辑是比较清楚的。</p>
<h2 id="while-（循环）语句"><a href="#while-（循环）语句" class="headerlink" title="while （循环）语句"></a><code>while</code> （循环）语句</h2><p>说完基本的计算思路，下面我们来说说它的代码的语法格式。</p>
<h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p><code>while</code> 语句可以解决上述的写法。我们尝试来看一下整体的逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        S += i;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们依旧尝试为 <code>i</code> 和 <code>S</code> 进行初始赋值，然后直接进入循环部分。当 <code>i</code> 不超过 100 的时候，就进行累加，并且要增大 <code>i</code> 变量的数值。最后执行完毕后，输出 <code>S</code> 的结果即可。</p>
<p>由此可见，这个类型的执行逻辑还是比较清晰的。有一点看起来像是瑕疵的地方在于，我们明明知道 <code>i</code> 此时初始数值是 1，没有超过 100，而为什么非要在最开始就写上判断条件 <code>i &lt;= 100</code> 来判断是否小于等于 100 呢？这不是废话吗？</p>
<p>实际上，这个程序当你输入了一个无效的数值时，比如 107，这个时候根本不可能计算从 107 到 100 的和（我们的目的是从 1 增大到 100，而 107 超过了 100），所以直接就退出了循环。另外，<code>while</code> 语句的格式要求把条件放到最开始，所以我们不得不这么做。</p>
<p>所以，总的来说，<code>while</code> 语句的写法是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    loopExecutingSentence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>while</code> 旁边写执行的元素的判断条件，然后在大括号里写上执行反复操作的语句。</p>
<blockquote>
<p><code>while</code> 语句也经常被称为 <code>while</code> 循环。</p>
</blockquote>
<h3 id="作出优化"><a href="#作出优化" class="headerlink" title="作出优化"></a>作出优化</h3><p>显然，在前文我们学习了自增自减运算符的前后缀书写方式的计算问题。当 <code>++</code> 写在变量之后，则表示变量在使用完成后最后增大一个单位。这使得我们原本需要写成两句话的语句可以写成一句话：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S += i++;</span><br></pre></td></tr></table></figure>
<p>这个写法等价于先执行 <code>sum += i;</code> 语句，然后执行 <code>i++;</code> 语句增大 <code>i</code> 变量一个单位。</p>
<p>所以，<code>while</code> 语句和 <code>if</code> 执行的模式完全一样，如果重复执行的语句只有一个语句，则可以省略大括号，所以上述写法融入到 <code>while</code> 里则可以写成这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>)</span><br><span class="line">    S += i++;</span><br></pre></td></tr></table></figure>
<h2 id="另外一个示例"><a href="#另外一个示例" class="headerlink" title="另外一个示例"></a>另外一个示例</h2><p>下面我们来看另外一则示例。我们还是用求和的思路来讲解，不过我们稍作改动。如果我们要计算从 1 到某个数的和，不过问题变为了”请求出从 1 到 $n$ 的所有整数的和 $S$ 在<strong>第一次</strong>超过 2400 的时候，此时的 $n$ 的值“。这个问题怎么解决呢？</p>
<p>实际上，可能你想得很复杂。我们知道，<code>while</code> 语句的写法是一个条件加上重复运算的语句，所以这个题目完全可以只修改执行的条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (S &lt;= <span class="number">2400</span>) <span class="comment">// Note here.</span></span><br><span class="line">    S += i++;</span><br></pre></td></tr></table></figure>
<p>注意条件改为了 <code>S &lt;= 2400</code>，其它的地方都没变化。最后只需要输出 <code>i</code> 的结果就可以了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/18/csharplang-complement-04-enum/" title="C# 语法查漏补缺系列（4）：枚举类型" itemprop="url">C# 语法查漏补缺系列（4）：枚举类型</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-18T11:47:37.000Z" itemprop="datePublished"> 发表于 2019-11-18</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="枚举类型是什么？"><a href="#枚举类型是什么？" class="headerlink" title="枚举类型是什么？"></a>枚举类型是什么？</h2><p>在搞懂枚举类型之前，我们先要搞清楚，什么是<strong>枚举</strong>（Enumeration）。枚举是一种机制，它将整数用更容易理解的自定义词汇表达，来表现数据的灵活性。最常见的枚举的使用就是表示执行程序的状态了。比如，程序分启动、运行、退出三种大状态，所以我们可以把它们三个情况用 <code>Start</code>、<code>Running</code> 和 <code>End</code> 三个单词表达出来。但计算机并不识别单词，所以我们不得不用数字表达，于是，我们便建立起了数字和单词的关系和映射。</p>
<p>在使用的时候，我们就不必使用枯燥的数字来表示一个运行状态了。这就是枚举的产生。当然，<strong>枚举类型</strong>（Enumeration Type）就是这个枚举的名称，比如程序状态类型 <code>ExecutingStatus</code>。</p>
<h2 id="枚举类型的使用"><a href="#枚举类型的使用" class="headerlink" title="枚举类型的使用"></a>枚举类型的使用</h2><h3 id="枚举类型的语法"><a href="#枚举类型的语法" class="headerlink" title="枚举类型的语法"></a>枚举类型的语法</h3><p>在 C# 里，枚举类型是这么书写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符] enum 枚举类型名[ : 整数类型]</span><br><span class="line">&#123;</span><br><span class="line">    枚举值1[ = 值1],</span><br><span class="line">    枚举值2[ = 值2],</span><br><span class="line">    枚举值3[ = 值3],</span><br><span class="line">    ...</span><br><span class="line">    枚举值n[ = 值n,]</span><br><span class="line">&#125;[;]</span><br></pre></td></tr></table></figure>
<p>其中所有的中括号内的东西都可以不写。比如，程序执行状态的类型 <code>ExecutingStatus</code> 就可以表达为</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ExecutingStatus : <span class="keyword">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    Start, <span class="comment">// Default value is 0.</span></span><br><span class="line">    Running, <span class="comment">// Default value is Start + 1.</span></span><br><span class="line">    End, <span class="comment">// Default value is Running + 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你不写第一个变量的枚举的等价数值时，系统默认为你分配为 0，当然你也可以给出一个非 0 数据来表示起始数值。但尽量使用 0，因为枚举如果没有 0 的话，后面写代码就可能会产生很隐蔽的错误，这一点我们稍后说明。另外，后面的任意一个数据不给等价数值的时候，默认是它前一个枚举类型的数值再加上 1 的结果。比如这里的三个枚举值分别就是 0、1、2。</p>
<p>另外，如果枚举类型的数值用得不是很大，我们为了节约内存，甚至可以为其设置枚举类型的数值范围，方法是在枚举类型名后跟上一个冒号，加上指定类型的范围的整数类型名称（可以是 <code>byte</code>、<code>sbyte</code>、<code>int</code>、<code>short</code>、<code>long</code>、<code>uint</code>、<code>ushort</code>、<code>ulong</code> 这些类型）。</p>
<p>由于整个大括号的关系，整体末尾的分号可以不写。</p>
<p>那么，我们就可以使用枚举类型了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (thread.CurrentStatus == ExecutingStatus.Running)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Means the current status is running.</span></span><br><span class="line">    <span class="comment">// We can do something such as abort the execution.</span></span><br><span class="line">    thread.Abort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上面这种用法（只是一个举例），如果当前线程还在跑的话，我们就中止这个线程。</p>
<h3 id="枚举类型的原理"><a href="#枚举类型的原理" class="headerlink" title="枚举类型的原理"></a>枚举类型的原理</h3><p>就枚举类型这一点来说，它可能比 Java 做得好。Java 的枚举类型是通过类实现的，这样使得枚举这种轻量级的东西变得非常“臃肿”。而 C# 里，枚举类型用的是值类型。在 C# 里，值类型认为是一些基础的、原子的类型（即元素不可拆分）。而这种类型通过调用栈来分配内存，使得比类的内存分配要快一点，而且要轻量级一些。</p>
<p>实际上，枚举可以在某种程度上认为是整数类型的等价封装。因为 C# 只是提供了一种将有意义的标识符来替换掉原本枯燥的数字，所以可以这么认为。</p>
<h3 id="枚举类型、数值和字符串三者的转换"><a href="#枚举类型、数值和字符串三者的转换" class="headerlink" title="枚举类型、数值和字符串三者的转换"></a>枚举类型、数值和字符串三者的转换</h3><p>枚举类型在编译期之前，可以使用显隐式转换，转换为对应的数值类型。比如，前文我们把 <code>ExecutingStatus</code> 类型设置为 <code>byte</code> 类型的数值范围，因为它只有三个字段，所以我们完全可以用 <code>byte</code> 内的元素搞定这些数值的枚举情况。</p>
<p>而从另外一个角度出发，这种类型的所有字段数值都将可以被转换为 <code>byte</code> 类型的数据。所以，C# 语法层面提供了隐式转换和显式转换两种模式。</p>
<p>当你想要把一个数值转换为枚举类型的时候，这个时候由于转换结果不定（比如我尝试把 3 转换为 <code>ExecutingStatus</code> 类型时，由于枚举里不存在该数值，所以这种转换是不安全的），所以 C# 提供的是显式转换，即需要写出转换类型符号来转换到指定类型）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutingStatus es = (ExecutingStatus)<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>显然，这样的转换是没有意义的。不过，在执行这句话的时候，是不会产生错误的；而相反，反而在使用的时候，它才会报错。</p>
<p>而且，枚举类型转数值的时候，依然用的是显式转换。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)ExecutingStatus.Running;</span><br></pre></td></tr></table></figure>
<p>所以，如果遇到想把上述枚举类型转为一个字符类型 <code>char</code> 的时候，你就必须写成这样：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="keyword">byte</span>)ExecutingStatus.Running;</span><br></pre></td></tr></table></figure>
<p>因为枚举类型是不允许直接转换为其它类型的，所以你需要先转换为 <code>byte</code> 后，然后再用 <code>byte</code> 转为 <code>char</code> 的强制转换来实现。当然，这种用法很少见。</p>
<p>另外，如果你想要把枚举类型的文本标识符获取到的话，可以使用 <code>ToString</code> 方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> s = ExecutingStatus.Running.ToString();</span><br></pre></td></tr></table></figure>
<p>但如果你需要把字符串等价的枚举类型字段转换过去的话，就得使用 <code>Enum.Parse</code> 或 <code>Enum.TryParse</code> 方法了。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Way of usage 1:</span></span><br><span class="line">ExecutingStatus es1</span><br><span class="line">    = (ExecutingStatus)Enum.Parse(<span class="keyword">typeof</span>(ExecutingStatus), <span class="string">"Start"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 2:</span></span><br><span class="line">ExecutingStatus es2 = Enum.Parse&lt;ExecutingStatus&gt;(<span class="string">"Start"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 3:</span></span><br><span class="line"><span class="keyword">if</span> (Enum.TryParse(<span class="keyword">typeof</span>(ExecutingStatus), <span class="string">"Start"</span>, <span class="keyword">out</span> <span class="keyword">object</span> o))</span><br><span class="line">&#123;</span><br><span class="line">    ExecutingStatus es3 = (ExecutingStatus)o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 4:</span></span><br><span class="line"><span class="comment">// Same as type 3, but using pattern matching to get es3 value.</span></span><br><span class="line"><span class="keyword">if</span> (Enum.TryParse(<span class="keyword">typeof</span>(ExecutingStatus), <span class="string">"Start"</span>, <span class="keyword">out</span> <span class="keyword">object</span> o)</span><br><span class="line">    &amp;&amp; o <span class="keyword">is</span> ExecutingStatus es4)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es4` is assigned successfully.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Way of usage 5:</span></span><br><span class="line"><span class="keyword">if</span> (Enum.TryParse&lt;ExecutingStatus&gt;(<span class="string">"Start"</span>, <span class="keyword">out</span> ExecutingStatus es5))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es5` is assigned successfully.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这五种书写格式都可以读取字符串，但前面两种当字符串书写不正确的时候，会抛出转换失败的异常，后面三种则不会。但第三种、第四种模式都会通过拆箱，因为是把 <code>object</code> 引用类型拆箱为 <code>ExecutingStatus</code> 值类型。第五种则使用的是泛型转换，这样的话 <code>es5</code> 的类型一定是和泛型参数类型一样的类型。</p>
<blockquote>
<p>所以你可以从这里看到，由于类型是一样的，所以泛型参数和 <code>out</code> 参数的类型里的任意一个都可以不写，即要么</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Enum.TryParse(<span class="string">"Start"</span>, <span class="keyword">out</span> ExecutingStatus es5))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es5` is assigned successfully.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要么</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Enum.TryParse&lt;ExecutingStatus&gt;(<span class="string">"Start"</span>, <span class="keyword">out</span> <span class="keyword">var</span> es5))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Variable `es5` is assigned successfully.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种写法均可。</p>
</blockquote>
<p>以上就介绍了枚举类型转数字和字符串，以及数字和字符串转枚举类型的方法。</p>
<h3 id="枚举类型的运算符重载"><a href="#枚举类型的运算符重载" class="headerlink" title="枚举类型的运算符重载"></a>枚举类型的运算符重载</h3><p>这才是最骚的，C# 由于和 Java 机制不同的关系，C# 具有操作符重载的说法。在语法层面上，C# 提供了枚举类型和整数的加减法重载。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es1 = ExecutingStatus.Running + <span class="number">1</span>; <span class="comment">// ExecutingStatus.End</span></span><br><span class="line"><span class="keyword">var</span> es2 = ExecutingStatus.Running - <span class="number">1</span>; <span class="comment">// ExecutingStatus.Start</span></span><br></pre></td></tr></table></figure>
<p>这样可以设置类似于“偏移量”的概念。</p>
<p>不过，还可以为其设置枚举类型之间的位运算，这一点我们在后面这一节作详细讲解。</p>
<h2 id="位域枚举类型"><a href="#位域枚举类型" class="headerlink" title="位域枚举类型"></a>位域枚举类型</h2><h3 id="位域枚举类型的定义"><a href="#位域枚举类型的定义" class="headerlink" title="位域枚举类型的定义"></a>位域枚举类型的定义</h3><p>位域枚举类型指的是，当某种类型的所有字段可以被复用的时候，我们可以使用二进制位表示每一种情况，这样可以允许一些“多角色”的情况出现。比如，Linux 操作文件的时候，文件具有可读可写可执行三大操作，这三种操作互不冲突，且文件可以具有多个属性，即某个文件完全可以实现可读和可写，或可读可写可执行都允许的情况。这种枚举类型是一种特殊的枚举类型，它就被称为<strong>位域枚举类型</strong>（Flag Enumeration Type）。</p>
<h3 id="位域枚举类型的使用"><a href="#位域枚举类型的使用" class="headerlink" title="位域枚举类型的使用"></a>位域枚举类型的使用</h3><p>这种现象，我们只需要做两步工作就可以把一个枚举类型该为位域枚举类型：为其添加 <code>FlagsAttribute</code> 特性，并为每一个枚举数值赋值二进制位对应每一种情况的数值结果：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FileTypes</span><br><span class="line">&#123;</span><br><span class="line">    Readable = <span class="number">1</span>,</span><br><span class="line">    Writable = <span class="number">2</span>,</span><br><span class="line">    Executable = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便完成了枚举类型转为位域枚举类型。</p>
<blockquote>
<p><code>FlagsAttribute</code> 特性可写可不写，下面的内容完全都可以用。但加上它可以让编译器辅助我们查找出一些隐藏的错误。</p>
</blockquote>
<p>这种类型有什么好处呢？由于每一个数值都是二进制位表示的，所以我们完全可以使用位运算符来操作它们，获取一个对象的固有枚举类型集。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft = FileTypes.Readable | FileTypes.Writable;</span><br></pre></td></tr></table></figure>
<p>这样就可以表示一个可读或者可写的行为，到时候就可以获取具体的枚举情况，查看它是否具有指定枚举情况。比如，我们需要判断文件是否有可读属性，如果可以读取，就执行读取操作；如果可写，则执行写入操作，等等。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = someFile;</span><br><span class="line"><span class="keyword">if</span> (file.FileTypes.HasFlag(FileTypes.Executable))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execute file.</span></span><br><span class="line">    file.Execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The file cannot be executed.</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"The file cannot be executed."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以调用系统自带的 <code>HasFlag</code> 方法来表示当前对象是否具有当前枚举值的行为。</p>
<p>诸如上述的操作。</p>
<p>当然，你可以写另外的一种枚举数值模式，二进制字面量。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> FileTypes</span><br><span class="line">&#123;</span><br><span class="line">    None       = <span class="number">0b000</span>,</span><br><span class="line">    Readable   = <span class="number">0b001</span>,</span><br><span class="line">    Writable   = <span class="number">0b010</span>,</span><br><span class="line">    Executable = <span class="number">0b100</span>,</span><br><span class="line">    All        = <span class="number">0b111</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，更易于看懂和理解每一个数值的对应情况，甚至你可以提供特殊的枚举数值，比如文件什么操作都不给，或者什么操作都有。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file.FileTypes == FileTypes.All)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Here all operation can be done.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用位运算来简化操作"><a href="#使用位运算来简化操作" class="headerlink" title="使用位运算来简化操作"></a>使用位运算来简化操作</h3><p>在前文里，我们使用了 <code>|</code> 位或运算符号来合并两种枚举情况，表示或的关系，二进制层面的话，数值则表示为 <code>0b110</code>，即可读可写的两个属性二进制位被置为 1。实际上，所有位运算符都适用于位域枚举类型。</p>
<h4 id="位与运算符-amp"><a href="#位与运算符-amp" class="headerlink" title="位与运算符 &amp;"></a>位与运算符 <code>&amp;</code></h4><p>可以使用位与运算符 <code>&amp;</code> 来表示两者都需要同时满足。它一般用于判断某个位域数值是否被包含在里面。比如，我们可以通过 <code>HasFlag</code> 方法查看当前位域数值是否包含 <code>FileTypes.Executable</code>，也可以通过该符号实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ft &amp; FileTypes.Executable) == FileTypes.Executable)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The file can be executed.</span></span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它完全等价于</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ft.HasFlag(FileTypes.Executable))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The file can be executed.</span></span><br><span class="line">    <span class="comment">// Do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位或运算符"><a href="#位或运算符" class="headerlink" title="位或运算符 |"></a>位或运算符 <code>|</code></h4><p>在前文已经说过，它用于表示两个枚举类型的或的关系，即同时给两个二进制位赋上值，甚至也可以为一个已经给定一部分二进制位的情况的枚举对象赋值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft1 = FileTypes.Readable | FileTypes.Writable;</span><br><span class="line"><span class="keyword">var</span> ft2 = ft1 | FileTypes.Executable;</span><br></pre></td></tr></table></figure>
<p>当前，请注意的是，二进制实现层面来说，哪怕你已经包含了某个属性，调用 <code>|</code> 运算符也不会清除掉它们。</p>
<h4 id="位异或运算符"><a href="#位异或运算符" class="headerlink" title="位异或运算符 ^"></a>位异或运算符 <code>^</code></h4><p>位异或运算符 <code>^</code> 用于反转一个二进制位。如果这个二进制位想从 1 变为 0，或者 0 变为 1，可以通过这个方式实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft = FileTypes.All ^ FileType.Executable;</span><br></pre></td></tr></table></figure>
<p>这样的话，就可以表示去掉可执行的二进制位的位域值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ft = FileTypes.None ^ FileType.Executable;</span><br></pre></td></tr></table></figure>
<p>这样就可以表示一个文件仅仅可被执行。</p>
<h4 id="位取反运算符"><a href="#位取反运算符" class="headerlink" title="位取反运算符 ~"></a>位取反运算符 <code>~</code></h4><p>位取反运算符 <code>~</code> 可以表示把一个二进制位反转，但这种用法并不常见，因为它甚至会把所有其它的二进制位都反转过来，所以显得非常没有意义。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E8%AF%AD%E6%B3%95/">C♯.语法</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E8%AF%AD%E6%B3%95/C%E2%99%AF-%E8%AF%AD%E6%B3%95-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/">C♯.语法.查漏补缺</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/17/clang-04-switch-statement/" title="C 语言语法系列（4）：switch 语句" itemprop="url">C 语言语法系列（4）：switch 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-17T07:38:08.000Z" itemprop="datePublished"> 发表于 2019-11-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="if-的弊端"><a href="#if-的弊端" class="headerlink" title="if 的弊端"></a><code>if</code> 的弊端</h2><p>很多时候，<code>if</code> 给我们的使用带来了方便的地方，但是依旧有点丑的是，我们经常会用到同一个变量分情况讨论的时候，但 <code>if</code> 非要写成 <code>if</code> 串联的模式，这样就很丑。于是，我们引入了新的语法格式：<code>switch</code> 语句。</p>
<h2 id="switch-语句的写法"><a href="#switch-语句的写法" class="headerlink" title="switch 语句的写法"></a><code>switch</code> 语句的写法</h2><p>考虑如下 <code>if</code> 串联写法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">    c = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">    c = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">5</span>)</span><br><span class="line">    c = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    c = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
<p>当我们需要判断相同的一个变量的不同数值时，我们可以考虑使用 <code>switch</code> 语句来书写，它在转换后是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        c = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        c = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        c = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// This one can not be written.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码里看到，它可能比原本的写法更臃肿了，但代码更清晰了。按照 <code>a</code> 分情况讨论。当 <code>a</code> 值为 2 的时候，执行 <code>c = 1</code> 的赋值操作；其它的同理。<code>default</code> 用来控制其它所有情况，类似于 <code>if</code> 里的 <code>else</code> 条件后没有其它判别情况时的执行操作。</p>
<p>还需要注意的是，每一个 <code>case</code> 语句的最后都有一个冒号，而且在每一个部分结束的时候，都有一个 <code>break</code> 语句作为结束（写法必须是 <code>break;</code>，即末尾带分号）。这是两个需要注意的地方。</p>
<p>另外，标签之间必须书写 <code>break</code> 是有道理的。如果不写它的话，语句就会贯穿到下一个部分去执行，所以不是非常好。但有些时候，我们也可以考虑使用这种特性来做事情。比如，我们获取 12 个月每一个月多少天的时候，可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (month)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"31\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"28\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"30\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Month value is not valid.\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// This one can not be written.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们暂且不考虑闰年还是平年，2 月分情况讨论的结果。这样的写法可以看到，像是 1、3、5、7、8、10、12 月，结果都是一样的，所以我们完全不必在中间给它加上 <code>break</code>。</p>
<p>当然，<code>default</code> 不一定要放在最后面。有些时候我们可能期望默认执行的情况和其中某个数值的执行情况是一样的，这个时候我们可以把 <code>default</code> 调整到前面去。</p>
<p>比如，我们需要在记录成绩等级（A 到 F）的时候，默认把其它情况和不及格显示成一样的结果（F），我们就可以这么做：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">67</span>;</span><br><span class="line"><span class="keyword">switch</span> (score / <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"F\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"E\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"D\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"C\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"B\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>: <span class="comment">// Only for 100.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>switch</code> 的小括号里的东西可以是任意一个整数数值的表达式，比如这个例子里的值就是 <code>score / 10</code>，算出来等于 6。</p>
<blockquote>
<p>注意，之前说过，67 和 10 都是整数，所以计算的除法一定得到的结果是整数，故得到的 6.7 会被截断为 6，而且截断不是四舍五入。</p>
</blockquote>
<h2 id="贯穿标签的用法"><a href="#贯穿标签的用法" class="headerlink" title="贯穿标签的用法"></a>贯穿标签的用法</h2><p>在前文里，所有 <code>case</code> 语句 <code>default</code> 都被称为标签。当有些时候，我们迫不得已需要贯穿标签，所以出现了前文的合并同类项的类似格式。但有些时候，我们除了这种贯穿模式之外，还有一种情况可以这么用，即不写 <code>break</code> 语句。</p>
<p>给定 <code>month</code> 数值表示当前月份，求从 1 月份到这个月一共多少天（暂不考虑日期是多少）。那么代码可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (month)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        result += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        result += <span class="number">28</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        result += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// Note this break sentence.</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        result = <span class="number">0</span>; <span class="comment">// We use 0 to let user know his input value is invalid.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以思考一下，为什么这种模式可以不写 <code>break</code> 语句。</p>
<h2 id="缺乏不等模式判断"><a href="#缺乏不等模式判断" class="headerlink" title="缺乏不等模式判断"></a>缺乏不等模式判断</h2><p><code>switch</code> 有一个缺点在于，它没有不等模式的判别，比如我们希望某个数字在 0 到 60 的时候是差， 61 到 80 的时候是中等，81 到 90 的时候是良好，91 到 100 是优秀。这个时候，我们只能使用 <code>if</code> 语句的串联，<code>switch</code> 很抱歉的是，在这一点并没有提供对应的语法判别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (score &lt;= <span class="number">60</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bad\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;= <span class="number">80</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Not bad\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;= <span class="number">90</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Awesome!\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Excellent!!\n"</span>);</span><br></pre></td></tr></table></figure>
<p>上述即可判断。你需要思考一点，为什么 <code>if</code> 判别里写的是 <code>score &lt;= 某数值</code> 呢？比如 61 到 80，不应该写成 <code>score &gt;= 61 &amp;&amp; score &lt;= 80</code> 才对吗？</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/16/hexo-mathjax-recovery/" title="Hexo 里关于 Mathjax 数学公式渲染问题的解决方案" itemprop="url">Hexo 里关于 Mathjax 数学公式渲染问题的解决方案</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-16T13:58:38.000Z" itemprop="datePublished"> 发表于 2019-11-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="为什么会出错？"><a href="#为什么会出错？" class="headerlink" title="为什么会出错？"></a>为什么会出错？</h2><p>因为内部使用的是 <code>marked</code> 的渲染模式，但它给出的渲染方式有点问题，导致最终渲染出现毛病。比如一个矩阵的渲染：</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
        1 & 2 & 3\\
        4 & 5 & 6
    \end{matrix}
\right)</script><p>就很有可能被渲染成</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
        1 & 2 & 3 \ 4 & 5 & 6
    \end{matrix}
\right)</script><p>如果你发现两个渲染结果完全一样，那么你的渲染就有问题；但是如果第一个是正常显示，但第二个不正常的话，那么就需要你仔细对比一下两个渲染的原 LaTeX 代码了。仔细对比就可以发现，第一个渲染正确的代码里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\left(</span><br><span class="line">    \begin&#123;matrix&#125;</span><br><span class="line">        1 &amp; 2 &amp; 3\\</span><br><span class="line">        4 &amp; 5 &amp; 6</span><br><span class="line">    \end&#123;matrix&#125;</span><br><span class="line">\right)</span><br></pre></td></tr></table></figure>
<p>的结尾处用的是双反斜杠 <code>\\</code>，表示换行；而下面错误渲染的公式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\left(</span><br><span class="line">    \begin&#123;matrix&#125;</span><br><span class="line">        1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6</span><br><span class="line">    \end&#123;matrix&#125;</span><br><span class="line">\right)</span><br></pre></td></tr></table></figure>
<p>却是一个反斜杠 <code>\</code>。这便是问题所在。在渲染的期间，不小心在使用正则表达式的时候替换错误了。现在我们来修复它。</p>
<h2 id="尝试修复"><a href="#尝试修复" class="headerlink" title="尝试修复"></a>尝试修复</h2><p>首先，我们需要在博客的文件夹下输入指定的卸载和安装命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br><span class="line">$ npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>进行卸载 <code>marked</code> 渲染和安装 <code>kramed</code> 的渲染。</p>
<blockquote>
<p>可能是我孤陋寡闻，不过我是偶然发现的，<code>mark</code> 和 <code>kram</code> 是一对镜面单词，即 <code>mark</code> 每个字母倒着读就是 <code>kram</code>……我估计设计者也是考虑到这样故意才取这个名的。</p>
</blockquote>
<p>然后，打开 <code>node_modules\kramed\lib\rules\inline.js</code> 文件，找到 <code>escape</code> 元素的正则表达式，替换为如下内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure>
<p>然后顺带把 <code>em</code> 一项也改掉：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure>
<p>然后保存，清除掉原本的数据库信息，然后重新部署和上传就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>当然也可以写简称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo cl</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>hexo s</code> 或 <code>hexo server</code> 全称来临时部署到本机上来查看效果。注意，记得在每一篇文章上添加 <code>mathjax: true</code> 元素表示启用 <code>mathjax</code> 渲染功能。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>不过，貌似复杂的公式依然无法渲染，因为需要导入 <code>package</code> 的功能，似乎一直都不行……所以这一点就算了吧，不过这样其实已经很好了，不是吗？</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Hexo/">Hexo</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/数学/">数学</a><a href="/tags/Hexo/">Hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/15/linear-algebra-operations/" title="矩阵操作" itemprop="url">矩阵操作</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-15T06:30:13.000Z" itemprop="datePublished"> 发表于 2019-11-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>回顾一下矩阵都有哪些基本操作吧！</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="矩阵的加法"><a href="#矩阵的加法" class="headerlink" title="矩阵的加法"></a>矩阵的加法</h3><p>加法就是把两个矩阵直接对应位置求和即可。</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
    1 & 2 & 3\\
    4 & 5 & 6
    \end{matrix}
\right) + \left(
    \begin{matrix}
    2 & 3 & -1\\
    0 & -1 & 5
    \end{matrix}
\right) = \left(
    \begin{matrix}
    3 & 5 & 2\\
    4 & 4 & 11
    \end{matrix}
\right)</script><h3 id="矩阵的减法"><a href="#矩阵的减法" class="headerlink" title="矩阵的减法"></a>矩阵的减法</h3><p>减法类似于加法，只是对应位置用减法罢了。</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
    1 & 2 & 3\\
    4 & 5 & 6
    \end{matrix}
\right) - \left(
    \begin{matrix}
    2 & 3 & -1\\
    0 & -1 & 5
    \end{matrix}
\right) = \left(
    \begin{matrix}
    -1 & -1 & 4\\
    4 & 6 & 1
    \end{matrix}
\right)</script><h3 id="矩阵的点乘法（内乘法）"><a href="#矩阵的点乘法（内乘法）" class="headerlink" title="矩阵的点乘法（内乘法）"></a>矩阵的点乘法（内乘法）</h3><p>矩阵乘法必须要求两个矩阵 $A_{m \times n}$ 和 $B_{n \times p}$ 的矩阵规格，第一个矩阵的列数必须等于第二个矩阵的行数。这是因为求值的过程是按整行和整列的内乘积（对应位相乘，再相加）。</p>
<script type="math/tex; mode=display">
\begin{align}
    \left(
        \begin{matrix}
        1 & 2 & 3\\
        4 & 5 & 6
        \end{matrix}
    \right) \cdot \left(
        \begin{matrix}
        1 & 2\\
        3 & 4\\
        5 & 6
        \end{matrix}
    \right) &= \left(
        \begin{matrix}
        1 \times 1 + 2 \times 3 + 3 \times 5 & 1 \times 2 + 2 \times 4 + 3 \times 6\\
        4 \times 1 + 5 \times 3 + 3 \times 6 & 4 \times 2 + 5 \times 4 + 6 \times 6
        \end{matrix}
    \right)\\
    &= \left(
        \begin{matrix}
        22 & 28\\
        37 & 64
        \end{matrix}
    \right)
\end{align}</script><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p>获取方阵的行列式，是采用降阶实现的。</p>
<script type="math/tex; mode=display">
\begin{align}
    \left|
        \begin{matrix}
        1 & 3\\
        2 & 4
        \end{matrix}
    \right|
    &= 1 \times 4 - 2 \times 3\\
    &= -2
\end{align}</script><p>三阶：</p>
<script type="math/tex; mode=display">
\begin{align}
    \left|
        \begin{matrix}
        1 & 2 & 3\\
        4 & 5 & 6\\
        7 & 8 & 9
        \end{matrix}
    \right| &= 1 \times (-1) ^ {1 + 1} \cdot \left|
        \begin{matrix}
        5 & 6\\
        8 & 9
        \end{matrix}
    \right| + 2 \times (-1) ^ {1 + 2} \cdot \left|
        \begin{matrix}
        4 & 6\\
        7 & 9
        \end{matrix}
    \right| + 3 \times (-1) ^ {1 + 3} \cdot \left|
        \begin{matrix}
        4 & 5\\
        7 & 8
        \end{matrix}
    \right|\\
    &= 1 \times 1 \times (-3) + 2 \times (-1) \times (-6) +3 \times 1 \times (-3)\\
    &= -3 + 12 - 9\\
    &=0
\end{align}</script><h3 id="矩阵的转置矩阵"><a href="#矩阵的转置矩阵" class="headerlink" title="矩阵的转置矩阵"></a>矩阵的转置矩阵</h3><p>将矩阵转置就是行列交换。</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
    1 & 2 & 3\\
    4 & 5 & 6
    \end{matrix}
\right) ^ T = \left(
    \begin{matrix}
    1 & 4\\
    2 & 5\\
    3 & 6
    \end{matrix}
\right)</script><h3 id="方阵的伴随矩阵"><a href="#方阵的伴随矩阵" class="headerlink" title="方阵的伴随矩阵"></a>方阵的伴随矩阵</h3><p>获取矩阵的伴随矩阵很简单，求得每一个位置上的代数余子式，并挨个写到矩阵里，再转置即可。</p>
<p>例如矩阵</p>
<script type="math/tex; mode=display">
A = \left(
    \begin{matrix}
    0 & 3 & -1\\
    1 & -1 & 1\\
    3 & -1 & 2
    \end{matrix}
\right)</script><p>它的每一个代数余子式如下所示：</p>
<script type="math/tex; mode=display">
\begin{matrix}
    A_{11} = (-1) ^ {1 + 1} \left|
        \begin{matrix}
        -1 & 1\\
        -1 & 2
        \end{matrix}
    \right| = -1, & A_{12} = (-1) ^ {1 + 2} \left|
        \begin{matrix}
        1 & 1\\
        3 & 2
        \end{matrix}
    \right| = 1, & A_{13} = (-1) ^ {1 + 3} \left|
        \begin{matrix}
        1 & -1\\
        3 & -1
        \end{matrix}
    \right| = 2,\\
    A_{21} = (-1) ^ {2 + 1} \left|
        \begin{matrix}
        3 & 1\\
        -1 & 2
        \end{matrix}
    \right| = -7, & A_{22} = (-1) ^ {2 + 2} \left|
        \begin{matrix}
        0 & 1\\
        3 & 2
        \end{matrix}
    \right| = -3, & A_{23} = (-1) ^ {2 + 3} \left|
        \begin{matrix}
        0 & 3\\
        3 & -1
        \end{matrix}
    \right| = 9,\\
    A_{31} = (-1) ^ {3 + 1} \left|
        \begin{matrix}
        3 & 1\\
        -1 & 1
        \end{matrix}
    \right| = 4, & A_{32} = (-1) ^ {3 + 2} \left|
        \begin{matrix}
        0 & 1\\
        1 & 1
        \end{matrix}
    \right| = 1, & A_{33} = (-1) ^ {3 + 3} \left|
        \begin{matrix}
        0 & 3\\
        1 & -1
        \end{matrix}
    \right| = -3.\\
\end{matrix}</script><p>所以</p>
<script type="math/tex; mode=display">
\text{adj} \ A = \left(
    \begin{matrix}
    -1 & -7 & 4\\
    1 & -3 & 1\\
    2 & 9 & -3
    \end{matrix}
\right)</script><h3 id="方阵的逆矩阵"><a href="#方阵的逆矩阵" class="headerlink" title="方阵的逆矩阵"></a>方阵的逆矩阵</h3><p>矩阵的除法的主要思路就是求逆矩阵。逆矩阵可以通过矩阵拼接一个同型单位矩阵 $E$ 并执行初等变换后得到。当然，能得到矩阵具有逆矩阵的前提是，这个矩阵的行列式不等于 0，记作 $\det A \neq 0$（中国的高等数学和线性代数的教材里多使用 $|A|$ 来表示 $A$ 的行列式，而不是用 $\det A$）。</p>
<p>矩阵如果能有它的逆矩阵，那么可以通过如下公式得到：</p>
<script type="math/tex; mode=display">
\begin{align}
    \text{inv} \ A &= \frac{\text{adj} \ A}{\det A}\\
    &= \frac1{\det A} \ \text{adj} \ A
\end{align}</script><p>或写作</p>
<script type="math/tex; mode=display">
\begin{align}
    A^{-1} &= \frac{A^*}{|A|}\\
    &= \frac1{|A|} \ A^*
\end{align}</script><p>例如上面的题目</p>
<script type="math/tex; mode=display">
A = \left(
    \begin{matrix}
    0 & 3 & -1\\
    1 & -1 & 1\\
    3 & -1 & 2
    \end{matrix}
\right)</script><p>它的行列式经过计算可得 $\det A = 5 \neq 0$，可逆，然后得到它的伴随矩阵为</p>
<script type="math/tex; mode=display">
\text{adj} \ A = \left(
    \begin{matrix}
    -1 & -7 & 4\\
    1 & -3 & 1\\
    2 & 9 & -3
    \end{matrix}
\right)</script><p>所以，根据公式可以得到</p>
<script type="math/tex; mode=display">
\begin{align}
    \text{inv} \ A &= \frac15 \left(
        \begin{matrix}
        -1 & -7 & 4\\
        1 & -3 & 1\\
        2 & 9 & -3
        \end{matrix}
    \right)\\
    &= \left(
        \begin{matrix}
        -\frac15 & -\frac75 & \frac45\\
        \frac15 & -\frac35 & \frac15\\
        \frac25 & \frac95 & -\frac35
        \end{matrix}
    \right)
\end{align}</script><h3 id="方阵的除法"><a href="#方阵的除法" class="headerlink" title="方阵的除法"></a>方阵的除法</h3><p>如果我们可以得到结果，那么我们可以定义出方阵的除法运算：</p>
<script type="math/tex; mode=display">
A \div B = A \ \text{inv} \ B = C => \text{inv} \ B = C \ \text{inv} \ A</script><p>当然，这种用法显然是不太方便的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/数学/">数学</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/15/clang-03-if-statement/" title="C 语言语法系列（3）：if 语句" itemprop="url">C 语言语法系列（3）：if 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-15T06:07:49.000Z" itemprop="datePublished"> 发表于 2019-11-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="if-关键字的用法"><a href="#if-关键字的用法" class="headerlink" title="if 关键字的用法"></a><code>if</code> 关键字的用法</h2><p>接下来，我将为你讲解的是一种新的执行语法模式：条件判断。</p>
<p>在前文的介绍里，我们可以使用运算符和类型声明的表达式，来获取一些数据的数值，并输出。但整个程序的写法格式是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样仅仅能够写出一些简单的执行语句。今天我们来学习一种跳转模式的语句：<code>if</code> 条件判断。<code>if</code> 条件判断的用法是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execution when condition is true.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execution when condition is false.</span></span><br><span class="line">    <span class="comment">// This block can be omitted when you don't need.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以根据注释内容看到，只要条件满足要求的，将会走第一个大括号的内容；如果不满足要求，将会走第二个大括号的内容。例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以从这里看到，显然 <code>a + b</code> 结果是大于 4 的，所以满足条件，故 <code>c</code> 的结果应为 <code>a + b</code>，输出的结果就是 5。当然，这里就需要你学习一些语法约定和书写格式规范。当 <code>if</code> 和 <code>else</code> 块里只有一句话的时候，大括号是可以省略的，但最好使用缩进格式书写，分清楚层次，这样可以轻松辨别代码的逻辑和控制的部分，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; <span class="number">4</span>)</span><br><span class="line">        c = a + b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        c = a * b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三目运算符：条件运算"><a href="#三目运算符：条件运算" class="headerlink" title="三目运算符：条件运算"></a>三目运算符：条件运算</h2><p>我们可以使用三目运算符 <code>?:</code> 来判别一个结果。类似上文的逻辑，在 <code>?</code> 前面写条件，在 <code>?</code> 和 <code>:</code> 之间写条件成立的时候的结果，而 <code>:</code> 后写条件为假的时候的结果。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = a + b &gt; <span class="number">4</span> ? a + b : a * b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就把之前的 <code>if-else</code> 判断模式简写为这样。它们是等价的。</p>
<h2 id="嵌套-if"><a href="#嵌套-if" class="headerlink" title="嵌套 if"></a>嵌套 <code>if</code></h2><p>之所以之前叫大家将 <code>if</code> 内部的执行内容进行缩进，是因为 <code>if</code> 的执行逻辑是可以嵌套的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a - b == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于上述逻辑，我们可以先看条件判断。由于 <code>a + b</code> 的结果是 5 而不是 3，所以它只能走 <code>else</code> 这一部分的执行内容。于是得到 <code>c</code> 为 0，所以输出结果为 0。</p>
<h2 id="串联-if"><a href="#串联-if" class="headerlink" title="串联 if"></a>串联 <code>if</code></h2><p>有时候，当分支不止一个的时候，我们可以使用把 <code>if</code> 的声明串联的模式来执行一些操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，这种写法太丑了。首先，我们认为一个分号就是一句话，现在引入了块的说法，所以一个大括号就是一句话。那么 <code>a == 2</code> 条件的 <code>else</code> 部分就只有一句话，我们可以省略这一个大括号；而且 <code>c == 3</code> 条件里的 <code>else</code> 分支的大括号也可以被省略，所以就变为这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不过，还是很丑陋。不过我们发现，既然 <code>else</code> 和 <code>if</code> 语句还有 <code>else</code> 完全可以连起来，那么何不把它们直接串联起来呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不就很好看了吗。这个写法就是 <code>if</code> 串联的写法。</p>
<h2 id="嵌套-if-时的三目运算"><a href="#嵌套-if-时的三目运算" class="headerlink" title="嵌套 if 时的三目运算"></a>嵌套 <code>if</code> 时的三目运算</h2><p>前文用到的这个示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a - b == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以被简写为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b == <span class="number">3</span> ? (a - b == <span class="number">3</span> ? a * b : a / b) : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，三目运算符的查找逻辑是从右到左的。所以它会有先发现到 <code>(a - b == 3 ? a * b : a / b)</code> 表达式是完整的整体，所以这个括号是可以不要的，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = a + b == <span class="number">3</span> ? a - b == <span class="number">3</span> ? a * b : a / b : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="数值条件"><a href="#数值条件" class="headerlink" title="数值条件"></a>数值条件</h2><p>最后要说明一下的是，任意一个整数数值都可以作为条件使用，写在 <code>if</code> 语句的小括号里。在前文里，我们说到，一个整数数值，只要它不是 0，我们就认为这个数值表示的条件是“正确的”的意思，而是 0 则表示这个条件是“不成立的”、“错误的”的意思。所以，如果我们想要把一个数值作为真假两种情况的判断的话，我们可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (isPrime)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"17 is a prime.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"17 is not a prime.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，你就能得到 <code>17 is a prime</code> 的输出信息。当然，你甚至也可以为 <code>isPrime</code> 变量的条件处添加前缀取反符号 <code>!</code> 来表示逻辑取反。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!isPrime) <span class="comment">// Note here.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"34 is not a prime.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"34 is a prime.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，从这个角度来看，<code>isPrime</code> 单独作为条件，可以等价用判断语句表示为 <code>isPrime != 0</code>，而 <code>!isPrime</code> 则可以等价表示为 <code>isPrime == 0</code>。所以推广到任意情况下：</p>
<ul>
<li><code>digit == 0</code> 简写作 <code>!digit</code>；</li>
<li><code>digit != 0</code> 简写作 <code>digit</code>。</li>
</ul>
<p>当然，这两种说法仅用于 <code>if</code> 的条件断言（小括号）处。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>




  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/5/">上一页 ↑</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/7/">下一页 ↓</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="Sunnie-Shine" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>



  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/C♯/" title="C♯">C♯<sup>33</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/LINQ/" title="LINQ">LINQ<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/位运算/" title="位运算">位运算<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/数独/" title="数独">数独<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-编译器生成/" title="C♯.编译器生成">C♯.编译器生成<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/数学/" title="数学">数学<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-7/" title="C♯ 7">C♯ 7<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-8/" title="C♯ 8">C♯ 8<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/SQL/" title="SQL">SQL<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/正则表达式/" title="正则表达式">正则表达式<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/向向的每周数独/" title="向向的每周数独">向向的每周数独<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/安卓/" title="安卓">安卓<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ASP/" title="ASP">ASP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/诗词/" title="诗词">诗词<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-3/" title="C♯ 3">C♯ 3<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-6/" title="C♯ 6">C♯ 6<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-2/" title="C♯ 2">C♯ 2<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://sunniesudoku.cn/" target="_blank" title="向向的数独文档库">向向的数独文档库</a>
            
          </li>
        
          <li>
            
            	<a href="http://tieba.baidu.com/f?kw=%CA%FD%B6%C0" target="_blank" title="数独贴吧">数独贴吧</a>
            
          </li>
        
          <li>
            
            	<a href="https://space.bilibili.com/23736703" target="_blank" title="Bilibili">Bilibili</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m Sunnie. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/Sunnie-Shine" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/Sunnie-Shine" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
	</div>
			
		

		<p class="copyright">
		Copyright © 2020 
		
		<a href="/about" target="_blank" title="向向">向向</a>
		
		<br />
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a>
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript"
  async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
