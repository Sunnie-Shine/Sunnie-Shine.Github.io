
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>向向的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="向向">
    

    
    <meta name="description" content="This is my blog...">
<meta property="og:type" content="website">
<meta property="og:title" content="向向的博客">
<meta property="og:url" content="https:&#x2F;&#x2F;sunnie-shine.github.io&#x2F;page&#x2F;6&#x2F;index.html">
<meta property="og:site_name" content="向向的博客">
<meta property="og:description" content="This is my blog...">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="向向的博客" title="向向的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="向向的博客">向向的博客</a></h1>
				<h2 class="blog-motto">Console.WriteLine(&#34;Hello, ^_^&#34;);</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">全部文档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:Sunnie-Shine.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/16/hexo-mathjax-recovery/" title="Hexo 里关于 Mathjax 数学公式渲染问题的解决方案" itemprop="url">Hexo 里关于 Mathjax 数学公式渲染问题的解决方案</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-16T13:58:38.000Z" itemprop="datePublished"> 发表于 2019-11-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="为什么会出错？"><a href="#为什么会出错？" class="headerlink" title="为什么会出错？"></a>为什么会出错？</h2><p>因为内部使用的是 <code>marked</code> 的渲染模式，但它给出的渲染方式有点问题，导致最终渲染出现毛病。比如一个矩阵的渲染：</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
        1 & 2 & 3\\
        4 & 5 & 6
    \end{matrix}
\right)</script><p>就很有可能被渲染成</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
        1 & 2 & 3 \ 4 & 5 & 6
    \end{matrix}
\right)</script><p>如果你发现两个渲染结果完全一样，那么你的渲染就有问题；但是如果第一个是正常显示，但第二个不正常的话，那么就需要你仔细对比一下两个渲染的原 LaTeX 代码了。仔细对比就可以发现，第一个渲染正确的代码里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\left(</span><br><span class="line">    \begin&#123;matrix&#125;</span><br><span class="line">        1 &amp; 2 &amp; 3\\</span><br><span class="line">        4 &amp; 5 &amp; 6</span><br><span class="line">    \end&#123;matrix&#125;</span><br><span class="line">\right)</span><br></pre></td></tr></table></figure>
<p>的结尾处用的是双反斜杠 <code>\\</code>，表示换行；而下面错误渲染的公式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\left(</span><br><span class="line">    \begin&#123;matrix&#125;</span><br><span class="line">        1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6</span><br><span class="line">    \end&#123;matrix&#125;</span><br><span class="line">\right)</span><br></pre></td></tr></table></figure>
<p>却是一个反斜杠 <code>\</code>。这便是问题所在。在渲染的期间，不小心在使用正则表达式的时候替换错误了。现在我们来修复它。</p>
<h2 id="尝试修复"><a href="#尝试修复" class="headerlink" title="尝试修复"></a>尝试修复</h2><p>首先，我们需要在博客的文件夹下输入指定的卸载和安装命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-renderer-marked --save</span><br><span class="line">$ npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>进行卸载 <code>marked</code> 渲染和安装 <code>kramed</code> 的渲染。</p>
<blockquote>
<p>可能是我孤陋寡闻，不过我是偶然发现的，<code>mark</code> 和 <code>kram</code> 是一对镜面单词，即 <code>mark</code> 每个字母倒着读就是 <code>kram</code>……我估计设计者也是考虑到这样故意才取这个名的。</p>
</blockquote>
<p>然后，打开 <code>node_modules\kramed\lib\rules\inline.js</code> 文件，找到 <code>escape</code> 元素的正则表达式，替换为如下内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure>
<p>然后顺带把 <code>em</code> 一项也改掉：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure>
<p>然后保存，清除掉原本的数据库信息，然后重新部署和上传就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>当然也可以写简称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo cl</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>hexo s</code> 或 <code>hexo server</code> 全称来临时部署到本机上来查看效果。注意，记得在每一篇文章上添加 <code>mathjax: true</code> 元素表示启用 <code>mathjax</code> 渲染功能。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>不过，貌似复杂的公式依然无法渲染，因为需要导入 <code>package</code> 的功能，似乎一直都不行……所以这一点就算了吧，不过这样其实已经很好了，不是吗？</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Hexo/">Hexo</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/数学/">数学</a><a href="/tags/Hexo/">Hexo</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/15/linear-algebra-operations/" title="矩阵操作" itemprop="url">矩阵操作</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-15T06:30:13.000Z" itemprop="datePublished"> 发表于 2019-11-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>回顾一下矩阵都有哪些基本操作吧！</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="矩阵的加法"><a href="#矩阵的加法" class="headerlink" title="矩阵的加法"></a>矩阵的加法</h3><p>加法就是把两个矩阵直接对应位置求和即可。</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
    1 & 2 & 3\\
    4 & 5 & 6
    \end{matrix}
\right) + \left(
    \begin{matrix}
    2 & 3 & -1\\
    0 & -1 & 5
    \end{matrix}
\right) = \left(
    \begin{matrix}
    3 & 5 & 2\\
    4 & 4 & 11
    \end{matrix}
\right)</script><h3 id="矩阵的减法"><a href="#矩阵的减法" class="headerlink" title="矩阵的减法"></a>矩阵的减法</h3><p>减法类似于加法，只是对应位置用减法罢了。</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
    1 & 2 & 3\\
    4 & 5 & 6
    \end{matrix}
\right) - \left(
    \begin{matrix}
    2 & 3 & -1\\
    0 & -1 & 5
    \end{matrix}
\right) = \left(
    \begin{matrix}
    -1 & -1 & 4\\
    4 & 6 & 1
    \end{matrix}
\right)</script><h3 id="矩阵的点乘法（内乘法）"><a href="#矩阵的点乘法（内乘法）" class="headerlink" title="矩阵的点乘法（内乘法）"></a>矩阵的点乘法（内乘法）</h3><p>矩阵乘法必须要求两个矩阵 $A_{m \times n}$ 和 $B_{n \times p}$ 的矩阵规格，第一个矩阵的列数必须等于第二个矩阵的行数。这是因为求值的过程是按整行和整列的内乘积（对应位相乘，再相加）。</p>
<script type="math/tex; mode=display">
\begin{align}
    \left(
        \begin{matrix}
        1 & 2 & 3\\
        4 & 5 & 6
        \end{matrix}
    \right) \cdot \left(
        \begin{matrix}
        1 & 2\\
        3 & 4\\
        5 & 6
        \end{matrix}
    \right) &= \left(
        \begin{matrix}
        1 \times 1 + 2 \times 3 + 3 \times 5 & 1 \times 2 + 2 \times 4 + 3 \times 6\\
        4 \times 1 + 5 \times 3 + 3 \times 6 & 4 \times 2 + 5 \times 4 + 6 \times 6
        \end{matrix}
    \right)\\
    &= \left(
        \begin{matrix}
        22 & 28\\
        37 & 64
        \end{matrix}
    \right)
\end{align}</script><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p>获取方阵的行列式，是采用降阶实现的。</p>
<script type="math/tex; mode=display">
\begin{align}
    \left|
        \begin{matrix}
        1 & 3\\
        2 & 4
        \end{matrix}
    \right|
    &= 1 \times 4 - 2 \times 3\\
    &= -2
\end{align}</script><p>三阶：</p>
<script type="math/tex; mode=display">
\begin{align}
    \left|
        \begin{matrix}
        1 & 2 & 3\\
        4 & 5 & 6\\
        7 & 8 & 9
        \end{matrix}
    \right| &= 1 \times (-1) ^ {1 + 1} \cdot \left|
        \begin{matrix}
        5 & 6\\
        8 & 9
        \end{matrix}
    \right| + 2 \times (-1) ^ {1 + 2} \cdot \left|
        \begin{matrix}
        4 & 6\\
        7 & 9
        \end{matrix}
    \right| + 3 \times (-1) ^ {1 + 3} \cdot \left|
        \begin{matrix}
        4 & 5\\
        7 & 8
        \end{matrix}
    \right|\\
    &= 1 \times 1 \times (-3) + 2 \times (-1) \times (-6) +3 \times 1 \times (-3)\\
    &= -3 + 12 - 9\\
    &=0
\end{align}</script><h3 id="矩阵的转置矩阵"><a href="#矩阵的转置矩阵" class="headerlink" title="矩阵的转置矩阵"></a>矩阵的转置矩阵</h3><p>将矩阵转置就是行列交换。</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
    1 & 2 & 3\\
    4 & 5 & 6
    \end{matrix}
\right) ^ T = \left(
    \begin{matrix}
    1 & 4\\
    2 & 5\\
    3 & 6
    \end{matrix}
\right)</script><h3 id="方阵的伴随矩阵"><a href="#方阵的伴随矩阵" class="headerlink" title="方阵的伴随矩阵"></a>方阵的伴随矩阵</h3><p>获取矩阵的伴随矩阵很简单，求得每一个位置上的代数余子式，并挨个写到矩阵里，再转置即可。</p>
<p>例如矩阵</p>
<script type="math/tex; mode=display">
A = \left(
    \begin{matrix}
    0 & 3 & -1\\
    1 & -1 & 1\\
    3 & -1 & 2
    \end{matrix}
\right)</script><p>它的每一个代数余子式如下所示：</p>
<script type="math/tex; mode=display">
\begin{matrix}
    A_{11} = (-1) ^ {1 + 1} \left|
        \begin{matrix}
        -1 & 1\\
        -1 & 2
        \end{matrix}
    \right| = -1, & A_{12} = (-1) ^ {1 + 2} \left|
        \begin{matrix}
        1 & 1\\
        3 & 2
        \end{matrix}
    \right| = 1, & A_{13} = (-1) ^ {1 + 3} \left|
        \begin{matrix}
        1 & -1\\
        3 & -1
        \end{matrix}
    \right| = 2,\\
    A_{21} = (-1) ^ {2 + 1} \left|
        \begin{matrix}
        3 & 1\\
        -1 & 2
        \end{matrix}
    \right| = -7, & A_{22} = (-1) ^ {2 + 2} \left|
        \begin{matrix}
        0 & 1\\
        3 & 2
        \end{matrix}
    \right| = -3, & A_{23} = (-1) ^ {2 + 3} \left|
        \begin{matrix}
        0 & 3\\
        3 & -1
        \end{matrix}
    \right| = 9,\\
    A_{31} = (-1) ^ {3 + 1} \left|
        \begin{matrix}
        3 & 1\\
        -1 & 1
        \end{matrix}
    \right| = 4, & A_{32} = (-1) ^ {3 + 2} \left|
        \begin{matrix}
        0 & 1\\
        1 & 1
        \end{matrix}
    \right| = 1, & A_{33} = (-1) ^ {3 + 3} \left|
        \begin{matrix}
        0 & 3\\
        1 & -1
        \end{matrix}
    \right| = -3.\\
\end{matrix}</script><p>所以</p>
<script type="math/tex; mode=display">
\text{adj} \ A = \left(
    \begin{matrix}
    -1 & -7 & 4\\
    1 & -3 & 1\\
    2 & 9 & -3
    \end{matrix}
\right)</script><h3 id="方阵的逆矩阵"><a href="#方阵的逆矩阵" class="headerlink" title="方阵的逆矩阵"></a>方阵的逆矩阵</h3><p>矩阵的除法的主要思路就是求逆矩阵。逆矩阵可以通过矩阵拼接一个同型单位矩阵 $E$ 并执行初等变换后得到。当然，能得到矩阵具有逆矩阵的前提是，这个矩阵的行列式不等于 0，记作 $\det A \neq 0$（中国的高等数学和线性代数的教材里多使用 $|A|$ 来表示 $A$ 的行列式，而不是用 $\det A$）。</p>
<p>矩阵如果能有它的逆矩阵，那么可以通过如下公式得到：</p>
<script type="math/tex; mode=display">
\begin{align}
    \text{inv} \ A &= \frac{\text{adj} \ A}{\det A}\\
    &= \frac1{\det A} \ \text{adj} \ A
\end{align}</script><p>或写作</p>
<script type="math/tex; mode=display">
\begin{align}
    A^{-1} &= \frac{A^*}{|A|}\\
    &= \frac1{|A|} \ A^*
\end{align}</script><p>例如上面的题目</p>
<script type="math/tex; mode=display">
A = \left(
    \begin{matrix}
    0 & 3 & -1\\
    1 & -1 & 1\\
    3 & -1 & 2
    \end{matrix}
\right)</script><p>它的行列式经过计算可得 $\det A = 5 \neq 0$，可逆，然后得到它的伴随矩阵为</p>
<script type="math/tex; mode=display">
\text{adj} \ A = \left(
    \begin{matrix}
    -1 & -7 & 4\\
    1 & -3 & 1\\
    2 & 9 & -3
    \end{matrix}
\right)</script><p>所以，根据公式可以得到</p>
<script type="math/tex; mode=display">
\begin{align}
    \text{inv} \ A &= \frac15 \left(
        \begin{matrix}
        -1 & -7 & 4\\
        1 & -3 & 1\\
        2 & 9 & -3
        \end{matrix}
    \right)\\
    &= \left(
        \begin{matrix}
        -\frac15 & -\frac75 & \frac45\\
        \frac15 & -\frac35 & \frac15\\
        \frac25 & \frac95 & -\frac35
        \end{matrix}
    \right)
\end{align}</script><h3 id="方阵的除法"><a href="#方阵的除法" class="headerlink" title="方阵的除法"></a>方阵的除法</h3><p>如果我们可以得到结果，那么我们可以定义出方阵的除法运算：</p>
<script type="math/tex; mode=display">
A \div B = A \ \text{inv} \ B = C => \text{inv} \ B = C \ \text{inv} \ A</script><p>当然，这种用法显然是不太方便的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E6%95%B0%E5%AD%A6/">数学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/数学/">数学</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/15/clang-03-if-statement/" title="C 语言语法系列（3）：if 语句" itemprop="url">C 语言语法系列（3）：if 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-15T06:07:49.000Z" itemprop="datePublished"> 发表于 2019-11-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="if-关键字的用法"><a href="#if-关键字的用法" class="headerlink" title="if 关键字的用法"></a><code>if</code> 关键字的用法</h2><p>接下来，我将为你讲解的是一种新的执行语法模式：条件判断。</p>
<p>在前文的介绍里，我们可以使用运算符和类型声明的表达式，来获取一些数据的数值，并输出。但整个程序的写法格式是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a + b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样仅仅能够写出一些简单的执行语句。今天我们来学习一种跳转模式的语句：<code>if</code> 条件判断。<code>if</code> 条件判断的用法是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execution when condition is true.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Execution when condition is false.</span></span><br><span class="line">    <span class="comment">// This block can be omitted when you don't need.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以根据注释内容看到，只要条件满足要求的，将会走第一个大括号的内容；如果不满足要求，将会走第二个大括号的内容。例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以从这里看到，显然 <code>a + b</code> 结果是大于 4 的，所以满足条件，故 <code>c</code> 的结果应为 <code>a + b</code>，输出的结果就是 5。当然，这里就需要你学习一些语法约定和书写格式规范。当 <code>if</code> 和 <code>else</code> 块里只有一句话的时候，大括号是可以省略的，但最好使用缩进格式书写，分清楚层次，这样可以轻松辨别代码的逻辑和控制的部分，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; <span class="number">4</span>)</span><br><span class="line">        c = a + b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        c = a * b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三目运算符：条件运算"><a href="#三目运算符：条件运算" class="headerlink" title="三目运算符：条件运算"></a>三目运算符：条件运算</h2><p>我们可以使用三目运算符 <code>?:</code> 来判别一个结果。类似上文的逻辑，在 <code>?</code> 前面写条件，在 <code>?</code> 和 <code>:</code> 之间写条件成立的时候的结果，而 <code>:</code> 后写条件为假的时候的结果。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    c = a + b &gt; <span class="number">4</span> ? a + b : a * b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就把之前的 <code>if-else</code> 判断模式简写为这样。它们是等价的。</p>
<h2 id="嵌套-if"><a href="#嵌套-if" class="headerlink" title="嵌套 if"></a>嵌套 <code>if</code></h2><p>之所以之前叫大家将 <code>if</code> 内部的执行内容进行缩进，是因为 <code>if</code> 的执行逻辑是可以嵌套的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a - b == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似于上述逻辑，我们可以先看条件判断。由于 <code>a + b</code> 的结果是 5 而不是 3，所以它只能走 <code>else</code> 这一部分的执行内容。于是得到 <code>c</code> 为 0，所以输出结果为 0。</p>
<h2 id="串联-if"><a href="#串联-if" class="headerlink" title="串联 if"></a>串联 <code>if</code></h2><p>有时候，当分支不止一个的时候，我们可以使用把 <code>if</code> 的声明串联的模式来执行一些操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，这种写法太丑了。首先，我们认为一个分号就是一句话，现在引入了块的说法，所以一个大括号就是一句话。那么 <code>a == 2</code> 条件的 <code>else</code> 部分就只有一句话，我们可以省略这一个大括号；而且 <code>c == 3</code> 条件里的 <code>else</code> 分支的大括号也可以被省略，所以就变为这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不过，还是很丑陋。不过我们发现，既然 <code>else</code> 和 <code>if</code> 语句还有 <code>else</code> 完全可以连起来，那么何不把它们直接串联起来呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不就很好看了吗。这个写法就是 <code>if</code> 串联的写法。</p>
<h2 id="嵌套-if-时的三目运算"><a href="#嵌套-if-时的三目运算" class="headerlink" title="嵌套 if 时的三目运算"></a>嵌套 <code>if</code> 时的三目运算</h2><p>前文用到的这个示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a - b == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = a * b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    c = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以被简写为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b == <span class="number">3</span> ? (a - b == <span class="number">3</span> ? a * b : a / b) : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，三目运算符的查找逻辑是从右到左的。所以它会有先发现到 <code>(a - b == 3 ? a * b : a / b)</code> 表达式是完整的整体，所以这个括号是可以不要的，即：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = a + b == <span class="number">3</span> ? a - b == <span class="number">3</span> ? a * b : a / b : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h2 id="数值条件"><a href="#数值条件" class="headerlink" title="数值条件"></a>数值条件</h2><p>最后要说明一下的是，任意一个整数数值都可以作为条件使用，写在 <code>if</code> 语句的小括号里。在前文里，我们说到，一个整数数值，只要它不是 0，我们就认为这个数值表示的条件是“正确的”的意思，而是 0 则表示这个条件是“不成立的”、“错误的”的意思。所以，如果我们想要把一个数值作为真假两种情况的判断的话，我们可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (isPrime)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"17 is a prime.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"17 is not a prime.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，你就能得到 <code>17 is a prime</code> 的输出信息。当然，你甚至也可以为 <code>isPrime</code> 变量的条件处添加前缀取反符号 <code>!</code> 来表示逻辑取反。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> isPrime = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!isPrime) <span class="comment">// Note here.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"34 is not a prime.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"34 is a prime.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，从这个角度来看，<code>isPrime</code> 单独作为条件，可以等价用判断语句表示为 <code>isPrime != 0</code>，而 <code>!isPrime</code> 则可以等价表示为 <code>isPrime == 0</code>。所以推广到任意情况下：</p>
<ul>
<li><code>digit == 0</code> 简写作 <code>!digit</code>；</li>
<li><code>digit != 0</code> 简写作 <code>digit</code>。</li>
</ul>
<p>当然，这两种说法仅用于 <code>if</code> 的条件断言（小括号）处。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/15/linq-08-relational-algrbra-in-linq/" title="LINQ 教程（8）：LINQ 里的关系代数" itemprop="url">LINQ 教程（8）：LINQ 里的关系代数</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-15T01:26:13.000Z" itemprop="datePublished"> 发表于 2019-11-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="什么是关系代数？"><a href="#什么是关系代数？" class="headerlink" title="什么是关系代数？"></a>什么是关系代数？</h2><p>关系代数是数据库里面需要用到的一个重要的理论概念。它针对于表进行加减乘除等等的定义操作。下面我们就一一来看下，关系代数里都有些啥。</p>
<h2 id="关系代数运算"><a href="#关系代数运算" class="headerlink" title="关系代数运算"></a>关系代数运算</h2><h3 id="加法（并集）"><a href="#加法（并集）" class="headerlink" title="加法（并集）"></a>加法（并集）</h3><p>关系代数里，把两个表加起来（$A \cup B$），就好比是求得两个表的并集。注意，在 LINQ 里，两个列表要求获取并集需要两个列表是同元素类型的。比如，我们只能针对于两个 <code>IEnumerable&lt;int&gt;</code> 作运算，尝试把 <code>IEnumerable&lt;int&gt;</code> 和 <code>IEnumerable&lt;char&gt;</code> 作并集是没有意义的。</p>
<p><img src="union.png" alt=""></p>
<p>好在，在 LINQ 里面提供了 <code>Union</code> 方法，可以用来提供作出并集操作：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.Union(list2);</span><br></pre></td></tr></table></figure>
<p>那么，如果 <code>list1</code> 里有 1、2、3，而 <code>list2</code> 里有 2、 3、 5 的话，那么 <code>result</code> 里就有 1、2、3、5 了。</p>
<h3 id="减法（差集）"><a href="#减法（差集）" class="headerlink" title="减法（差集）"></a>减法（差集）</h3><p>将两个表求差（$A \backslash B$ 或 $A - B$），就好比取出被减集合里有，而减集合里没有的元素。</p>
<p><img src="difference.png" alt=""></p>
<p>在 LINQ 里，我们可以使用 <code>Except</code> 方法来获取差集。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.Except(list2);</span><br></pre></td></tr></table></figure>
<p>那么，如果 <code>list1</code> 里有 1、2、3，而 <code>list2</code> 里有 2、 3、 5 的话，那么 <code>result</code> 里就是 1。</p>
<p>可见，减法操作是要区分被减集合和减集合的。</p>
<h3 id="对称差集"><a href="#对称差集" class="headerlink" title="对称差集"></a>对称差集</h3><p>对称差集又表示为 $A - B \cup B - A$，即取两种差集的并集。</p>
<p><img src="symmetrical-difference.png" alt=""></p>
<p>我们可以使用 <code>SymmetricalExcept</code> 方法获取对称差集。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.SymmetricalExcept(list2);</span><br></pre></td></tr></table></figure>
<p>由于最终用到了并集，所以计算过程并不区分调用方和被调用方，即你写成 <code>list2.SymmetricalExcept(list1)</code> 也是一样的。</p>
<h3 id="点乘法（交集）"><a href="#点乘法（交集）" class="headerlink" title="点乘法（交集）"></a>点乘法（交集）</h3><blockquote>
<p>为了区分这里的乘法和笛卡尔积的区别，我们把这里的乘法叫做点乘，而笛卡尔积我们表示为叉乘。</p>
</blockquote>
<p>点乘两个表（$A \cap B$）相当于为两个表作交集处理，取出都有的部分。</p>
<p><img src="intersection.png" alt=""></p>
<p>它使用的是 LINQ 里的 <code>Intersect</code> 方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.Intersect(list2);</span><br></pre></td></tr></table></figure>
<p>那么，如果 <code>list1</code> 里有 1、2、3，而 <code>list2</code> 里有 2、 3、 5 的话，那么 <code>result</code> 里就是 2、3。</p>
<h3 id="叉乘法（笛卡尔积）"><a href="#叉乘法（笛卡尔积）" class="headerlink" title="叉乘法（笛卡尔积）"></a>叉乘法（笛卡尔积）</h3><p>笛卡尔积在前文已经提到过了，它的模式是获取两个表的一一匹配的结果。我们使用的是 <code>SelectMany</code> 来实现的（当然你也可以用查询表达式实现），最终得到的结果通过匿名类型或者元组的方式返回出来，即可达到叉乘效果。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.SelectMany(d1 =&gt; list2.Select(d2 =&gt; (d1, d2)));</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="keyword">from</span> d1 <span class="keyword">in</span> list1</span><br><span class="line">             <span class="keyword">from</span> d2 <span class="keyword">in</span> list2</span><br><span class="line">             <span class="keyword">select</span> (d1, d2);</span><br></pre></td></tr></table></figure>
<p>这样就可以实现了。</p>
<h3 id="补集"><a href="#补集" class="headerlink" title="补集"></a>补集</h3><p>在 LINQ 的世界里，是不好实现补集一说的，因为全集是不清楚的。如果你要实现它，你可以尝试给出一个全局集合，然后作出补集。不过，这好比是使用全局集合减去当前集合得到的，所以补集完全不必去实现。</p>
<p><img src="complement.png" alt=""></p>
<p>它的公式大概就是 $A^C = \Omega - A$，其中 $\Omega$ 表示全局集合。</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>选择就是横向获取所有满足指定条件的对象。它相当于 <code>Where</code> 筛选方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = list1.Where(v =&gt; v &gt;= <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>这样就选择出了所有大于等于 5 的元素。</p>
<h3 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h3><p>投影就是纵向获取所有指定字段的信息。比如，我有一堆学生，学生包含姓名、学号等信息，我可以尝试使用 <code>Select</code> 方法获取所有学生的学号。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = students.Select(</span><br><span class="line">    student =&gt; <span class="keyword">new</span> &#123; student.Name, student.Age, student.Gender &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样筛选出来的就是所有学生的姓名、年龄和性别三大属性值。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接表（Join）在前面已经讲了很多了，所以这里我们就不再赘述了，不过需要注意的是，它还有很多操作，例如自然连接、非等值连接等等。</p>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>除法理解起来比较困难，所以我们把它放在最后讲，而且我们得分四个例子给大家解释。</p>
<p><img src="division-eg1.png" alt=""></p>
<p>第一个实例给出了 A 和 B 两个表，现在要获取两个表的商。除法运算的模式是，先找到第一个表在第二个表里没有的字段，即这里的甲和乙，然后每一个元组都看一遍。看看所有当前元组对应行上的对应 B 表的丙字段的数值有没有包含。如果包含就取出来。</p>
<p>我们发现，A 表第 1、2、3 行的元组信息里，丙字段的数值都是 3，所以这三个元组的甲乙两个字段的投影便是 A 除以 B 的商。</p>
<p><img src="division-eg2.png" alt=""></p>
<p>第二个例子稍微难一点。B 表多了一个值，那么筛选 A 表元组的时候，就必须要看，是否筛选出来的集合，包含了全部 B 给出的信息值。举个例子，B 表的丙字段是 3 和 6，我们就必须在 A 表里找到所有记录，这些记录的丙字段要包括所有 3 和 6。</p>
<p>我们尝试整理 A 表，发现 A 表记录里甲乙字段值为 4 和 2 的所有记录里，丙字段为 3 和 6，把 B 表给定的丙字段的结果全部包含在内，所以 4 和 2 是一个结果；同理，发现 A 表满足类似要求的还有 1 和 5 的所有信息，它们素有记录里也全部含有 3 和 6（只需要全部包含即可，可以允许有多出来的部分，比如 1 和 5 还包含了丙字段的 7、8、9 的信息）。</p>
<p><img src="division-eg3.png" alt=""></p>
<p>第三个例子和第二个例子类似，发现 A 表里甲乙字段记录为 1 和 5 的信息的所有的丙字段分别为 3、6、7、8、9，完整包含了 3、6、7、8，所以甲乙字段 1 和 5 是这个结果的一个记录。不过这个例子里，只有这一个结果满足要求，所以只有它。</p>
<p><img src="division-eg4.png" alt=""></p>
<p>最后一个例子里，B 表是两个记录，所以我们只能去筛选 A 表里甲字段的信息。发现，能够完整包含 B 表信息的所有数据的，只有甲字段为 1 和 4 的时候，它们的记录分别为 1、2、3 和 4、2、3，完整包含了 B 表乙丙字段的 2 和 3，所以 1 和 4 是这个除法的结果。</p>
<p>不过遗憾的是，LINQ 并不能够很好地实现除法运算，因为它需要保证两个表的信息能够被正确投影，而在 LINQ 里，投影出来的结果一般用匿名类型或元组表示，但匿名类型和元组我们没有基类可以使用，所以我们不能够简单地表达出这些字段或属性的信息，所以即使是想要使用反射，也是非常困难的。而在 SQL 里，例如 <code>R(X, Y)÷S(Y, Z)</code> 的运算用结构化语言 SQL 语句可表达为下列形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> R.X <span class="keyword">from</span> R R1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">( </span><br><span class="line">    <span class="keyword">select</span> S.Y <span class="keyword">from</span> S</span><br><span class="line">    <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">    ( </span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> R R2</span><br><span class="line">        <span class="keyword">where</span> R2.X=R1.X <span class="keyword">and</span> R2.Y=S.Y </span><br><span class="line">    ) </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>即利用的是双重否定表肯定的语义逻辑。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/">C♯.LINQ</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/C%E2%99%AF-LINQ-%E6%95%99%E7%A8%8B/">C♯.LINQ.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/SQL/">SQL</a><a href="/tags/LINQ/">LINQ</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/14/linq-07-aggregate-functions/" title="LINQ 教程（7）：聚合函数" itemprop="url">LINQ 教程（7）：聚合函数</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-14T12:55:42.000Z" itemprop="datePublished"> 发表于 2019-11-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="什么是聚合函数？"><a href="#什么是聚合函数？" class="headerlink" title="什么是聚合函数？"></a>什么是聚合函数？</h2><p>在 LINQ 的使用过程之中，我们肯定会用到 <code>Select</code>、<code>SelectMany</code>、<code>Where</code> 等方法。不过，这些方法是可以允许串联使用的，也就是说，这些方法可以一直往下通过方法链的方式，往下延伸到想要的地方结束。</p>
<p>不过，有一些 LINQ 提供的函数并不支持这种用途，而它们仅仅用来获取这些数据里的属性信息，例如求得一个整数集合 <code>IEnumerable&lt;int&gt;</code> 的最大值、平均值，或是获取总个数等等。这些函数在调用后，就无法继续往下调用其它的 LINQ 函数，而且它们往往都表示集合内部的属性。我们把这种函数称为<strong>聚合函数</strong>（Aggregate Function）。</p>
<blockquote>
<p>请记住，C# 在一般情况下都会把可执行的操作集称为方法（Method），而不是函数（Function）。但在一些特殊术语词汇和用途上，它们更被习惯性地称为函数。例如构造函数、析构函数以及聚合函数等，这些词汇一般不用“方法”一词。</p>
</blockquote>
<p>那么，LINQ 为我们提供了哪一些聚合函数呢？我们下面就来看看它们。</p>
<h2 id="聚合函数使用一览"><a href="#聚合函数使用一览" class="headerlink" title="聚合函数使用一览"></a>聚合函数使用一览</h2><p>先假设我们有一个集合：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> <span class="keyword">value</span> <span class="keyword">in</span> values</span><br><span class="line">                <span class="keyword">where</span> <span class="keyword">value</span> &gt;= <span class="number">6</span></span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>
<p>当然了，这个集合下面用不用都无关紧要，仅仅是为了表达出一些常见的聚合函数的用法。</p>
<h3 id="Max-和-Min-方法"><a href="#Max-和-Min-方法" class="headerlink" title="Max 和 Min 方法"></a><code>Max</code> 和 <code>Min</code> 方法</h3><p>显然，这两个方法用来求 <code>IEnumerable&lt;数值类型&gt;</code> 的最大值的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = selection.Max(); <span class="comment">// Get the maximum value.</span></span><br><span class="line"><span class="keyword">int</span> min = selection.Min(); <span class="comment">// Get the minimum one.</span></span><br></pre></td></tr></table></figure>
<p>它还有一堆重载方法。都是看的集合内元素的类型，进而去确定与之匹配的重载方法。</p>
<h3 id="Average-方法"><a href="#Average-方法" class="headerlink" title="Average 方法"></a><code>Average</code> 方法</h3><p>这个用法和求最大最小值没有差别。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> result = selection.Average();</span><br></pre></td></tr></table></figure>
<p>当然，请注意，这个返回值一定是 <code>double</code> 类型的。虽然 C# 提供了 <code>decimal</code> 类型，会更加精确，但 LINQ 里的求平均值用的是 <code>double</code>。</p>
<p>另外，它也有一堆重载方法。也是和上面的思路一样。</p>
<h3 id="Count-方法和-Any-无参方法"><a href="#Count-方法和-Any-无参方法" class="headerlink" title="Count 方法和 Any 无参方法"></a><code>Count</code> 方法和 <code>Any</code> 无参方法</h3><p>这个方法用于获取一个 <code>IEnumerable&lt;T&gt;</code> 集合里到底有多少个元素。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = selection.Count();</span><br></pre></td></tr></table></figure>
<p>注意，由于 LINQ 的实现用的是扩展方法，所以 <code>Count</code> 在这里是一个方法名，而不是属性，所以必须要加上这一对小括号。另外，如果你需要使用这个数值来判断一个集合是否有元素的话，一般可以写成</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> existAnyElement = selection.Count() != <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>不过，我建议你使用 <code>Any</code> 方法（无参的这个重载），来判断集合是否有元素。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> existAnyElement = selection.Any();</span><br></pre></td></tr></table></figure>
<h3 id="存在量词-Any-函数和全称量词-All-函数"><a href="#存在量词-Any-函数和全称量词-All-函数" class="headerlink" title="存在量词 Any 函数和全称量词 All 函数"></a>存在量词 <code>Any</code> 函数和全称量词 <code>All</code> 函数</h3><p>接着是两个比较常用的聚合函数，它们用于判断集合里是否有元素满足指定条件，或者是全部元素都满足指定条件。</p>
<p>举个例子。我们要查询集合里是否所有元素都小于 7，它的写法是这样的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> allLessThanEight = selection.All(v =&gt; v &lt;= <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>而如果查找集合里是否存在任意一个元素，它的数值小于 8，那么写作</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> anyValueLessThanEight = selection.Any(v =&gt; v &lt;= <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意不要把 Lambda 运算符 <code>=&gt;</code> 和小于等于符号 <code>&lt;=</code> 以及大于等于符号 <code>&gt;=</code> 看混了。</p>
</blockquote>
<p>刚才也说过，<code>Any</code> 的无参重载表示的是这个集合是否包含元素。所以这里就不提及了。</p>
<h3 id="Concat-函数"><a href="#Concat-函数" class="headerlink" title="Concat 函数"></a><code>Concat</code> 函数</h3><p>这个函数用于拼接两个元素类型一致的 <code>IEnumerable&lt;T&gt;</code> 集合。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; l1 = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span> &#125;;</span><br><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; l2 = <span class="keyword">new</span> Stack&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the function `Concat`.</span></span><br><span class="line"><span class="keyword">var</span> result = l1.Concat(l2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the result.</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> v <span class="keyword">in</span> result)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，两个集合即使类型不是一致的，但如果都实现了 <code>IEnumerable&lt;T&gt;</code> 接口的话，那么第 1、2 行给出的写法就一定奏效（隐式转换），然后调用 <code>Concat</code> 方法一定是可以的。但是，迭代器将会取决于具体类型的实现。比如例子给出的实现里，第二个则用的是一个栈（先进后出集合），所以最终拼接并遍历出来的结果顺序必然是 3、8、1、6、5、0、9、2、7、4，即后五个新加入的元素的顺序应倒过来。</p>
</blockquote>
<h3 id="Cast-函数"><a href="#Cast-函数" class="headerlink" title="Cast 函数"></a><code>Cast</code> 函数</h3><p>如果我们有一个 <code>IEnumerable</code> 集合，知道它的元素的类型，却发现我们无法使用 LINQ 函数，怎么办？我们可以调用该方法将其转换为泛型集合 <code>IEnumerable&lt;T&gt;</code> 对象。例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable helloStr = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"Hello"</span>, <span class="string">","</span>, <span class="string">" "</span>, <span class="string">"world"</span>, <span class="string">"!"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the function `Cast`.</span></span><br><span class="line">IEnumerable&lt;<span class="keyword">string</span>&gt; result = helloStr.Cast&lt;<span class="keyword">string</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>注意，为这个方法添加泛型参数，来表示这个集合需要转换为这个类型。当然，如果你尝试把它转换为其它类型，那么只会出现报错，提示转换失败；而且，<code>IEnumerable</code> 接口在迭代的时候，每一个元素都是 <code>object</code> 类型。如果内部存放的是值类型的话，将会产生拆箱操作。</p>
<h3 id="Distinct-函数"><a href="#Distinct-函数" class="headerlink" title="Distinct 函数"></a><code>Distinct</code> 函数</h3><p>这个函数类似于 SQL 语句里的 <code>distinct</code> 关键字，它用来筛选集合里的重复数据。重复的项将会只保留一个，但前提是，这个集合的元素类型必须是可以比较相等操作的（即要么它本身实现了 <code>IEquatable&lt;T&gt;</code> 或 <code>IEquatable</code> 接口，要么就手动规定比较规则，即使用 <code>IEqualityComparer&lt;T&gt;</code> 或 <code>IEqualityComparer</code> 接口）。</p>
<p>例如，我们要对一个集合去重，那么写法如下。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; values = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the function `Distinct`.</span></span><br><span class="line"><span class="comment">// `result` will include only three values: 3, 2 and 1.</span></span><br><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; result = values.Distinct();</span><br></pre></td></tr></table></figure>
<h3 id="Range-函数（静态函数）"><a href="#Range-函数（静态函数）" class="headerlink" title="Range 函数（静态函数）"></a><code>Range</code> 函数（静态函数）</h3><p>这个函数用于生成一个 <code>IEnumerable&lt;int&gt;</code> 集合，且集合从指定数值增大，一次一个单位。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; values = Enumerable.Range(<span class="number">0</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<p>这样将会获取 0 到 8，一共 9 个元素。第一个参数表示起始数值，第二个参数表示一共要取出多少个元素。</p>
<p>注意，这个函数是静态函数，所以调用的时候，请使用 <code>Enumerable.Range</code> 的方式调用。</p>
<h3 id="Repeat-函数（静态函数）"><a href="#Repeat-函数（静态函数）" class="headerlink" title="Repeat 函数（静态函数）"></a><code>Repeat</code> 函数（静态函数）</h3><p><code>Repeat</code> 函数和 <code>Range</code> 不同，它虽然也是静态函数，但生成的集合并不是按序增大的，而是重复的。比如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">string</span>&gt; strings = Enumerable.Repeat(<span class="string">"I like programming."</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure>
<p>这样将会生成一个拥有 15 个元素的、且元素全都是 <code>I like programming</code> 字符串的字符串列表。</p>
<h3 id="Take-和-Skip-函数"><a href="#Take-和-Skip-函数" class="headerlink" title="Take 和 Skip 函数"></a><code>Take</code> 和 <code>Skip</code> 函数</h3><p><code>Take</code> 函数用于获取集合的前多少个元素（类似于 SQL 的 <code>top</code> 关键字），而 <code>Skip</code> 函数则用于跳过指定个数的元素。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; values = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt; &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; r1 = values.Take(<span class="number">3</span>); <span class="comment">// 3, 2, 1</span></span><br><span class="line">IEnumerable&lt;<span class="keyword">int</span>&gt; r2 = values.Skip(<span class="number">3</span>).Take(<span class="number">2</span>); <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>Skip</code> 函数返回值依然是 <code>IEnumerable&lt;int&gt;</code> 类型，这样做的好处是可以继续使用成员访问运算符向下继续串联代码，而使用它所得到的集合，一定是从跳过了指定个数的元素后，作为第一项开始的新集合 <code>IEnumerable&lt;int&gt;</code>。换句话说，<code>values.Skip(3)</code> 将会返回的是 1、2、2、2、3、3、1、2、2 序列。</p>
<h3 id="ToArray-和-ToList-函数"><a href="#ToArray-和-ToList-函数" class="headerlink" title="ToArray 和 ToList 函数"></a><code>ToArray</code> 和 <code>ToList</code> 函数</h3><p>这两个函数用于将集合转换为数组 <code>T[]</code> 和列表集合 <code>List&lt;T&gt;</code>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = <span class="keyword">new</span> Queue&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"hello"</span>, <span class="string">","</span>, <span class="string">" "</span>, <span class="string">"world"</span>, <span class="string">"!"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>[] r1 = values.ToArray();</span><br><span class="line">List&lt;<span class="keyword">string</span>&gt; r2 = values.ToList();</span><br></pre></td></tr></table></figure>
<p>当然，LINQ 还提供了 <code>ToDictionary</code> 和 <code>ToHashSet</code> 函数，用于转字典和哈希表对象。这种转换就不在这里提及了，因为用得比较少，而且学习起来不太难。</p>
<p>还有一个 <code>ToLookUp</code> 方法，用于生成仅用于 LINQ 的类似于字典的分组表集合，这种集合专门用来存放分组数据，表示一对多的映射关系。</p>
<h3 id="First、FirstOrDefault、Single-和-SingleOrDefault-函数"><a href="#First、FirstOrDefault、Single-和-SingleOrDefault-函数" class="headerlink" title="First、FirstOrDefault、Single 和 SingleOrDefault 函数"></a><code>First</code>、<code>FirstOrDefault</code>、<code>Single</code> 和 <code>SingleOrDefault</code> 函数</h3><p><code>First</code> 方法有两个重载。一个是无参的，表示取出集合的第一个元素；第二个是有一个 Lambda 表达式参数的，表示获取满足指定条件的第一个元素。但是，这两个方法都有一个问题。当元素全部不满足要求的时候，运行将会抛出 <code>InvalidOperationException</code> 异常。</p>
<p>显然，这样做是容易出错的，于是我们提供了新方法：<code>FirstOrDefault</code>，它的操作和上一个一样，但当找不到元素的时候的行为不同。<code>FirstOrDefault</code> 方法在找不到满足要求的元素的时候，将会返回和元素的类型完全一样的这个类型的默认数值。比如一个集合是 <code>int</code> 类型的元素构成的，那么当找不到元素时，将会返回 <code>default(int)</code>，即 0。</p>
<p><code>Single</code> 和 <code>SingleOrDefault</code> 方法的行为则不同。它们除了计算整个集合满足要求的元素以外，还要要求整个集合只能有一个元素满足要求。<code>Single</code> 方法调用时，如果集合有超过一个元素满足该要求，则会直接抛出异常，而 <code>SingleOrDefault</code> 方法被调用时，如何有集合超过一个元素满足要求时，则会返回和集合元素类型一致的类型的默认值 <code>default(T)</code>。</p>
<h3 id="Last-和-LastOrDefault-函数"><a href="#Last-和-LastOrDefault-函数" class="headerlink" title="Last 和 LastOrDefault 函数"></a><code>Last</code> 和 <code>LastOrDefault</code> 函数</h3><p>当然了，这两个函数和上述用法基本一样，只是用来获取集合最后一个满足要求的元素。当然，找不到的话，<code>Last</code> 会产生 <code>InvalidOperationException</code>，而 <code>LastOrDefault</code> 将会返回默认数值 <code>default(T)</code>。</p>
<h3 id="ElementAt-函数"><a href="#ElementAt-函数" class="headerlink" title="ElementAt 函数"></a><code>ElementAt</code> 函数</h3><p>这个函数你完全可以理解为 <code>IEnumerable&lt;T&gt;</code> 集合类型的索引器。这里就不举例子了。</p>
<h3 id="Aggregate-函数"><a href="#Aggregate-函数" class="headerlink" title="Aggregate 函数"></a><code>Aggregate</code> 函数</h3><p>最后讲一个比较常见的聚合函数。把 aggregate 这个单词直译过来，实际上就是“聚合”的意思。真·聚合函数！</p>
<p>这个函数将每一次集合遍历过程的时候，通过指定的公式进行计算和处理，并得到最终的结果的行为就是这个函数的使用方式了。它有三个重载。</p>
<p>第一个重载是非常简单的，除了扩展方法的 <code>IEnumerable&lt;T&gt;</code> 集合自己，只需要给出一个额外参数，这个参数是一个 Lambda 表达式，表示一个聚合公式，把所有元素按照这个公式计算的结果聚合起来。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"hello"</span>, <span class="string">","</span>, <span class="string">" "</span>, <span class="string">"world"</span>, <span class="string">"!"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = values.Aggregate((s, v) =&gt; <span class="string">$"<span class="subst">&#123;s&#125;</span><span class="subst">&#123;v&#125;</span>"</span>);</span><br><span class="line">Console.WriteLine(result);</span><br></pre></td></tr></table></figure>
<p>可以看懂这个聚合函数的意义吗？这个函数将字符串序列按照顺序依次拼接，得到字符串结果。Lambda 表达式里的 <code>s</code> 表示临时变量，用于积累元素处理期间的数据的，而这个 <code>v</code> 就是集合在每一次遍历过程之中的元素。我们把用来积累的变量 <code>s</code> 往后添加 <code>v</code>，就凑成了字符串拼接后的新字符串，然后再往后添加下一个字符串，直到集合遍历完成。当然最终这个结果就是一个完整的字符串了。</p>
<p>第二个重载需要加入一个初始值 <code>seed</code> 参数。即可以改写一下上面的写法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.Aggregate(<span class="string">"Sunnie, "</span>, (s, v) =&gt; <span class="string">$"<span class="subst">&#123;s&#125;</span><span class="subst">&#123;v&#125;</span>"</span>);</span><br></pre></td></tr></table></figure>
<p>第三个重载，则在最后增加一个参数，用于指定聚合的处理情况。如下代码所示。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.Aggregate(<span class="string">"Sunnie, "</span>, (s, v) =&gt; <span class="string">$"<span class="subst">&#123;s&#125;</span><span class="subst">&#123;v&#125;</span>"</span>, v =&gt; v.ToUpper());</span><br></pre></td></tr></table></figure>
<p>这个聚合操作，将会把所有聚合的元素全部先转为大写，然后输出。自然结果就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNNIE, HELLO, WORLD!</span><br></pre></td></tr></table></figure>
<p>是不是很神奇呢？</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/">C♯.LINQ</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/C%E2%99%AF-LINQ-%E6%95%99%E7%A8%8B/">C♯.LINQ.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/SQL/">SQL</a><a href="/tags/LINQ/">LINQ</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/14/linq-06-phase-exercises/" title="LINQ 教程（6）：阶段性练习" itemprop="url">LINQ 教程（6）：阶段性练习</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-14T09:38:10.000Z" itemprop="datePublished"> 发表于 2019-11-14</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="一起来练习吧！"><a href="#一起来练习吧！" class="headerlink" title="一起来练习吧！"></a>一起来练习吧！</h2><p>在前面的内容里，我们尝试了非常多的 LINQ 语句（查询表达式格式以及方法链调用格式），今天我们这一节不讲解内容，而是来做一个小练习。</p>
<h3 id="题目一：关键字查询"><a href="#题目一：关键字查询" class="headerlink" title="题目一：关键字查询"></a>题目一：关键字查询</h3><p>我们依旧拿出之前用过的实例：关键字。C# 拥有上百个关键字，这使得我们使用 C# 语言更加丰富多彩：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> words = <span class="keyword">new</span>[]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"abstract"</span>, <span class="string">"as"</span>,</span><br><span class="line">    <span class="string">"base"</span>, <span class="string">"bool"</span>, <span class="string">"break"</span>, <span class="string">"byte"</span>,</span><br><span class="line">    <span class="string">"case"</span>, <span class="string">"catch"</span>, <span class="string">"char"</span>, <span class="string">"checked"</span>, <span class="string">"class"</span>, <span class="string">"const"</span>, <span class="string">"continue"</span>,</span><br><span class="line">    <span class="string">"decimal"</span>, <span class="string">"default"</span>, <span class="string">"delegate"</span>, <span class="string">"do"</span>, <span class="string">"double"</span>,</span><br><span class="line">    <span class="string">"else"</span>, <span class="string">"enum"</span>, <span class="string">"event"</span>, <span class="string">"explicit"</span>, <span class="string">"extern"</span>,</span><br><span class="line">    <span class="string">"false"</span>, <span class="string">"finally"</span>, <span class="string">"fixed"</span>, <span class="string">"float"</span>, <span class="string">"for"</span>, <span class="string">"foreach"</span>,</span><br><span class="line">    <span class="string">"goto"</span>,</span><br><span class="line">    <span class="string">"if"</span>, <span class="string">"implicit"</span>, <span class="string">"in (foreach)"</span>, <span class="string">"int"</span>, <span class="string">"interface"</span>, <span class="string">"internal"</span>, <span class="string">"is"</span>,</span><br><span class="line">    <span class="string">"lock"</span>, <span class="string">"long"</span>,</span><br><span class="line">    <span class="string">"namespace"</span>, <span class="string">"new"</span>, <span class="string">"null"</span>,</span><br><span class="line">    <span class="string">"object"</span>, <span class="string">"operator"</span>, <span class="string">"out (generic modifier)"</span>, <span class="string">"out (parameter)"</span>, <span class="string">"override"</span>,</span><br><span class="line">    <span class="string">"params"</span>, <span class="string">"private"</span>, <span class="string">"protected"</span>, <span class="string">"public"</span>,</span><br><span class="line">    <span class="string">"readonly"</span>, <span class="string">"ref"</span>, <span class="string">"return"</span>,</span><br><span class="line">    <span class="string">"sbyte"</span>, <span class="string">"sealed"</span>, <span class="string">"short"</span>, <span class="string">"sizeof"</span>, <span class="string">"stackalloc"</span>, <span class="string">"static"</span>, <span class="string">"string"</span>, <span class="string">"struct"</span>, <span class="string">"switch"</span>,</span><br><span class="line">    <span class="string">"this"</span>, <span class="string">"throw"</span>, <span class="string">"true"</span>, <span class="string">"try"</span>, <span class="string">"typeof"</span>,</span><br><span class="line">    <span class="string">"uint"</span>, <span class="string">"ulong"</span>, <span class="string">"unchecked"</span>, <span class="string">"unsafe"</span>, <span class="string">"ushort"</span>, <span class="string">"using"</span>,</span><br><span class="line">    <span class="string">"virtual"</span>, <span class="string">"void"</span>, <span class="string">"volatile"</span>,</span><br><span class="line">    <span class="string">"while"</span>,</span><br><span class="line">    <span class="string">"*add"</span>, <span class="string">"*alias"</span>, <span class="string">"*ascending"</span>, <span class="string">"*async"</span>, <span class="string">"*await"</span>,</span><br><span class="line">    <span class="string">"*by"</span>,</span><br><span class="line">    <span class="string">"*descending"</span>, <span class="string">"*dynamic"</span>,</span><br><span class="line">    <span class="string">"*equals"</span>,</span><br><span class="line">    <span class="string">"*from"</span>,</span><br><span class="line">    <span class="string">"*get"</span>, <span class="string">"*global"</span>, <span class="string">"*group"</span>,</span><br><span class="line">    <span class="string">"*in (generic modifier)"</span>, <span class="string">"*in (parameter)"</span>, <span class="string">"*in (query)"</span>, <span class="string">"*into"</span>,</span><br><span class="line">    <span class="string">"*join"</span>,</span><br><span class="line">    <span class="string">"*let"</span>,</span><br><span class="line">    <span class="string">"*nameof"</span>, <span class="string">"*notnull"</span>,</span><br><span class="line">    <span class="string">"*on"</span>, <span class="string">"*orderby"</span>,</span><br><span class="line">    <span class="string">"*partial (method)"</span>, <span class="string">"*partial (type)"</span>,</span><br><span class="line">    <span class="string">"*remove"</span>,</span><br><span class="line">    <span class="string">"*select"</span>, <span class="string">"*set"</span>, <span class="string">"*switch (expression)"</span>,</span><br><span class="line">    <span class="string">"*unmanaged"</span>, <span class="string">"*using static"</span>,</span><br><span class="line">    <span class="string">"*value"</span>, <span class="string">"*var"</span>,</span><br><span class="line">    <span class="string">"*when"</span>, <span class="string">"*where (generic constraint)"</span>, <span class="string">"*where (query)"</span>,</span><br><span class="line">    <span class="string">"*yield"</span>,</span><br><span class="line">    <span class="string">"#annotations"</span>,</span><br><span class="line">    <span class="string">"#checksum"</span>,</span><br><span class="line">    <span class="string">"#disable"</span>,</span><br><span class="line">    <span class="string">"#enable"</span>,</span><br><span class="line">    <span class="string">"#nullable"</span>,</span><br><span class="line">    <span class="string">"#restore"</span>,</span><br><span class="line">    <span class="string">"!#safeonly"</span>,</span><br><span class="line">    <span class="string">"#warning"</span>, <span class="string">"#warnings"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面试着完成如下的小练习：</p>
<ol>
<li>取出所有第一个字符不是符号的关键字；</li>
<li>取出所有不含有注解文字（包含小括号的注解）的关键字；</li>
<li>取出所有只有一个符号开头的关键字（例如 <code>!#safeonly</code> 就不应该包含在该集合里，因为它以两个符号开头）；</li>
<li>取出所有上下文关键字（以 <code>*</code> 符号开头的关键字）；</li>
<li>取出所有的预处理器关键字（以 <code>#</code> 或以 <code>!#</code> 符号开头的关键字）；</li>
<li>取出所有超过 7 个字符的关键字（包含符号在内）；</li>
<li>将所有不是以符号开头的关键字按字母表顺序升序排序；</li>
<li>将所有第一个字符是符号的关键字以第二个字符升序排序；</li>
<li>将所有关键字以第一个字符分组；</li>
<li>取出所有关键字的第一个字符的所有情况；</li>
<li>取出所有关键字的单词部分（即忽略掉所有的前缀符号），并按忽略后的关键字，它们的第一个字符进行升序排序并分组；</li>
<li>使用目前学过的知识点，尝试将所有关键字按第一个字符进行升序排序，然后取出倒数 30 个关键字。</li>
</ol>
<h3 id="题目二：宠物和主人"><a href="#题目二：宠物和主人" class="headerlink" title="题目二：宠物和主人"></a>题目二：宠物和主人</h3><p>现给出狗狗和猫咪若干只，并给出如下的类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">internal class Person : IEquatable&lt;Person&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">Person other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> FirstName == other.FirstName &amp;&amp; LastName == other.LastName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span> other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">is</span> Person comparer &amp;&amp; Equals(comparer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> FirstName.GetHashCode() ^ LastName.GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"<span class="subst">&#123;FirstName&#125;</span> <span class="subst">&#123;LastName&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Person left, Person right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left.Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(Person left, Person right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !left.Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Person Owner &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Pet</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Pet</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>并给出如下信息：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> magnus = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Magnus"</span>, LastName = <span class="string">"Hedlund"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> terry = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Terry"</span>, LastName = <span class="string">"Adams"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> charlotte = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Charlotte"</span>, LastName = <span class="string">"Weiss"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> arlene = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Arlene"</span>, LastName = <span class="string">"Huff"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> rui = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Rui"</span>, LastName = <span class="string">"Raposo"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> phyllis = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Phyllis"</span>, LastName = <span class="string">"Harris"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> barley = <span class="keyword">new</span> Cat &#123; Name = <span class="string">"Barley"</span>, Owner = terry &#125;;</span><br><span class="line"><span class="keyword">var</span> boots = <span class="keyword">new</span> Cat &#123; Name = <span class="string">"Boots"</span>, Owner = terry &#125;;</span><br><span class="line"><span class="keyword">var</span> whiskers = <span class="keyword">new</span> Cat &#123; Name = <span class="string">"Whiskers"</span>, Owner = charlotte &#125;;</span><br><span class="line"><span class="keyword">var</span> bluemoon = <span class="keyword">new</span> Cat &#123; Name = <span class="string">"Blue Moon"</span>, Owner = rui &#125;;</span><br><span class="line"><span class="keyword">var</span> daisy = <span class="keyword">new</span> Cat &#123; Name = <span class="string">"Daisy"</span>, Owner = magnus &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fourwheeldrive = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Four Wheel Drive"</span>, Owner = phyllis &#125;;</span><br><span class="line"><span class="keyword">var</span> duke = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Duke"</span>, Owner = magnus &#125;;</span><br><span class="line"><span class="keyword">var</span> denim = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Denim"</span>, Owner = terry &#125;;</span><br><span class="line"><span class="keyword">var</span> wiley = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Wiley"</span>, Owner = charlotte &#125;;</span><br><span class="line"><span class="keyword">var</span> snoopy = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Snoopy"</span>, Owner = rui &#125;;</span><br><span class="line"><span class="keyword">var</span> snickers = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Snickers"</span>, Owner = arlene &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create three lists.</span></span><br><span class="line"><span class="keyword">var</span> people =</span><br><span class="line">    <span class="keyword">new</span> List&lt;Person&gt; &#123; magnus, terry, charlotte, arlene, rui, phyllis &#125;;</span><br><span class="line"><span class="keyword">var</span> cats =</span><br><span class="line">    <span class="keyword">new</span> List&lt;Cat&gt; &#123; barley, boots, whiskers, bluemoon, daisy &#125;;</span><br><span class="line"><span class="keyword">var</span> dogs =</span><br><span class="line">    <span class="keyword">new</span> List&lt;Dog&gt; &#123; fourwheeldrive, duke, denim, wiley, snoopy, snickers &#125;;</span><br></pre></td></tr></table></figure>
<p>请查找如下内容：</p>
<ol>
<li>所有狗狗自己的名字；</li>
<li>所有猫咪的主人的姓和名；</li>
<li>所有狗狗和猫咪的主人的姓和名；</li>
<li>所有养了两只狗狗的主人；</li>
<li>所有没有养宠物的人。</li>
</ol>
<h3 id="题目三：杂货铺"><a href="#题目三：杂货铺" class="headerlink" title="题目三：杂货铺"></a>题目三：杂货铺</h3><p>给定一些类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> CategoryID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Category</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并提供如下信息：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> categories = <span class="keyword">new</span> List&lt;Category&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> Category() &#123; Name = <span class="string">"Beverages"</span>, ID = <span class="number">001</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Category() &#123; Name = <span class="string">"Condiments"</span>, ID = <span class="number">002</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Category() &#123; Name = <span class="string">"Vegetables"</span>, ID = <span class="number">003</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Specify the second data source.</span></span><br><span class="line"><span class="keyword">var</span> products = <span class="keyword">new</span> List&lt;Product&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Tea"</span>, CategoryID = <span class="number">001</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Mustard"</span>, CategoryID = <span class="number">002</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Pickles"</span>, CategoryID = <span class="number">002</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Carrots"</span>, CategoryID = <span class="number">003</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Bok Choy"</span>, CategoryID = <span class="number">003</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Peaches"</span>, CategoryID = <span class="number">005</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Melons"</span>, CategoryID = <span class="number">005</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Ice Cream"</span>, CategoryID = <span class="number">007</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Mackerel"</span>, CategoryID = <span class="number">012</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>请找出如下内容：</p>
<ol>
<li>所有商品的分类 ID；</li>
<li>所有名字至少含有两个单词的商品；</li>
<li>所有饮品；</li>
<li>所有调味料；</li>
<li>胡萝卜（Carrot）的所有信息（名字、编号以及它的所属类别的名称）；</li>
<li>白菜（Bok Choy）的分类名称；</li>
<li>所有拥有两个商品的分类。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/">C♯.LINQ</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/C%E2%99%AF-LINQ-%E6%95%99%E7%A8%8B/">C♯.LINQ.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/LINQ/">LINQ</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/13/linq-05-join-clause/" title="LINQ 教程（5）：join 从句" itemprop="url">LINQ 教程（5）：join 从句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-13T11:55:14.000Z" itemprop="datePublished"> 发表于 2019-11-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="先让我们用以前的知识来实现"><a href="#先让我们用以前的知识来实现" class="headerlink" title="先让我们用以前的知识来实现"></a>先让我们用以前的知识来实现</h2><p>接着，我们继续讲解 LINQ 的新的一种从句类型：<code>join</code> 从句。这种从句的格式比较复杂，因为它比较像 SQL 里的连接表操作。</p>
<blockquote>
<p>下文里，我们会把原本应该用的“联接”这种写法改为“连接”，这并不是打错，因为我们不必去区分两个词语的区别，它们都表示把两个事物拼接起来。</p>
</blockquote>
<p>不过今天有点不同的是，由于前文叙述的实例（关键字实例）只有一个表，而且不太好讲述今天的内容，所以今天我们换一个例子：宠物和主人。我们预先创建好了如下的一些类。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Person : IEquatable&lt;Person&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LastName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">Person other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> FirstName == other.FirstName &amp;&amp; LastName == other.LastName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span> other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">is</span> Person comparer &amp;&amp; Equals(comparer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> FirstName.GetHashCode() ^ LastName.GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; <span class="string">$"<span class="subst">&#123;FirstName&#125;</span> <span class="subst">&#123;LastName&#125;</span>"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Person left, Person right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left.Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(Person left, Person right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !left.Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Pet</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Person Owner &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; Name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>Person</code> 类是人的信息（名和姓），而 <code>Pet</code> 类是宠物的信息（宠物名和主人）。当然，为了下文比较信息方便，我们尝试让 <code>Person</code> 类实现 <code>IEquatable&lt;Person&gt;</code> 接口，并重载它的等号和不等号运算符，以便后续使用运算符比较相等性。</p>
<p>并且提供如下的一些预先提供好，用来查找的信息：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Persons.</span></span><br><span class="line"><span class="keyword">var</span> magnus = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Magnus"</span>, LastName = <span class="string">"Hedlund"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> terry = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Terry"</span>, LastName = <span class="string">"Adams"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> charlotte = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Charlotte"</span>, LastName = <span class="string">"Weiss"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> arlene = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Arlene"</span>, LastName = <span class="string">"Huff"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> rui = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Rui"</span>, LastName = <span class="string">"Raposo"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pets.</span></span><br><span class="line"><span class="keyword">var</span> barley = <span class="keyword">new</span> Pet &#123; Name = <span class="string">"Barley"</span>, Owner = terry &#125;;</span><br><span class="line"><span class="keyword">var</span> boots = <span class="keyword">new</span> Pet &#123; Name = <span class="string">"Boots"</span>, Owner = terry &#125;;</span><br><span class="line"><span class="keyword">var</span> whiskers = <span class="keyword">new</span> Pet &#123; Name = <span class="string">"Whiskers"</span>, Owner = charlotte &#125;;</span><br><span class="line"><span class="keyword">var</span> bluemoon = <span class="keyword">new</span> Pet &#123; Name = <span class="string">"Blue Moon"</span>, Owner = rui &#125;;</span><br><span class="line"><span class="keyword">var</span> daisy = <span class="keyword">new</span> Pet &#123; Name = <span class="string">"Daisy"</span>, Owner = magnus &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lists.</span></span><br><span class="line"><span class="keyword">var</span> people = <span class="keyword">new</span> List&lt;Person&gt; &#123; magnus, terry, charlotte, arlene, rui &#125;;</span><br><span class="line"><span class="keyword">var</span> pets = <span class="keyword">new</span> List&lt;Pet&gt; &#123; barley, boots, whiskers, bluemoon, daisy &#125;;</span><br></pre></td></tr></table></figure>
<p>为了方便，我们在最后也创建了两个列表，专门存放这些数据。</p>
<p>现在我们来尝试取出关联信息：输出所有宠物，以及它们对应主人的信息。这应该如何做到呢？我们最开始想到的写法是这样的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> pet <span class="keyword">in</span> pets</span><br><span class="line">                <span class="keyword">select</span> (name:  pet.Name, owner: pet.Owner);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>select</code> 从句使用了一个三元组，把宠物以及它们自己的主人的姓和名全部组织起来了。</p>
</blockquote>
<p>这样就可以取出这些信息，然后输出它们：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> info <span class="keyword">in</span> petsInfos)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;name&#125;</span> is owned by <span class="subst">&#123;owner&#125;</span>."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是，这样执行下来，确实可以得到结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Daisy is owned by Magnus Hedlund</span><br><span class="line">Barley is owned by Terry Adams</span><br><span class="line">Boots is owned by Terry Adams</span><br><span class="line">Whiskers is owned by Charlotte Weiss</span><br><span class="line">Blue Moon is owned by Rui Raposo</span><br></pre></td></tr></table></figure>
<p>听起来不错？我们来看看，另外一个思维如何。</p>
<p>我们这么思考这个问题。我们把两个数据列表关联起来。怎么关联呢？笛卡尔积就好。</p>
<h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><h3 id="笛卡尔积的概念"><a href="#笛卡尔积的概念" class="headerlink" title="笛卡尔积的概念"></a>笛卡尔积的概念</h3><p>什么是笛卡尔积呢？在数据表里，我们常常会把所有字段挨个组合拼接起来。比如第一个列表有 3 个信息，而第二个表有 5 个信息。笛卡尔积就好比是把第一个表的每一个信息和第二个表的每一个信息挨个拼接起来，组合成一个具有 15 个信息的大表。这种组合方式有一个好处就是方便查询，而不需要每次把不同表的内容分开执行查询，然后再通过一些难受的操作组织整合起来。哪怕这样拼接起来是没有意义的。只要后续我们筛选掉这些无意义的数据就可以了。</p>
<h3 id="查询表达式写法"><a href="#查询表达式写法" class="headerlink" title="查询表达式写法"></a>查询表达式写法</h3><p>比如，这里的两个表，我们做笛卡尔积，把每一个主人和每一个宠物都匹配一遍。只要找到主人的姓名信息和宠物的主人给出的信息一样，那我们就选出来。于是，我们的写法是这样的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> person <span class="keyword">in</span> people</span><br><span class="line">                <span class="keyword">from</span> pet <span class="keyword">in</span> pets</span><br><span class="line">                <span class="keyword">let</span> owner = pet.Owner</span><br><span class="line">                <span class="keyword">where</span> person == owner</span><br><span class="line">                <span class="keyword">select</span> (name:  pet.Name, owner: owner);</span><br></pre></td></tr></table></figure>
<p>注意书写格式和模式。这里在 <code>from</code> 从句下面还有一个新的 <code>from</code> 从句。这个写法是我们之前没有见过的。正是因为没有见过，所以我们作为新东西介绍给大家。这个写法就是在做笛卡尔积。它尝试在遍历每一个人的信息的时候，把每一个人都和每一个宠物作匹配。当目前计算到的这个人和宠物所属主人的信息是一样的时候，就选取出来。这样依然可以达到效果。</p>
<h3 id="方法链写法"><a href="#方法链写法" class="headerlink" title="方法链写法"></a>方法链写法</h3><p>可以发现，它实际上在做两层 <code>foreach</code> 循环，外层就是这里的 <code>people</code>，而内层则是 <code>pets</code>。这是可以理解的。但 LINQ 不是这么去实现的，它为了能够完成对这个操作的迭代，它采用了一种“一对多”的机制，把每一个元素都匹配上所有的宠物。</p>
<p>当然，我相信这里的内容是目前内容里掌握起来最难的地方。不过我相信你能够多看几次就可以明白它们。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> seletion = people.SelectMany(person =&gt; pets.Where(pet =&gt; person == pet.Owner).Select(pet =&gt; (pet.Name, person)));</span><br></pre></td></tr></table></figure>
<p>显然，这个写法有点长，我们尝试改写一下，Lambda 表达式是可以写成语句块的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> seletion = people.SelectMany(person =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pets.Where(pet =&gt; person == pet.Owner)</span><br><span class="line">               .Select(pet =&gt; (name: pet.Name, owner: person));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样看起来似乎比刚才那种写法要清爽一些，那么我们尝试去理解一下这种写法。</p>
<p>点开 <code>SelectMany</code> 方法，你可以立马发现，这个方法的函数声明是这样的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable&lt;TResult&gt; SelectMany&lt;TSource, TResult&gt;(</span><br><span class="line">    <span class="keyword">this</span> IEnumerable&lt;TSource&gt;,</span><br><span class="line">    Func&lt;TSource, IEnumerable&lt;TResult&gt;&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>首先第一个参数就是遍历的列表集合，显然这个就是扩展方法给出的对象类型实例，这个可以放一边。第二个参数则是 <code>Func&lt;TSource, IEnumerable&lt;TResult&gt;&gt;</code> 的类型，它表示你给出的一个 Lambda 表达式，传入一个 <code>TSource</code> 泛型类型，然后得到 <code>IEnumerable&lt;TResult&gt;</code> 类型，即一个 <code>TResult</code> 类型的可遍历集合。</p>
<p>可以看到，它想要告诉的是，你需要给出一个一对多的映射模型，即当我们的集合里的每一个元素，都必须按照后面给出的 Lambda 表达式，来一一对应，一个元素对应一个集合、一个元素对应一个集合……。这样来看，在后续执行的思路里，只要我们在内层筛选掉“一个集合”里这个集合的一部分不正确的部分。</p>
<p>例如这个例子里，它在内条件里用了 <code>Where</code> 方法，筛选掉了其中一部分，然后通过 <code>Select</code> 映射，来映射出一个宠物，对应的主人名字和宠物自己的名字。然后，外部调用了 <code>SelectMany</code> 方法，来让每一个人，都对应一组宠物信息（主人名和宠物名），然后它将会自动整合，形成一个自动整合好了的普通的序列，而不是多个一对多关系的序列。</p>
<p>那么，返回值是 <code>IEnumerable&lt;TResult&gt;</code> 类型的 <code>SelectMany</code>，这里对应的是什么方法呢？当然就是这里给的 <code>IEnumerable&lt;(string, Person)&gt;</code>。这便是印证了刚才说的整合序列的逻辑。</p>
<p>再来对比原本给出的查询表达式写法，可以发现，它的实现就完全不一样了。但仔细思考一下，实际上它想要表示的意思是这样的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> person <span class="keyword">in</span> people)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> pet <span class="keyword">in</span> pets)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> owner = pet.Owner;</span><br><span class="line">        <span class="keyword">if</span> (person == owner)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get the info pair.</span></span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="title">return</span> (<span class="params">name: pet.Name, owner: owner</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，一个 <code>from</code> 从句就翻译为一层循环，所以第二层循环已经在内部了，所以转译的方法链写法，显然筛选的操作应该写在 Lambda 表达式的内部，即内层，而不是方法链平行的外部。</p>
<blockquote>
<p>注意，作笛卡尔积的操作，在查询里也称为交叉连接。</p>
</blockquote>
<h2 id="join-从句派生出来的各种连接类型"><a href="#join-从句派生出来的各种连接类型" class="headerlink" title="join 从句派生出来的各种连接类型"></a><code>join</code> 从句派生出来的各种连接类型</h2><p>现在，我们终于可以学习新从句类型——<code>join</code> 从句了！不过，这个从句类型是目前学到的类型里最难的一种从句，所以它的类型也是丰富多样，我们得分很多类型分情况讲解。</p>
<h3 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h3><p>第一种要介绍的连接方式就是交叉连接了。这是最基础也是最容易掌握的连接模式。不过，交叉连接就是笛卡尔积，所以这一节没有内容，请你往前翻一翻，上一节在讲解这一个内容。</p>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>第一种类型，我更喜欢称为“笛卡尔积连接”，因为它是从“笛卡尔积+筛选后连接”的方式变过去的。这种写法需要用到的方式是这样的写法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> person <span class="keyword">in</span> people</span><br><span class="line">                <span class="keyword">join</span> pet <span class="keyword">in</span> pets <span class="keyword">on</span> person <span class="keyword">equals</span> pet.Owner</span><br><span class="line">                <span class="keyword">select</span> (name: pet.Name, owner: pet.Owner);</span><br></pre></td></tr></table></figure>
<p>我们尝试把前文的例子转换为 <code>join</code> 从句。此时我们就可以看到，这个筛选模式得到的结果照样是正确的。首先，我们依旧从 <code>from</code> 从句开始，遍历每一个 <code>person</code>。接着，我们使用 <code>join</code> 从句开始连接另外一个列表 <code>pets</code>。在 <code>people</code> 表右侧拼接一个 <code>pets</code> 表，拼接条件是，当前拼接项的 <code>person</code> 和 <code>pet</code> 的主人属性值是一样的时候，我们就拼接起来。然后选取出宠物名称和宠物主人两大属性，作为选取项。</p>
<p>在打开 Intellisense 的时候，它会提示你转换为 Call-form，于是代码变为这样。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = people.SelectMany(person =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pets.Where(pet =&gt; <span class="keyword">object</span>.Equals(person, pet.Owner))</span><br><span class="line">               .Select(pet =&gt; (name: pet.Name, owner: pet.Owner));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果发现，它和前文的写法基本上是一样的。你可以思考一下，为什么这两种写法完全是一样的。唯一的不同是，它把条件从运算符 <code>==</code> 转为了 <code>object.Equals</code> 方法，其它的地方完全没有变化。当然，你要注意，这里我建议你换为 <code>==</code> 运算符，而不要使用默认提供的 <code>object.Equals</code> 方法。因为 <code>object.Equals</code> 静态方法比较的两个对象，使用的仅仅是这两个对象的引用。</p>
<p>不过，实际上，虽然 Intellisense 提供这样的转换，但它并没有表示出完整的 <code>join</code> 从句想要表达的意思。所以，我们尝试使用 <code>Join</code> 方法的转换方法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = people.Join(</span><br><span class="line">    pets,</span><br><span class="line">    person        =&gt; person,</span><br><span class="line">    pet           =&gt; pet.Owner,</span><br><span class="line">    (person, pet) =&gt; (name: pet.Name, owner: pet.Owner)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>看起来好复杂的说。我们挨个来看，这四个参数的意思。第一个参数是为 <code>people</code> 表拼接的另外一张表的名称，这里肯定就是宠物表 <code>pets</code> 了；第二个参数是第一个比较参数 <code>person</code>；第三个参数是第二个比较参数 <code>pet.Owner</code>。这里指的比较参数就是我们在 <code>join</code> 从句里用作 <code>A equals B</code> 里的 <code>A</code> 和 <code>B</code>；第四个参数则是取出最终结果的 Lambda 表达式。</p>
<p>Lambda 表达式规定，当参数个数不为 1 个的时候，需要用小括号把所有参数括起来。这便是 <code>Join</code> 方法的使用方法。</p>
<h3 id="组合键连接"><a href="#组合键连接" class="headerlink" title="组合键连接"></a>组合键连接</h3><p>下面我们把前文的内连接模式改一下。</p>
<p>试想一下，上一个实例里，如果我们并没有提供 <code>IEquatable&lt;Person&gt;</code> 的实现，那么 <code>Person</code> 类信息的比较就必须得拆开。好在我们拼接过程的时候，用的是 <code>string</code>，而 <code>string</code> 给出了一套完整的比较方式操作，不需要我们自己实现 <code>string</code> 的比较，所以我们可以把上面的代码改写为这样。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> person <span class="keyword">in</span> people</span><br><span class="line">                <span class="keyword">join</span> pet <span class="keyword">in</span> pets</span><br><span class="line">                <span class="keyword">let</span> owner = pet.Owner</span><br><span class="line">                    <span class="keyword">on</span> (person.FirstName, person.LastName)</span><br><span class="line">                    <span class="keyword">equals</span> (owner.FirstName, owner.LastName)</span><br><span class="line">                <span class="keyword">select</span> (name: pet.Name, owner: owner);</span><br></pre></td></tr></table></figure>
<p>或用匿名类型</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> person <span class="keyword">in</span> people</span><br><span class="line">                <span class="keyword">join</span> pet <span class="keyword">in</span> pets</span><br><span class="line">                <span class="keyword">let</span> owner = pet.Owner</span><br><span class="line">                    <span class="keyword">on</span> <span class="keyword">new</span> &#123; person.FirstName, person.LastName &#125;</span><br><span class="line">                    <span class="keyword">equals</span> <span class="keyword">new</span> &#123; owner.FirstName, owner.LastName &#125;</span><br><span class="line">                <span class="keyword">select</span> (name: pet.Name, owner: owner);</span><br></pre></td></tr></table></figure>
<p>此时的拼接方式，就称为组合键比较模型。注意，值元组和匿名类型都提供了具体的逐个比较的完整比较的操作，它能够找到对应相同的字段，进行比较。哪怕无法完成正确的比较模式，它们也会使用默认的比较操作 <code>GetHashCode</code> 方法来比较哈希码。</p>
<p>当然，它的方法链模式写法是这样的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = people.Join(</span><br><span class="line">    pets,</span><br><span class="line">    person        =&gt; (person.FirstName, person.LastName),</span><br><span class="line">    pet           =&gt; (pet.Owner.FirstName, pet.Owner.LastName),</span><br><span class="line">    (person, pet) =&gt; (name: pet.Name, owner: pet.Owner)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然，这个写法我没有写 <code>Select</code> 方法来写出匹配 <code>let</code> 从句的内容，否则这样写起来读起来就很复杂了，不利于这里的学习。</p>
</blockquote>
<h3 id="多连接"><a href="#多连接" class="headerlink" title="多连接"></a>多连接</h3><p>下面我们来看更复杂的。我们把原本的例子的模型改一下，现在我们把宠物的类型进行细化：有猫也有狗。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Pet</span> &#123; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Pet</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>然后重新组表：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> magnus = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Magnus"</span>, LastName = <span class="string">"Hedlund"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> terry = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Terry"</span>, LastName = <span class="string">"Adams"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> charlotte = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Charlotte"</span>, LastName = <span class="string">"Weiss"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> arlene = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Arlene"</span>, LastName = <span class="string">"Huff"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> rui = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Rui"</span>, LastName = <span class="string">"Raposo"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> phyllis = <span class="keyword">new</span> Person &#123; FirstName = <span class="string">"Phyllis"</span>, LastName = <span class="string">"Harris"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> barley = <span class="keyword">new</span> Cat &#123; Name = <span class="string">"Barley"</span>, Owner = terry &#125;;</span><br><span class="line"><span class="keyword">var</span> boots = <span class="keyword">new</span> Cat &#123; Name = <span class="string">"Boots"</span>, Owner = terry &#125;;</span><br><span class="line"><span class="keyword">var</span> whiskers = <span class="keyword">new</span> Cat &#123; Name = <span class="string">"Whiskers"</span>, Owner = charlotte &#125;;</span><br><span class="line"><span class="keyword">var</span> bluemoon = <span class="keyword">new</span> Cat &#123; Name = <span class="string">"Blue Moon"</span>, Owner = rui &#125;;</span><br><span class="line"><span class="keyword">var</span> daisy = <span class="keyword">new</span> Cat &#123; Name = <span class="string">"Daisy"</span>, Owner = magnus &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fourwheeldrive = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Four Wheel Drive"</span>, Owner = phyllis &#125;;</span><br><span class="line"><span class="keyword">var</span> duke = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Duke"</span>, Owner = magnus &#125;;</span><br><span class="line"><span class="keyword">var</span> denim = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Denim"</span>, Owner = terry &#125;;</span><br><span class="line"><span class="keyword">var</span> wiley = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Wiley"</span>, Owner = charlotte &#125;;</span><br><span class="line"><span class="keyword">var</span> snoopy = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Snoopy"</span>, Owner = rui &#125;;</span><br><span class="line"><span class="keyword">var</span> snickers = <span class="keyword">new</span> Dog &#123; Name = <span class="string">"Snickers"</span>, Owner = arlene &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create three lists.</span></span><br><span class="line"><span class="keyword">var</span> people =</span><br><span class="line">    <span class="keyword">new</span> List&lt;Person&gt; &#123; magnus, terry, charlotte, arlene, rui, phyllis &#125;;</span><br><span class="line"><span class="keyword">var</span> cats =</span><br><span class="line">    <span class="keyword">new</span> List&lt;Cat&gt; &#123; barley, boots, whiskers, bluemoon, daisy &#125;;</span><br><span class="line"><span class="keyword">var</span> dogs =</span><br><span class="line">    <span class="keyword">new</span> List&lt;Dog&gt; &#123; fourwheeldrive, duke, denim, wiley, snoopy, snickers &#125;;</span><br></pre></td></tr></table></figure>
<p>现在，我们尝试获取如下的拼接信息，来看看这个拼接模式得到的是什么吧：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> person <span class="keyword">in</span> people</span><br><span class="line">                <span class="keyword">join</span> cat <span class="keyword">in</span> cats <span class="keyword">on</span> person <span class="keyword">equals</span> cat.Owner</span><br><span class="line">                <span class="keyword">join</span> dog <span class="keyword">in</span> dogs</span><br><span class="line">                    <span class="keyword">on</span> <span class="keyword">new</span> &#123; Owner = person, Letter = cat.Name[<span class="number">0</span>] &#125;</span><br><span class="line">                    <span class="keyword">equals</span> <span class="keyword">new</span> &#123; dog.Owner, Letter = dog.Name[<span class="number">0</span>] &#125;</span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">new</span> &#123; CatName = cat.Name, DogName = dog.Name &#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子是比较难理解的。首先，它先把 <code>people</code> 表和 <code>cat</code> 表拼接起来（笛卡尔积），拼接条件是 <code>person</code> 和 <code>cat.Owner</code> 一样。这说明拼接出来的结果一定就是猫咪们和它们主人的匹配表了。接下来，再把这个匹配表再次和狗狗表 <code>dogs</code> 拼接起来。这一次，拼接条件是狗狗的主人要一致，而且狗狗和猫咪的首字母要一样。最终，我们再使用 <code>select</code> 从句，把狗狗和猫咪的名字选起来。</p>
<p>我们尝试调用上述筛选结果：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> info <span class="keyword">in</span> selection)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine( </span><br><span class="line">        <span class="string">$"The cat \"<span class="subst">&#123;info.CatName&#125;</span>\" shares a house,"</span> +</span><br><span class="line">        <span class="string">" and the first letter of their name, with \"&#123;info.DogName&#125;\"."</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样将会出现两个结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The cat &quot;Daisy&quot; shares a house, and the first letter of their name, with &quot;Duke&quot;.</span><br><span class="line">The cat &quot;Whiskers&quot; shares a house, and the first letter of their name, with &quot;Wiley&quot;.</span><br></pre></td></tr></table></figure>
<p>可以发现，它们比较出来的结果显然是符合预期的。</p>
<p>偏偏最难的这个实例，我要让你来思考，这个查询表达式的 LINQ 方法链写法到底是如何的。</p>
<p>提示一下，如下图所示。</p>
<p><img src="Multiple-join.png" alt=""></p>
<h3 id="分组连接"><a href="#分组连接" class="headerlink" title="分组连接"></a>分组连接</h3><p>如果我们依旧使用原本的例子（不区分猫咪和狗狗的例子），而要实现分组连接，即把每一个主人分组显示出它的所有宠物信息表，那么怎么做到呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> person <span class="keyword">in</span> people</span><br><span class="line">                <span class="keyword">join</span> pet <span class="keyword">in</span> pets <span class="keyword">on</span> person <span class="keyword">equals</span> pet.Owner <span class="keyword">into</span> gj</span><br><span class="line">                <span class="keyword">from</span> subpet <span class="keyword">in</span> gj</span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">new</span> &#123; OwnerName = person.FirstName, PetName = subpet.Name &#125;;</span><br></pre></td></tr></table></figure>
<p>看下这个代码。我们依旧从 <code>join</code> 从句入手，把每一个宠物的信息和主人匹配上。接着，我们在 <code>join</code> 从句最后添加 <code>into</code> 从句，为其添加分组的成员表。什么是分组的成员表呢？这里指的是主人表右侧拼接的宠物信息。所以这里的 <code>gj</code> 变量，是一个宠物列表 <code>IEnumerable&lt;Pet&gt;</code>。</p>
<p>接着，我们尝试遍历该列表，然后取出主人信息，以及 <code>gj</code> 的每一个信息。这样你就会发现，它的执行结果居然是正确的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Magnus - Daisy</span><br><span class="line">Terry - Barley</span><br><span class="line">Terry - Boots</span><br><span class="line">Terry - Blue Moon</span><br><span class="line">Charlotte - Whiskers</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但遗憾的是，Visual Studio 2019 的 IDE 好像不是很会识别类型的样子。把鼠标放到 <code>into</code> 从句后的 <code>gj</code> 变量上，它会识别不出类型（而是显示的是“<code>(范围变量) ? gj</code>”，本应该显示的是“<code>(范围变量) IEnumerable&lt;Pet&gt; gj</code>”）。不过，这仅仅是一个显示 bug，因为后面的语句可以正常执行，并且在后面使用该变量的时候，这个类型可以被显示出来。这个 bug 目前（版本 15.3.9）尚未得到修复。</p>
</blockquote>
<p>而实际上，它的写法和不进行分组连接的效果是一样的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> person <span class="keyword">in</span> people</span><br><span class="line">                <span class="keyword">join</span> pet <span class="keyword">in</span> pets <span class="keyword">on</span> person <span class="keyword">equals</span> pet.Owner</span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">new</span> &#123; OwnerName = person.FirstName, PetName = pet.Name &#125;;</span><br></pre></td></tr></table></figure>
<p>这样执行的结果完全是一样的。</p>
<p>那么，请你思考一下，为什么这么写是完全没有问题的，以及它的方法链写法。</p>
<p>不过，分组连接比较复杂，它的方法链是这样的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = people.GroupJoin(</span><br><span class="line">    pets,</span><br><span class="line">    person =&gt; person,</span><br><span class="line">    pet =&gt; pet.Owner,</span><br><span class="line">    (person, pets) =&gt; <span class="keyword">new</span> &#123; OwnerName = person.FirstName, Pets = pets &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以发现，这里的结果返回和前文给出的模式还有一点不一样。它最终提取出来的是一对多的模型（一个人对多个宠物），而在 LINQ 查询表达式里，最终取出来的是一对一的模型（一个人对一个宠物的所有情况）。虽说写法不同，但结果被完整展开后，它们其实是一样的。</p>
</blockquote>
<p>而调用该结果，需要两层 <code>foreach</code> 循环：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> info <span class="keyword">in</span> selection)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"OwnerName: &#123;info.OwnerName&#125;"</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> pet <span class="keyword">in</span> info.Pets)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"    <span class="subst">&#123;pet.Name&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，就会发现，这个写法为什么叫做分组交换，就显得很清晰明了了。</p>
<p>接着，我们来另外看一种 <code>GroupJoin</code> 方法执行的写法。在 LINQ 里，<code>GroupJoin</code> 方法包含两个重载：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Summary:</span></span><br><span class="line"><span class="comment">//     Correlates the elements of two sequences based on equality of keys and groups</span></span><br><span class="line"><span class="comment">//     the results. The default equality comparer is used to compare keys.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Parameters:</span></span><br><span class="line"><span class="comment">//   outer:</span></span><br><span class="line"><span class="comment">//     The first sequence to join.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   inner:</span></span><br><span class="line"><span class="comment">//     The sequence to join to the first sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   outerKeySelector:</span></span><br><span class="line"><span class="comment">//     A function to extract the join key from each element of the first sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   innerKeySelector:</span></span><br><span class="line"><span class="comment">//     A function to extract the join key from each element of the second sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   resultSelector:</span></span><br><span class="line"><span class="comment">//     A function to create a result element from an element from the first sequence</span></span><br><span class="line"><span class="comment">//     and a collection of matching elements from the second sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Type parameters:</span></span><br><span class="line"><span class="comment">//   TOuter:</span></span><br><span class="line"><span class="comment">//     The type of the elements of the first sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   TInner:</span></span><br><span class="line"><span class="comment">//     The type of the elements of the second sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   TKey:</span></span><br><span class="line"><span class="comment">//     The type of the keys returned by the key selector functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   TResult:</span></span><br><span class="line"><span class="comment">//     The type of the result elements.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//     An System.Collections.Generic.IEnumerable`1 that contains elements of</span></span><br><span class="line"><span class="comment">//     type TResult that are obtained by performing a grouped join on two sequences.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Exceptions:</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentNullException:</span></span><br><span class="line"><span class="comment">//     outer or inner or outerKeySelector or innerKeySelector or resultSelector</span></span><br><span class="line"><span class="comment">//     is null.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(</span><br><span class="line">    <span class="keyword">this</span> IEnumerable&lt;TOuter&gt; outer,</span><br><span class="line">    IEnumerable&lt;TInner&gt; inner,</span><br><span class="line">    Func&lt;TOuter, TKey&gt; outerKeySelector,</span><br><span class="line">    Func&lt;TInner, TKey&gt; innerKeySelector,</span><br><span class="line">    Func&lt;TOuter, IEnumerable&lt;TInner&gt;, TResult&gt; resultSelector</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Summary:</span></span><br><span class="line"><span class="comment">//     Correlates the elements of two sequences based on key equality and groups the</span></span><br><span class="line"><span class="comment">//     results. A specified System.Collections.Generic.IEqualityComparer`1 is used to</span></span><br><span class="line"><span class="comment">//     compare keys.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Parameters:</span></span><br><span class="line"><span class="comment">//   outer:</span></span><br><span class="line"><span class="comment">//     The first sequence to join.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   inner:</span></span><br><span class="line"><span class="comment">//     The sequence to join to the first sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   outerKeySelector:</span></span><br><span class="line"><span class="comment">//     A function to extract the join key from each element of the first sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   innerKeySelector:</span></span><br><span class="line"><span class="comment">//     A function to extract the join key from each element of the second sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   resultSelector:</span></span><br><span class="line"><span class="comment">//     A function to create a result element from an element from the first sequence</span></span><br><span class="line"><span class="comment">//     and a collection of matching elements from the second sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   comparer:</span></span><br><span class="line"><span class="comment">//     An System.Collections.Generic.IEqualityComparer`1 to hash and compare keys.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Type parameters:</span></span><br><span class="line"><span class="comment">//   TOuter:</span></span><br><span class="line"><span class="comment">//     The type of the elements of the first sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   TInner:</span></span><br><span class="line"><span class="comment">//     The type of the elements of the second sequence.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   TKey:</span></span><br><span class="line"><span class="comment">//     The type of the keys returned by the key selector functions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   TResult:</span></span><br><span class="line"><span class="comment">//     The type of the result elements.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//     An System.Collections.Generic.IEnumerable`1 that contains elements of</span></span><br><span class="line"><span class="comment">//     type TResult that are obtained by performing a grouped join on two sequences.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Exceptions:</span></span><br><span class="line"><span class="comment">//   T:System.ArgumentNullException:</span></span><br><span class="line"><span class="comment">//     outer or inner or outerKeySelector or innerKeySelector or resultSelector</span></span><br><span class="line"><span class="comment">//     is null.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(</span><br><span class="line">    <span class="keyword">this</span> IEnumerable&lt;TOuter&gt; outer,</span><br><span class="line">    IEnumerable&lt;TInner&gt; inner,</span><br><span class="line">    Func&lt;TOuter, TKey&gt; outerKeySelector,</span><br><span class="line">    Func&lt;TInner, TKey&gt; innerKeySelector,</span><br><span class="line">    Func&lt;TOuter, IEnumerable&lt;TInner&gt;, TResult&gt; resultSelector,</span><br><span class="line">    IEqualityComparer&lt;TKey&gt; comparer</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可以从元数据里看到，它的注释文字都非常多，你先慢慢看着。</p>
<p>实际上我们可以看到，第一个重载和第二个重载完全不同的地方就只有一处：第二个重载方法的参数里多了一个 <code>IEqualityComparer&lt;TKey&gt; comparer</code>。这个对象旨在用于自定义两个键值类型 <code>TKey</code> 的对象的相等性比较器。显然，这个参数在一般情况下都用不到，因为大多类型，只要自己实现了 <code>IEquatable&lt;TKey&gt;</code> 后，这个参数便可不用手动传递进去。</p>
<h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><p>接下来我们来提一下<strong>内连接</strong>（Inner Join）和<strong>外连接</strong>（Outer Join）。内连接在前文其实说到过，但没有细谈，因为内连接本身不属于今天要讲的内容，而是前置内容，需要你提前就清楚的东西，所以默认就在你明白了这一点，然后开讲。现在需要提到左外连接的时候，不得不需要说明清楚，所以这里提一下。</p>
<p>在关系数据库术语中，内部联接会生成一个结果集，在该结果集中，第一个集合的每个元素对于第二个集合中的每个匹配元素都会出现一次。 如果第一个集合中的元素没有匹配元素，则它不会出现在结果集中。由 C# 中的 <code>join</code> 从句或调用 <code>Join</code> 方法就可以实现内部联接。所以可以发现，前文给出的例子全部都是内连接，它们执行的行为和操作就是在查询所有满足要求的键值对，而没有出现的，确实没有在结果集合里出现。那么接下来，我们开始考虑外连接。</p>
<p>而外连接，则是返回一个大表，哪怕没有出现，这里的字段也应当置为 <code>null</code>（注意，此时的 <code>null</code> 的意义并非是指向不确定或指向默认位置的一个引用字面量，而是表示类似于数据库里存储的 <code>null</code> 值的意义——此时不存在或不清楚要填入什么值）。可以从此处看出，外连接可以分两种，<strong>左外连接</strong>（Left Outer Join）和<strong>右外连接</strong>（Right Outer Join），即分别表示返回左侧拼接结果，和返回右侧拼接结果。如图所示。</p>
<p>从 LINQ 语法角度来看，我们一般都是往后添加数据，所以我们很好实现左外连接，LINQ 为我们提供了一个很好用的 <code>DefaultIfEmpty</code> 方法，来表示我们拼接时如果数据为空时，就返回该类型默认值的方法，以轻松实现左外连接。</p>
<p>我们照旧使用宠物和主人的实例给大家演示，如何实现左外连接。</p>
<p>如果我们想要完整地把表格显示出来，哪怕有人没有养宠物（宠物信息为 <code>null</code> 作为默认值）：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> person <span class="keyword">in</span> people</span><br><span class="line">                <span class="keyword">join</span> pet <span class="keyword">in</span> pets <span class="keyword">on</span> person <span class="keyword">equals</span> pet.Owner <span class="keyword">into</span> gj</span><br><span class="line">                <span class="keyword">from</span> subpet <span class="keyword">in</span> gj.DefaultIfEmpty()</span><br><span class="line">                <span class="keyword">select</span> <span class="keyword">new</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Name    = person.FirstName,</span><br><span class="line">                    PetName = subpet?.Name ?? <span class="keyword">string</span>.Empty</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> info <span class="keyword">in</span> selection)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// "-15" means left-aligning (pad right to 15-character width).</span></span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;info.FirstName + <span class="string">":"</span>,<span class="number">-15</span>&#125;</span><span class="subst">&#123;info.PetName&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后请注意最后返回的匿名类型里的 <code>PetName</code> 属性，以及执行内连接后进行分组连接操作得到的 <code>gj</code> 变量（宠物表）。这个属性给出的值是这样的：如果尝试遍历出来的每一个宠物 <code>subpet</code>，它为 <code>null</code> 值的话，将无法调用 <code>Name</code> 属性（因为 <code>subpet</code> 是一个引用类型，我们需要先判断它是否为 <code>null</code>，如果不为 <code>null</code>，才能使用 <code>Name</code> 属性来获取宠物自己的名字）。当 <code>subpet</code> 确定为 <code>null</code> 时，我们将返回一个默认显示结果：<code>string.Empty</code>，即 0 长度的字符串 <code>&quot;&quot;</code>。</p>
<p>然后，我们得到的 <code>selection</code> 便是这个匿名类型构建起来的一个列表集合。然后我们对每一个匿名类型进行遍历，输出它们的信息。注意，此时的 <code>info.PetName</code> 属性可能显示的是空字符串，所以没有输出任何可以看见的字符信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;----- 15 ----&gt;|</span><br><span class="line">Magnus:        Daisy</span><br><span class="line">Terry:         Barley</span><br><span class="line">Terry:         Boots</span><br><span class="line">Terry:         Blue Moon</span><br><span class="line">Charlotte:     Whiskers</span><br><span class="line">Arlene:</span><br></pre></td></tr></table></figure>
<p>可以看到，左外连接的使用其实并不困难，但需要显示整个表，就需要你额外调用一些方法，例如 <code>DefaultIfEmpty</code>，和使用一些操作来灵活处理它们。</p>
<h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p>很抱歉的是，右外连接在 LINQ 里来举例并不是很合适。由于语法的制约，我们一般都在表格后添加一个表，然后进行拼接操作（或设计筛选条件拼接，比如上述的等值连接 <code>join-in-on-equals</code> 从句序列）。但 LINQ 从实现起来，如果需要达到右外连接的话，就相当于它的左侧添加一张表，但这显然是不好做到的，因为我们调用方法的顺序是顺次调用的（即方法链只能往下写代码），所以我们并不好做到右外连接的操作。</p>
<p>不过，如果你要实现它，也不是不可以。不过，你就得单独创建新表，然后在新的表上执行左外连接来达到同样的目的了。不过这样的操作还不如写成左外连接，所以我们不建议你在 LINQ 里使用右外连接。</p>
<h3 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h3><p>最后，作为收尾的内容，我们再来讲解两个不是前面连接模式的其它连接方式，这些模式我们都可以称为<strong>自定义连接</strong>（Custom Join），这里介绍 1 种常见的自定义连接<strong>非等值连接</strong>（Nonequijoin）。</p>
<p>在前文的介绍里，我们解释了如何使用 <code>join</code> 从句（或是 <code>Join</code> 和 <code>GroupJoin</code> 方法）来达到我们大多时候可以做到的连接操作。这些时候，我们一般都使用到的是<strong>自然连接</strong>（也叫<strong>等值连接</strong>，Equijoin），可以从查询表达式里看到，这种写法直接引入了关键字 <code>equals</code>，可见 C# 的设计师们认为，等值连接是多么广泛的存在。</p>
<p>但在极少数情况下，我们依旧会使用非等值连接，即拼接两个表的条件并不是相等时才拼接，而是比较结果后拼接，比如左侧比右侧的结果大的时候，拼接两个表。这种拼接模式确实很难理解，但极少数情况下是存在的。由于 C# 语法设计师们认为，这种拼接模式比较少用，所以 <code>join</code> 从句就完全没有考虑到这一点的实现，于是从官网的原文上得到的信息是：</p>
<blockquote>
<p>在查询表达式中，<code>join</code> 子句只限于同等联接（并针对其进行优化），这类联接到目前为止是最常见的联接操作类型。执行同等联接时，可能会始终使用 <code>join</code> 子句获得最佳性能。 </p>
<p>但是，在以下情况下不能使用 <code>join</code> 子句：</p>
<ul>
<li>当联接依据不等式表达式时（非同等联接）。</li>
<li>当联接依据多个等式或不等式表达式时。</li>
<li>当必须为联接操作前的右侧（内部）序列引入临时范围变量。</li>
</ul>
<p>若要执行不是同等联接的联接，可以使用多个 <code>from</code> 子句独立引入每个数据源。 随后可在 <code>where</code> 子句中将谓词表达式应用于每个源的范围变量。 表达式还可以采用方法调用的形式。</p>
</blockquote>
<p>可见，这种连接模式有多么少见了。下面我们将给出该官网页面的两则实例，来给大家介绍非等值连接的用法和写法。</p>
<p>由于前文的宠物和主人实例对于这里的讲解有些困难，所以下面考虑一个新的实例，这个实例将贯穿下面的两种连接模型。</p>
<p>假如，我们在开一个杂货铺，给出两个类：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> CategoryID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Category</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个类分别表示商品 <code>Product</code> 和商品的分类 <code>Category</code>。现在我们给出一系列的数据信息：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> categories = <span class="keyword">new</span> List&lt;Category&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> Category() &#123; Name = <span class="string">"Beverages"</span>, ID = <span class="number">001</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Category() &#123; Name = <span class="string">"Condiments"</span>, ID = <span class="number">002</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Category() &#123; Name = <span class="string">"Vegetables"</span>, ID = <span class="number">003</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> products = <span class="keyword">new</span> List&lt;Product&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Tea"</span>, CategoryID = <span class="number">001</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Mustard"</span>, CategoryID = <span class="number">002</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Pickles"</span>, CategoryID = <span class="number">002</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Carrots"</span>, CategoryID = <span class="number">003</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Bok Choy"</span>, CategoryID = <span class="number">003</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Peaches"</span>, CategoryID = <span class="number">005</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Melons"</span>, CategoryID = <span class="number">005</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Ice Cream"</span>, CategoryID = <span class="number">007</span> &#125;,</span><br><span class="line">    <span class="keyword">new</span> Product &#123; Name = <span class="string">"Mackerel"</span>, CategoryID = <span class="number">012</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>给出一些产品，以及产品的类型。下面我们来试着实现利用非等值连接。假如，我要取出两个表的笛卡尔积，那么很简单，写两层 <code>from</code> 从句即可。但我现在要取出商品的分类是存在于分类表里的所有商品，这怎么做呢？</p>
<p>实际上，这并不困难。我们只要两层遍历，并设计 <code>where</code> 从句即可：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nonEquijoinQuery = <span class="keyword">from</span> p <span class="keyword">in</span> products</span><br><span class="line">                       <span class="keyword">let</span> catIds = <span class="keyword">from</span> c <span class="keyword">in</span> categories <span class="keyword">select</span> c.ID</span><br><span class="line">                       <span class="keyword">where</span> catIds.Contains(p.CategoryID)</span><br><span class="line">                       <span class="keyword">select</span> <span class="keyword">new</span> &#123; Product = p.Name, p.CategoryID &#125;;</span><br></pre></td></tr></table></figure>
<p>只要在分类表里遍历一下，然后取出每一个 ID 值，然后去看商品表的每一个元素，是否包含这些 ID 即可。如果包含，就选出来；如果没有就跳过。所以代码就是上面这样写的。</p>
<p>当然，调用起来也很简单：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"Non-equijoin query:"</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> v <span class="keyword">in</span> nonEquijoinQuery)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;v.CategoryID,<span class="number">-5</span>&#125;</span><span class="subst">&#123;v.Product&#125;</span>"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以得到结果集合了。</p>
<blockquote>
<p>当然，在文档上不小心把内插字符串的 <code>,</code> 写作了 <code>:</code>，这里已经作出了改正。</p>
</blockquote>
<p>至此，我们就把 <code>join</code> 的大致拼接类型全部都讲了一遍，不知道你是否都理解和消化了呢？</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/from-clause#compound-from-clauses" target="_blank" rel="noopener">复合 from 子句</a>（为笛卡尔积一节提供资料）</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/join-clause" target="_blank" rel="noopener">join 子句</a>（为 <code>join</code> 从句简单介绍一节提供资料）</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/linq/perform-left-outer-joins" target="_blank" rel="noopener">执行左外部连接</a>（为左外连接一节提供资料）</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/linq/perform-custom-join-operations" target="_blank" rel="noopener">执行自定义连接操作</a>（为非等值连接一节提供资料）</li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.defaultifempty?view=netframework-4.8" target="_blank" rel="noopener">Enumerable.DefaultIfEmpty 方法（英文文档）</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.groupjoin?view=netframework-4.8" target="_blank" rel="noopener">Enumerable.GroupJoin 方法（英文文档）</a></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/">C♯.LINQ</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/C%E2%99%AF-LINQ-%E6%95%99%E7%A8%8B/">C♯.LINQ.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/LINQ/">LINQ</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/13/linq-04-group-by-clause/" title="LINQ 教程（4）：group-by 从句" itemprop="url">LINQ 教程（4）：group-by 从句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-13T10:47:55.000Z" itemprop="datePublished"> 发表于 2019-11-13</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="group-by-从句"><a href="#group-by-从句" class="headerlink" title="group-by 从句"></a><code>group-by</code> 从句</h2><p>今天我们来看一个类似于 <code>orderby</code> 但写法不太一样、并且执行原理也不太一样的从句类型：<code>group-by</code> 从句。它的用法有一点麻烦，写法倒是很简单，但使用起来不如前文用的结果那样，一层 <code>foreach</code> 就可以遍历，而需要两层。</p>
<p>比如，我们尝试拿出之前的关键词实例给大家举例。假设我们今天要把所有的关键字，按第一个字符分组显示，那么显示模式是如何的呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Uses group-by clause.</span></span><br><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> word <span class="keyword">in</span> words</span><br><span class="line">                <span class="keyword">group</span> word <span class="keyword">by</span> word[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uses `selection` to get all different groups.</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> wordGroup <span class="keyword">in</span> selection)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Output the grouping basis.</span></span><br><span class="line">    Console.WriteLine(<span class="string">$"<span class="subst">&#123;wordGroup.Key&#125;</span>:"</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> word <span class="keyword">in</span> wordGroup)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// All words in the same group.</span></span><br><span class="line">        Console.WriteLine(<span class="string">$"    <span class="subst">&#123;word&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看上面的使用 <code>group-by</code> 从句的方法：使用 <code>group</code> 和 <code>by</code> 关键字，把需要排序的成员写在之间，然后在 <code>by</code> 后写上排序的依据（按首字母排序，当然，有些单词含有符号，比如以 <code>#</code> 和 <code>!</code> 开头的关键字）。</p>
<p>然后在使用的时候，需要两层循环，在外层写上的是按字母分组的那个一组元素，然后在内层，在继续执行循环，遍历这一组元素的每一个关键字。然后我们尝试使用 <code>wordGroup.Key</code> 属性来获取这一组元素的排序依据的值。比如按第一个字符把所有关键字分组的话，自然每一组的分组依据的值就是 <code>a</code>、<code>b</code>、<code>c</code>、……、<code>*</code>、<code>#</code> 这些了。</p>
<blockquote>
<p>注意，它和 <code>orderby</code> 从句的写法不同的是，它的 <code>by</code> 是被拆分出来的，而不像是 <code>order</code> 和 <code>by</code>，没有拆分开来，是一个整体；而且，<code>group-by</code> 从句后不要再写 <code>select</code> 从句了，即 <code>group-by</code> 从句应作为整个 LINQ 查询表达式的结尾。</p>
</blockquote>
<p>用起来其实也不算比较难的地方，但掌握它的调用模式和原理是非常难的。前面我们说到了这个使用方式，而下面我们就来说一下它的原理，和它的方法链写法。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="IGrouping-lt-TKey-TElement-gt-接口"><a href="#IGrouping-lt-TKey-TElement-gt-接口" class="headerlink" title="IGrouping&lt;TKey, TElement&gt; 接口"></a><code>IGrouping&lt;TKey, TElement&gt;</code> 接口</h3><p>接下来我们来说一个接口：<code>IGrouping&lt;TKey, TElement&gt;</code> 接口。这个接口是什么呢？这个接口就是上文提到的 <code>group-by</code> 从句使用后得到的这个返回的元素类型，即</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> word <span class="keyword">in</span> words</span><br><span class="line">                <span class="keyword">group</span> word <span class="keyword">by</span> word[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>这个语句的返回值就是 <code>IEnumerable&lt;IGrouping&lt;char, string&gt;&gt;</code> 接口类型（即 <code>var</code> 关键字代替的就是这个类型）。其中的第一个泛型参数 <code>char</code> 表示分组依据的类型，而第二个泛型参数 <code>string</code> 表示这个分组里的元素的元素类型。由此可见，这个类型是一个一对多的模型。当我们查看这个接口的实现代码的时候，就可以发现，它里面提供了轻松的 <code>Key</code> 属性来获取分组依据，而且它直接实现了 <code>IEnumerable&lt;TElement&gt;</code> 接口，这样我们就可以轻松使用 <code>foreach</code> 循环来获取每一个元素了。</p>
<p>现在我们来进行解惑。为啥这个返回值这么复杂。<code>IEnumerable&lt;IGrouping&lt;char, string&gt;&gt;</code> 初学起来肯定会觉得很不好理解。现在我们来看，为什么这个 <code>group-by</code> 从句使用过后，返回值的类型会长成这样奇怪。</p>
<p>首先，发明 <code>IGrouping&lt;TKey, TElement&gt;&gt;</code> 接口，目的非常简单，就是为了推迟执行。还记得前文提到的推迟执行吗？推迟执行便是让执行推后到 <code>foreach</code> 调用的时候才会使用的一种执行机制。这里发明这个接口，为的就是让程序在调用 <code>foreach</code> 遍历的时候，这个接口的成员才会被全部迭代出来，这是这个接口存在的第一个意义。</p>
<p>第二个意义是，这个接口类型如果我们不发明出来的话，那么这里的 <code>group-by</code> 从句执行的结果应该用什么表示呢？显然，既然是分组的模式，必然需要一个可以表示分组意义的类型来表示，于是微软 C# 语言设计师就想到了，使用一个一对多的模型，来表示这个构型。然后，外层这个 <code>IEnumerable&lt;T&gt;</code> 表示的是这个外层循环迭代出来的每一个组，而内层的元素类型，就是这个所谓的 <code>IGrouping&lt;TKey, TElement&gt;</code> 了，这样就变得非常清晰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                                               ↓ IEnumerable&lt;IGrouping&lt;char, string&gt;&gt;</span><br><span class="line">foreach (IGrouping&lt;char, string&gt; group in everyGroups)</span><br><span class="line">&#123;</span><br><span class="line">                              ↓ IGrouping&lt;char, string&gt;</span><br><span class="line">    foreach (string word in group)</span><br><span class="line">    &#123;</span><br><span class="line">        // Use them...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，这个设计模式是非常正确的。</p>
<h3 id="方法链写法"><a href="#方法链写法" class="headerlink" title="方法链写法"></a>方法链写法</h3><p>下面我们来看看这个关键字的实现原理：方法链写法。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = words.GroupBy(word =&gt; word[<span class="number">0</span>]);</span><br><span class="line">                     .Select(word =&gt; word);</span><br></pre></td></tr></table></figure>
<p>可以看到，这个方法的调用非常简单：LINQ 提供了一个非常好用的 <code>GroupBy</code> 方法，只要我们依葫芦画瓢，照着 <code>OrderBy</code> 的调用方式书写这里的 Lambda 表达式即可。请注意，这里调用 <code>GroupBy</code> 方法一定是生成好的 <code>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</code> 类型了，所以你完全不需要多此一举在后面加上 <code>Select</code> 方法不然就相当于多做了一次完全没有意义的工作。</p>
<h3 id="愉快地看下输出结果吧！"><a href="#愉快地看下输出结果吧！" class="headerlink" title="愉快地看下输出结果吧！"></a>愉快地看下输出结果吧！</h3><p>下面我们来看看，上述调用的输出结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">a:</span><br><span class="line">    abstract</span><br><span class="line">    as</span><br><span class="line"></span><br><span class="line">b:</span><br><span class="line">    base</span><br><span class="line">    bool</span><br><span class="line">    break</span><br><span class="line">    byte</span><br><span class="line"></span><br><span class="line">c:</span><br><span class="line">    case</span><br><span class="line">    catch</span><br><span class="line">    char</span><br><span class="line">    checked</span><br><span class="line">    class</span><br><span class="line">    const</span><br><span class="line">    continue</span><br><span class="line"></span><br><span class="line">d:</span><br><span class="line">    decimal</span><br><span class="line">    default</span><br><span class="line">    delegate</span><br><span class="line">    do</span><br><span class="line">    double</span><br><span class="line"></span><br><span class="line">e:</span><br><span class="line">    else</span><br><span class="line">    enum</span><br><span class="line">    event</span><br><span class="line">    explicit</span><br><span class="line">    extern</span><br><span class="line"></span><br><span class="line">f:</span><br><span class="line">    false</span><br><span class="line">    finally</span><br><span class="line">    fixed</span><br><span class="line">    float</span><br><span class="line">    for</span><br><span class="line">    foreach</span><br><span class="line"></span><br><span class="line">g:</span><br><span class="line">    goto</span><br><span class="line"></span><br><span class="line">i:</span><br><span class="line">    if</span><br><span class="line">    implicit</span><br><span class="line">    in (foreach)</span><br><span class="line">    int</span><br><span class="line">    interface</span><br><span class="line">    internal</span><br><span class="line">    is</span><br><span class="line"></span><br><span class="line">l:</span><br><span class="line">    lock</span><br><span class="line">    long</span><br><span class="line"></span><br><span class="line">n:</span><br><span class="line">    namespace</span><br><span class="line">    new</span><br><span class="line">    null</span><br><span class="line"></span><br><span class="line">o:</span><br><span class="line">    object</span><br><span class="line">    operator</span><br><span class="line">    out (generic modifier)</span><br><span class="line">    out (parameter)</span><br><span class="line">    override</span><br><span class="line"></span><br><span class="line">p:</span><br><span class="line">    params</span><br><span class="line">    private</span><br><span class="line">    protected</span><br><span class="line">    public</span><br><span class="line"></span><br><span class="line">r:</span><br><span class="line">    readonly</span><br><span class="line">    ref</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">    sbyte</span><br><span class="line">    sealed</span><br><span class="line">    short</span><br><span class="line">    sizeof</span><br><span class="line">    stackalloc</span><br><span class="line">    static</span><br><span class="line">    string</span><br><span class="line">    struct</span><br><span class="line">    switch</span><br><span class="line"></span><br><span class="line">t:</span><br><span class="line">    this</span><br><span class="line">    throw</span><br><span class="line">    true</span><br><span class="line">    try</span><br><span class="line">    typeof</span><br><span class="line"></span><br><span class="line">u:</span><br><span class="line">    uint</span><br><span class="line">    ulong</span><br><span class="line">    unchecked</span><br><span class="line">    unsafe</span><br><span class="line">    ushort</span><br><span class="line">    using</span><br><span class="line"></span><br><span class="line">v:</span><br><span class="line">    virtual</span><br><span class="line">    void</span><br><span class="line">    volatile</span><br><span class="line"></span><br><span class="line">w:</span><br><span class="line">    while</span><br><span class="line"></span><br><span class="line">*:</span><br><span class="line">    *add</span><br><span class="line">    *alias</span><br><span class="line">    *ascending</span><br><span class="line">    *async</span><br><span class="line">    *await</span><br><span class="line">    *by</span><br><span class="line">    *descending</span><br><span class="line">    *dynamic</span><br><span class="line">    *equals</span><br><span class="line">    *from</span><br><span class="line">    *get</span><br><span class="line">    *global</span><br><span class="line">    *group</span><br><span class="line">    *in (generic modifier)</span><br><span class="line">    *in (parameter)</span><br><span class="line">    *in (query)</span><br><span class="line">    *into</span><br><span class="line">    *join</span><br><span class="line">    *let</span><br><span class="line">    *nameof</span><br><span class="line">    *notnull</span><br><span class="line">    *on</span><br><span class="line">    *orderby</span><br><span class="line">    *partial (method)</span><br><span class="line">    *partial (type)</span><br><span class="line">    *remove</span><br><span class="line">    *select</span><br><span class="line">    *set</span><br><span class="line">    *switch (expression)</span><br><span class="line">    *unmanaged</span><br><span class="line">    *using static</span><br><span class="line">    *value</span><br><span class="line">    *var</span><br><span class="line">    *when</span><br><span class="line">    *where (generic constraint)</span><br><span class="line">    *where (query)</span><br><span class="line">    *yield</span><br><span class="line"></span><br><span class="line">#:</span><br><span class="line">    #annotations</span><br><span class="line">    #checksum</span><br><span class="line">    #disable</span><br><span class="line">    #enable</span><br><span class="line">    #nullable</span><br><span class="line">    #restore</span><br><span class="line">    #warning</span><br><span class="line">    #warnings</span><br><span class="line"></span><br><span class="line">!:</span><br><span class="line">    !#safeonly</span><br></pre></td></tr></table></figure>
<p>emmm……可能有点长。</p>
<h2 id="group-by-into-从句"><a href="#group-by-into-从句" class="headerlink" title="group-by-into 从句"></a><code>group-by-into</code> 从句</h2><p>在 <code>group-by</code> 从句里，LINQ 还提供了一个辅助语句：<code>into</code> 从句。<code>into</code> 从句作为临时存储的方式而存在，把 <code>into</code> 后写上自己取的临时名，那么前面取出来的这些数据就都会存到这个变量里，留着后面用。如果写了 <code>into</code> 从句，那么查询表达式就可以继续写下去了。</p>
<p>举个例子。我们觉得上文太长了，我们尝试只把所有的分组依据取出来。那么接下来怎么办呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = <span class="keyword">from</span> word <span class="keyword">in</span> words</span><br><span class="line">                <span class="keyword">group</span> word <span class="keyword">by</span> word[<span class="number">0</span>] <span class="keyword">into</span> grp</span><br><span class="line">                <span class="keyword">select</span> grp.Key;</span><br></pre></td></tr></table></figure>
<p>这样的话，我们就可以尝试把每一个组都取出来，然后取出其中的 <code>Key</code> 属性了。那么此时，<code>selection</code> 变量就是 <code>IEnumerable&lt;char&gt;</code> 类型的了。方法链写法是：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selection = words.GroupBy(word =&gt; word[<span class="number">0</span>])</span><br><span class="line">                     .Select(grp =&gt; grp.Key);</span><br></pre></td></tr></table></figure>
<p>可以看到，实际上在方法链模式下，书写格式是完全允许继续往下写的，因为在 <code>GroupBy</code> 方法的层面来说，它的返回值类型虽然是 <code>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt;</code> 这么长的类型，但依旧是 <code>IEnumerable&lt;T&gt;</code> 的，所以依旧可以继续进行枚举和使用 <code>Select</code> 方法继续往下写。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/">C♯.LINQ</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-LINQ/C%E2%99%AF-LINQ-%E6%95%99%E7%A8%8B/">C♯.LINQ.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/LINQ/">LINQ</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>




  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/5/">上一页 ↑</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/">下一页 ↓</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="Sunnie-Shine" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>



  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/C♯/" title="C♯">C♯<sup>29</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>24</sup></a></li>
			
		
			
				<li><a href="/tags/LINQ/" title="LINQ">LINQ<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/位运算/" title="位运算">位运算<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/数独/" title="数独">数独<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-编译器生成/" title="C♯.编译器生成">C♯.编译器生成<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/数学/" title="数学">数学<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/SQL/" title="SQL">SQL<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-8/" title="C♯ 8">C♯ 8<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-7/" title="C♯ 7">C♯ 7<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/正则表达式/" title="正则表达式">正则表达式<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/向向的每周数独/" title="向向的每周数独">向向的每周数独<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/安卓/" title="安卓">安卓<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ASP/" title="ASP">ASP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/诗词/" title="诗词">诗词<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-3/" title="C♯ 3">C♯ 3<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-6/" title="C♯ 6">C♯ 6<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/TODO/" title="TODO">TODO<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://sunniesudoku.cn/" target="_blank" title="向向的数独文档库">向向的数独文档库</a>
            
          </li>
        
          <li>
            
            	<a href="http://tieba.baidu.com/f?kw=%CA%FD%B6%C0" target="_blank" title="数独贴吧">数独贴吧</a>
            
          </li>
        
          <li>
            
            	<a href="https://space.bilibili.com/23736703" target="_blank" title="Bilibili">Bilibili</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m Sunnie. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/Sunnie-Shine" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/Sunnie-Shine" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
	</div>
			
		

		<p class="copyright">
		Copyright © 2020 
		
		<a href="/about" target="_blank" title="向向">向向</a>
		
		<br />
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a>
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript"
  async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
