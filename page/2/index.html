
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>向向的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="向向">
    

    
    <meta name="description" content="This is my blog...">
<meta property="og:type" content="website">
<meta property="og:title" content="向向的博客">
<meta property="og:url" content="https:&#x2F;&#x2F;sunnie-shine.github.io&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="向向的博客">
<meta property="og:description" content="This is my blog...">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="向向的博客" title="向向的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="向向的博客">向向的博客</a></h1>
				<h2 class="blog-motto">Console.WriteLine(&#34;Hello, ^_^&#34;);</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">全部文档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:Sunnie-Shine.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/20/regex-learning/" title="正则表达式基础" itemprop="url">正则表达式基础</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-20T13:51:00.000Z" itemprop="datePublished"> 发表于 2019-11-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <blockquote>
<p>全文都转自正则表达式学习 repo 的<a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" target="_blank" rel="noopener">这篇文章</a>的内容。</p>
</blockquote>
<h2 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h2><blockquote>
<p><strong>正则表达式</strong>（Regular Expression）是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p>
</blockquote>
<p>一个正则表达式是一种从左到右匹配主体字符串的模式。“Regular expression”这个词比较拗口，我们常使用缩写的术语 <strong>regex</strong> 或 <strong>regexp</strong>。正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p>
<p>想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。</p>
<p>我们使用以下正则表达式来验证一个用户名：</p>
<p><img src="regexp-cn.png" alt=""></p>
<p>以上的正则表达式可以接受 <code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。 但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p>
<h2 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。例如：一个正则表达式 <code>the</code>，它表示一个规则：由字母 <code>t</code> 开始，接着是 <code>h</code>，再接着是 <code>e</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;the&quot; =&gt; The fat cat sat on [the] mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/dmRygT/1" target="_blank" rel="noopener">在线练习</a></p>
<p>正则表达式 <code>123</code> 匹配字符串 <code>123</code>。它逐个字符的与输入的正则表达式做比较。</p>
<p>正则表达式是大小写敏感的，所以 <code>The</code> 不会匹配 <code>the</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;The&quot; =&gt; [The] fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/1paXsy/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式主要依赖于元字符。元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在中括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>句号匹配任意单个字符除了换行符。</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>字符种类。匹配中括号内的任意字符。</td>
</tr>
<tr>
<td><code>[^ ]</code></td>
<td>否定的字符种类。匹配除了中括号里的任意字符。</td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配 &gt;=0 个重复的在 <code>*</code> 号之前的字符。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配 &gt;=1 个重复的 <code>+</code> 号前的字符。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>标记 <code>?</code> 之前的字符为可选。</td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td>匹配 $p$ 个大括号之间的字符（其中 $n \leq p \leq m$)。</td>
</tr>
<tr>
<td><code>(xyz)</code></td>
<td>字符集，匹配与 <code>xyz</code> 完全相等的字符串。</td>
</tr>
<tr>
<td><code>&#124;</code></td>
<td>或运算符，匹配符号前或后的字符。</td>
</tr>
<tr>
<td><code>\</code></td>
<td>转义字符，用于匹配一些保留的字符 <code>[ ] ( ) { } . * + ? ^ $ \ &#124;</code>。</td>
</tr>
<tr>
<td><code>^</code></td>
<td>从开始行开始匹配。</td>
</tr>
<tr>
<td><code>$</code></td>
<td>从末端开始匹配。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="点运算符"><a href="#点运算符" class="headerlink" title="点运算符 ."></a>点运算符 <code>.</code></h2><p><code>.</code> 是元字符中最简单的例子。<code>.</code> 匹配任意单个字符，但不匹配换行符。例如，表达式 <code>.ar</code> 匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;.ar&quot; =&gt; [The] [car] [par]ked in the [gar]age.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/xc9GkU/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>字符集也叫做字符类。中括号用来指定一个字符集。 在中括号中使用连字符来指定字符集的范围。 在中括号中的字符集不关心顺序。 例如，表达式 <code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[Tt]he&quot; =&gt; [The] car parked in [the] garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/2ITLQ4/1" target="_blank" rel="noopener">在线练习</a></p>
<p>中括号的句号就表示句号。 表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ar[.]&quot; =&gt; A garage is a good place to park a c[ar.]</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/wL3xtE/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h3><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个中括号的开头的时候，它表示这个字符集是否定的。 例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[^c]ar&quot; =&gt; The car [par]ked in the [gar]age.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/nNNlq3/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h2><p>后面跟着元字符 <code>+</code>，<code>*</code> 或 <code>?</code> 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。</p>
<h3 id="号"><a href="#号" class="headerlink" title="* 号"></a><code>*</code> 号</h3><p><code>*</code> 号匹配 在 <code>*</code> 之前的字符出现<strong>大于等于 0</strong>次。 例如，表达式 <code>a*</code> 匹配0或更多个以 <code>a</code> 开头的字符。表达式 <code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[a-z]*&quot; =&gt; T[he] [car] [parked] [in] [the] [garage] #21.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/7m8me5/1" target="_blank" rel="noopener">在线练习</a></p>
<p><code>*</code> 字符和 <code>.</code> 字符搭配可以匹配所有的字符 <code>.*</code>。<code>*</code> 和表示匹配空格的符号 <code>\s</code> 连起来用，如表达式 <code>\s*cat\s*</code> 匹配 <code>0</code> 或更多个空格开头和 <code>0</code>或更多个空格结尾的 <code>cat</code> 字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\s*cat\s*&quot; =&gt; The fat [cat] sat on the con[cat]enation.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/gGrwuz/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="号-1"><a href="#号-1" class="headerlink" title="+ 号"></a><code>+</code> 号</h3><p><code>+</code> 号匹配 <code>+</code> 号之前的字符<strong>出现 &gt;=1 次</strong>。 例如表达式 <code>c.+t</code> 匹配以首字母 <code>c</code> 开头以 <code>t</code> 结尾，中间跟着至少一个字符的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;c.+t&quot; =&gt; The fat [cat sat on the mat].</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/Dzf9Aa/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="号-2"><a href="#号-2" class="headerlink" title="? 号"></a><code>?</code> 号</h3><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即<strong>出现 0 或 1 次</strong>。 例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[T]he&quot; =&gt; [The] car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/cIg9zm/1" target="_blank" rel="noopener">在线练习</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[T]?he&quot; =&gt; [The] car is parked in t[he] garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/kPpO2x/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="号-3"><a href="#号-3" class="headerlink" title="{} 号"></a><code>{}</code> 号</h2><p>在正则表达式中 <code>{}</code> 是一个量词，常用来一个或一组字符可以重复出现的次数。例如，表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,3&#125;&quot; =&gt; The number was 9.[999]7 but we rounded it off to [10].0.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/juM86s/1" target="_blank" rel="noopener">在线练习</a></p>
<p>我们可以省略第二个参数。 例如，<code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,&#125;&quot; =&gt; The number was 9.[9997] but we rounded it off to [10].0.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/Gdy4w5/1" target="_blank" rel="noopener">在线练习</a></p>
<p>如果逗号也省略掉则表示重复固定的次数。 例如，<code>[0-9]{3}</code> 匹配3位数字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;3&#125;&quot; =&gt; The number was 9.[999]7 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/Sivu30/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="特征标群"><a href="#特征标群" class="headerlink" title="(...) 特征标群"></a><code>(...)</code> 特征标群</h2><p>特征标群是一组写在 <code>(...)</code> 中的子模式。例如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复 N 次。例如，表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。</p>
<p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(c|g|p)ar&quot; =&gt; The [car] is [par]ked in the [gar]age.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/tUxrBG/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="或运算符"><a href="#或运算符" class="headerlink" title="| 或运算符"></a><code>|</code> 或运算符</h2><p>或运算符就表示或，用作判断条件。</p>
<p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he|car&quot; =&gt; [The] [car] is parked in [the] garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/fBXyX0/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="转码特殊字符"><a href="#转码特殊字符" class="headerlink" title="转码特殊字符"></a>转码特殊字符</h2><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p>
<p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(f|c|m)at\.?&quot; =&gt; The [fat] [cat] sat on the [mat.]</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/DOc5Nu/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p>
<h3 id="号-4"><a href="#号-4" class="headerlink" title="^ 号"></a><code>^</code> 号</h3><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p>
<p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code>开头。</p>
<p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he&quot; =&gt; [The] car is parked in [the] garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/5ljjgB/1" target="_blank" rel="noopener">在线练习</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;^(T|t)he&quot; =&gt; [The] car is parked in the garage.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/jXrKne/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="号-5"><a href="#号-5" class="headerlink" title="$ 号"></a><code>$</code> 号</h3><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p>
<p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(at\.)&quot; =&gt; The fat c[at.] s[at.] on the m[at.]</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/y4Au4D/1" target="_blank" rel="noopener">在线练习</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(at\.)$&quot; =&gt; The fat cat. sat. on the m[at.]</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/t0AkOd/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h2><p>正则表达式提供一些常用的字符集简写。如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>简写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>除换行符外的所有字符。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code>。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code>。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字： <code>[0-9]</code>。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字： <code>[^\d]</code>。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p{Z}]</code>。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配所有非空格字符： <code>[^\s]</code>。</td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。</td>
</tr>
<tr>
<td>\p</td>
<td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="零宽度断言（前后预查）"><a href="#零宽度断言（前后预查）" class="headerlink" title="零宽度断言（前后预查）"></a>零宽度断言（前后预查）</h2><p>先行断言和后发断言都属于<strong>非捕获簇</strong>（不捕获文本，也不针对组合计进行计数）。先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。</p>
<p>例如，我们想要获得所有跟在 <script type="math/tex">` 符号后的数字，我们可以使用正后发断言 `(?<=\$)[0-9\.]*`。 这个表达式匹配 `</script> 开头，之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次。</p>
<p>零宽度断言如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>?=</td>
<td>正先行断言-存在</td>
</tr>
<tr>
<td>?!</td>
<td>负先行断言-排除</td>
</tr>
<tr>
<td>?&lt;=</td>
<td>正后发断言-存在</td>
</tr>
<tr>
<td>?&lt;!</td>
<td>负后发断言-排除</td>
</tr>
</tbody>
</table>
</div>
<h3 id="正先行断言"><a href="#正先行断言" class="headerlink" title="?=... 正先行断言"></a><code>?=...</code> 正先行断言</h3><p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p>
<p>返回结果只包含满足匹配条件的第一部分表达式。定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号：<code>(?=...)</code>。</p>
<p>正先行断言的内容写在括号中的等号后面。例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code>，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he(?=\sfat)&quot; =&gt; [The] fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/IDDARt/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="负先行断言"><a href="#负先行断言" class="headerlink" title="?!... 负先行断言"></a><code>?!...</code> 负先行断言</h3><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 <code>正先行断言</code> 定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p>
<p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he(?!\sfat)&quot; =&gt; The fat cat sat on [the] mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/V32Npg/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="lt-正后发断言"><a href="#lt-正后发断言" class="headerlink" title="?&lt;= ... 正后发断言"></a><code>?&lt;= ...</code> 正后发断言</h3><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(?&lt;=(T|t)he\s)(fat|mat)&quot; =&gt; The [fat] cat sat on the [mat].</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/avH165/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="负后发断言"><a href="#负后发断言" class="headerlink" title="? 负后发断言"></a><code>?</code> 负后发断言</h3><p>负后发断言 记作 <code>(?</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。例如，表达式 <code>(?</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(?&lt;!(T|t)he\s)(cat)&quot; =&gt; The cat sat on [cat].</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/8Efx5G/1" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>忽略大小写。</td>
</tr>
<tr>
<td>g</td>
<td>全局搜索。</td>
</tr>
<tr>
<td>m</td>
<td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="忽略大小写（Case-Insensitive）"><a href="#忽略大小写（Case-Insensitive）" class="headerlink" title="忽略大小写（Case Insensitive）"></a>忽略大小写（Case Insensitive）</h3><p>修饰语 <code>i</code> 用于忽略大小写。 例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;The&quot; =&gt; [The] fat cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/dpQyf9/1" target="_blank" rel="noopener">在线练习</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/The/gi&quot; =&gt; [The] fat cat sat on [the] mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/ahfiuh/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="全局搜索（Global-search）"><a href="#全局搜索（Global-search）" class="headerlink" title="全局搜索（Global search）"></a>全局搜索（Global search）</h3><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即“不仅仅返回第一个匹配的，而是返回全部”。例如，表达式 <code>/.(at)/g</code> 表示搜索 <code>除换行外的任意字符 + at</code>，并返回全部结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/.(at)/&quot; =&gt; The [fat] cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/jnk6gM/1" target="_blank" rel="noopener">在线练习</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/.(at)/g&quot; =&gt; The [fat] [cat] [sat] on the [mat].</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/dO1nef/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="多行修饰符（Multiline）"><a href="#多行修饰符（Multiline）" class="headerlink" title="多行修饰符（Multiline）"></a>多行修饰符（Multiline）</h3><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p>
<p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p>
<p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code>，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;/.at(.)?$/&quot; =&gt; The fat</span><br><span class="line">                cat sat</span><br><span class="line">                on the [mat].</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/hoGMkP/1" target="_blank" rel="noopener">在线练习</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;/.at(.)?$/gm&quot; =&gt; The [fat]</span><br><span class="line">                  cat [sat]</span><br><span class="line">                  on the [mat].</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/E88WE2/1" target="_blank" rel="noopener">在线练习</a></p>
<h3 id="贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）"><a href="#贪婪匹配与惰性匹配（Greedy-vs-lazy-matching）" class="headerlink" title="贪婪匹配与惰性匹配（Greedy vs lazy matching）"></a>贪婪匹配与惰性匹配（Greedy vs lazy matching）</h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/(.*at)/&quot; =&gt; [The fat cat sat on the mat].</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/AyAdgJ/1" target="_blank" rel="noopener">在线练习</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;/(.*?at)/&quot; =&gt; [The fat] cat sat on the mat.</span><br></pre></td></tr></table></figure>
<p><a href="https://regex101.com/r/AyAdgJ/2" target="_blank" rel="noopener">在线练习</a></p>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul>
<li>报告问题</li>
<li>开放合并请求</li>
<li>传播此文档</li>
<li>直接和我联系 <a href="mailto:ziishaned@gmail.com" target="_blank" rel="noopener">ziishaned@gmail.com</a> 或 <a href="https://twitter.com/ziishaned" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1e087b64058f101f01e1183e2ae522aab49ff408/68747470733a2f2f696d672e736869656c64732e696f2f747769747465722f75726c2f68747470732f747769747465722e636f6d2f7a69697368616e65642e7376673f7374796c653d736f6369616c266c6162656c3d466f6c6c6f772532302534307a69697368616e6564" alt="Twitter URL"></a></li>
</ul>
<h2 id="许可证"><a href="#许可证" class="headerlink" title="许可证"></a>许可证</h2><p>MIT © <a href="https://twitter.com/ziishaned" target="_blank" rel="noopener">Zeeshan Ahmad</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/正则表达式/">正则表达式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/20/csharp-fraction-struct/" title="C# 实现一个分数类型的结构" itemprop="url">C# 实现一个分数类型的结构</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-20T13:45:28.000Z" itemprop="datePublished"> 发表于 2019-11-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="让我们愉快地写一个分数结构吧！"><a href="#让我们愉快地写一个分数结构吧！" class="headerlink" title="让我们愉快地写一个分数结构吧！"></a>让我们愉快地写一个分数结构吧！</h2><p>因为分数的类型比较轻量级，仅包含两个字段，所以我们可以使用值类型。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Fraction : IEquatable&lt;Fraction&gt;, IComparable&lt;Fraction&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Fraction Zero = <span class="keyword">new</span> Fraction(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Fraction One = <span class="keyword">new</span> Fraction(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Fraction MinusOne = <span class="keyword">new</span> Fraction(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">int</span> gcd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fraction</span>(<span class="params"><span class="keyword">int</span> numerator</span>) : <span class="title">this</span>(<span class="params">numerator, <span class="number">1</span></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fraction</span>(<span class="params"><span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        gcd = GetGcd(Math.Abs(numerator), Math.Abs(denominator));</span><br><span class="line">        Numerator = Deduct(numerator, gcd);</span><br><span class="line">        Denominator = Deduct(denominator, gcd);</span><br><span class="line">        IsPositive = !(numerator &gt; <span class="number">0</span> ^ denominator &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Deduct</span>(<span class="params"><span class="keyword">int</span> digit, <span class="keyword">int</span> gcd</span>)</span> =&gt; Math.Abs(digit) / gcd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> IsPositive &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Value =&gt; (<span class="keyword">decimal</span>)Numerator / Denominator;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Numerator &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Denominator &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Fraction Nagate =&gt; <span class="keyword">new</span> Fraction(-Numerator, Denominator);</span><br><span class="line">    <span class="keyword">public</span> Fraction Reciprocal =&gt; <span class="keyword">new</span> Fraction(Denominator, Numerator);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span>(<span class="params">Fraction other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">this</span> - other;</span><br><span class="line">        <span class="keyword">return</span> result &gt; <span class="number">0</span> ? <span class="number">1</span> : result &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="keyword">int</span> other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> other == <span class="number">0</span> ? Numerator == <span class="number">0</span> ? <span class="number">0</span> : IsPositive ? <span class="number">1</span> : <span class="number">-1</span> : CompareTo((Fraction)other);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Truncate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TruncatingDivide</span>(<span class="params">Fraction fraction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="keyword">this</span> / fraction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span>? obj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">is</span> Fraction comparer &amp;&amp; Equals(comparer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">Fraction other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> Numerator == other.Numerator &amp;&amp; Denominator == other.Denominator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> Value.GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">$"<span class="subst">&#123;(IsPositive ? <span class="string">""</span> : <span class="string">"-"</span>)&#125;</span><span class="subst">&#123;Numerator&#125;</span><span class="subst">&#123;(Denominator == <span class="number">1</span> ? <span class="string">""</span> : <span class="string">$"/<span class="subst">&#123;Denominator&#125;</span>"</span>)&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SuppressMessage(<span class="meta-string">"Design"</span>, <span class="meta-string">"CA1031:Do not catch general exception types"</span>, Justification = <span class="meta-string">"&lt;Pending&gt;"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">TryParse</span>(<span class="params"><span class="keyword">string</span> str, [NotNullWhen(<span class="literal">true</span></span>)] <span class="keyword">out</span> Fraction? result)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = Parse(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="title">Parse</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.Contains(<span class="string">'/'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">string</span> digitPattern = <span class="string">@"[+-]?\d+"</span>;</span><br><span class="line">            <span class="keyword">var</span> match = <span class="keyword">new</span> Regex(<span class="string">$@"<span class="subst">&#123;digitPattern&#125;</span>/\s*<span class="subst">&#123;digitPattern&#125;</span>"</span>).Match(str);</span><br><span class="line">            <span class="keyword">if</span> (match.Success)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> mc = <span class="keyword">new</span> Regex(digitPattern).Matches(str);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Fraction(<span class="keyword">int</span>.Parse(mc[<span class="number">0</span>].Value), <span class="keyword">int</span>.Parse(mc[<span class="number">1</span>].Value));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Parse failed.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"Cannot parse value to target type."</span>, <span class="keyword">nameof</span>(str));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Fraction(<span class="keyword">int</span>.Parse(str));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetGcd</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span> =&gt; b == <span class="number">0</span> ? a : GetGcd(b, a % b);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetLcm</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> gcd = GetGcd(a, b);</span><br><span class="line">        <span class="keyword">return</span> Math.Max(a / gcd, b / gcd) * gcd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> +(Fraction fraction) =&gt; fraction;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> -(Fraction fraction) =&gt; fraction.Nagate;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> ++(Fraction fraction) =&gt; fraction + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> --(Fraction fraction) =&gt; fraction - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> +(Fraction left, Fraction right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> (a, b, c, d) = (left.Numerator, left.Denominator, right.Numerator, right.Denominator);</span><br><span class="line">        <span class="keyword">var</span> (s1, s2) = (left.IsPositive, right.IsPositive);</span><br><span class="line">        <span class="keyword">int</span> lcm = GetLcm(b, d);</span><br><span class="line">        a *= lcm / b;</span><br><span class="line">        c *= lcm / d;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fraction((s1 ? a : -a) + (s2 ? c : -c), lcm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> -(Fraction left, Fraction right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left + right.Nagate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> *(Fraction left, Fraction right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> (a, b, c, d) = (left.Numerator, left.Denominator, right.Numerator, right.Denominator);</span><br><span class="line">        <span class="keyword">bool</span> isPositive = !(left.IsPositive ^ right.IsPositive);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fraction((isPositive ? a : -a) * c, b * d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> /(Fraction left, Fraction right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left * right.Reciprocal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="keyword">operator</span> %(Fraction left, Fraction right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left - right * left.TruncatingDivide(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Fraction left, Fraction right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left.Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(Fraction left, Fraction right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !left.Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(Fraction left, Fraction right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left.CompareTo(right) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Fraction left, Fraction right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left.CompareTo(right) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;=(Fraction left, Fraction right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left.CompareTo(right) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;=(Fraction left, Fraction right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> left.CompareTo(right) &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">byte</span>(<span class="params">Fraction fraction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>)fraction.Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">short</span>(<span class="params">Fraction fraction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>)fraction.Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">Fraction fraction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> fraction.Truncate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">long</span>(<span class="params">Fraction fraction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>)fraction.Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">float</span>(<span class="params">Fraction fraction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>)fraction.Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">double</span>(<span class="params">Fraction fraction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>)fraction.Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">decimal</span>(<span class="params">Fraction fraction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> fraction.Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">Fraction</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fraction(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E6%95%B0%E5%AD%A6/">C♯.数学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/数学/">数学</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/20/csharp-regex-util/" title="C# 的正则表达式用法" itemprop="url">C# 的正则表达式用法</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-20T11:24:21.000Z" itemprop="datePublished"> 发表于 2019-11-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h2><p>正则表达式是一种机制，可以从一个字符串里快速提取指定内容格式的信息，比如在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, world</span><br></pre></td></tr></table></figure>
<p>里提取出所有的单词信息，用正则表达式可以写作 <code>[A-Za-z]+</code>，这样就能得到与这个表达式所匹配的 <code>Hello</code> 和 <code>world</code> 两个单词。</p>
<p>但是，具体怎么使用正则表达式，语法有哪些，并不在本文里给出，可以参考网络上的正则表达式的文章，或是这个 GitHub 上的<a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">正则表达式学习 repo</a>。不过在使用所有下面的内容之前，你需要先使用命名空间 <code>System.Text.RegularExpression</code>。</p>
<h2 id="Regex-类"><a href="#Regex-类" class="headerlink" title="Regex 类"></a><code>Regex</code> 类</h2><p>使用 <code>Regex</code> 类，并以正则表达式的字符串写法，可以实例化一个正则表达式的对象。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wordRegex = <span class="keyword">new</span> Regex(<span class="string">@"[A-Za-z]+"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Match-和-MatchCollection-类"><a href="#Match-和-MatchCollection-类" class="headerlink" title="Match 和 MatchCollection 类"></a><code>Match</code> 和 <code>MatchCollection</code> 类</h2><p>在通过实例化对象后，使用 <code>Match</code> 和 <code>Matches</code> 方法可以获取所有匹配项，只不过，<code>Match</code> 方法执行的结果是 <code>Match</code> 类类型的数据，它表示只提取所有满足条件的一个，而 <code>Matches</code> 方法执行的结果是一个 <code>MatchCollection</code> 类类型的对象，表示所有满足条件的匹配项目。不过，它们提取出来的内容都是封装好的对象，需要使用 <code>Value</code> 属性获取信息。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">string</span> str = <span class="string">"Hello, world"</span>;</span><br><span class="line"><span class="keyword">var</span> wordRegex = <span class="keyword">new</span> Regex(<span class="string">@"[A-Za-z]+"</span>);</span><br><span class="line"><span class="keyword">var</span> match = wordRegex.Match(str);</span><br><span class="line"><span class="keyword">var</span> matchCollection = wordRegex.Matches(str);</span><br><span class="line">Console.WriteLine(match.Value);</span><br><span class="line">Console.WriteLine(matchCollection[<span class="number">0</span>].Value);</span><br><span class="line">Console.WriteLine(matchCollection[<span class="number">1</span>].Value);</span><br></pre></td></tr></table></figure>
<p>调用 <code>MatchCollection</code> 对象的方法是，通过中括号索引来获取，或者通过 <code>foreach</code> 循环获取每一个对象，再使用 <code>Value</code> 属性获取匹配的具体内容。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> m <span class="keyword">in</span> matchCollection) <span class="comment">// m is object.</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine((m <span class="keyword">as</span> Match).Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or</span></span><br><span class="line"><span class="keyword">foreach</span> (Match m <span class="keyword">in</span> matchCollection)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(m.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稍微注意的是，<code>MatchCollection</code> 同时实现了 <code>IEnumerable</code> 和 <code>IEnumerable&lt;Match&gt;</code> 接口，这使得上述两种 <code>foreach</code> 循环均成立。但如果对迭代的每一个对象使用 <code>var</code> 关键字，它将会被当作 <code>object</code>，这是因为在 API 里，隐式实现接口的模式是 <code>IEnumerable</code>，而不是那个泛型接口。</p>
<h2 id="IsMatch-方法"><a href="#IsMatch-方法" class="headerlink" title="IsMatch 方法"></a><code>IsMatch</code> 方法</h2><p>另外，你可以使用 <code>IsMatch</code> 方法来判断匹配是否成功（即匹配后是否包含有匹配项）。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> isSuccess = <span class="keyword">new</span> Regex(<span class="string">@"[A-Za-z]+"</span>).IsMatch(str);</span><br></pre></td></tr></table></figure>
<p>如果 <code>isSuccess</code> 是 <code>false</code>，则表示不包含。</p>
<h2 id="构造器的精细化处理"><a href="#构造器的精细化处理" class="headerlink" title="构造器的精细化处理"></a>构造器的精细化处理</h2><p>我们甚至可以通过构造器的参数来设置匹配的更多细节，比如超时等。</p>
<p>C# 为我们提供了三个不同的构造器：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Regex</span>(<span class="params"><span class="keyword">string</span> pattern</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Regex</span>(<span class="params"><span class="keyword">string</span> pattern, RegexOptions options</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Regex</span>(<span class="params"><span class="keyword">string</span> pattern, RegexOptions options, TimeSpan matchTimeout</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是传入一个正则表达式的字符串格式写法（即上面的 <code>[A-Za-z]+</code>），第二个参数是匹配方式，它是一个枚举值，它包含如下的枚举结果：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RegexOptions</span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    IgnoreCase = <span class="number">1</span>,</span><br><span class="line">    Multiline = <span class="number">2</span>,</span><br><span class="line">    ExplicitCapture = <span class="number">4</span>,</span><br><span class="line">    Compiled = <span class="number">8</span>,</span><br><span class="line">    Singleline = <span class="number">16</span>,</span><br><span class="line">    IgnorePatternWhitespace = <span class="number">32</span>,</span><br><span class="line">    RightToLeft = <span class="number">64</span>,</span><br><span class="line">    ECMAScript = <span class="number">256</span>,</span><br><span class="line">    CultureInvariant = <span class="number">512</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不必都讲，默认是传入 <code>RegexOptions.None</code> 的。到时候查文档就可以了。</p>
<p>第三个参数是传入一个超时的时长 <code>TimeSpan</code> 结构对象。当匹配过程超出这个时间的时候将会直接抛出 <code>RegexMatchTimeoutException</code> 异常（这个是确定的），表示匹配超时。所以如果你在传入第三个参数时，就一定要想着去捕获可能抛出的这个异常。</p>
<blockquote>
<p>如果在 Java 里，这个机制就更加类似于 Checked Exception 了。</p>
</blockquote>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>下面来一个实例。假设我们在设计一个分数类 <code>Fraction</code> 的时候需要解析字符串，并生成指定的分数对象。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fraction <span class="title">Parse</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">string</span> digitPattern = <span class="string">@"[+-]?\d+"</span>;</span><br><span class="line">    <span class="keyword">var</span> match = <span class="keyword">new</span> Regex(<span class="string">$@"<span class="subst">&#123;digitPattern&#125;</span>/\s*<span class="subst">&#123;digitPattern&#125;</span>"</span>).Match(str);</span><br><span class="line">    <span class="keyword">if</span> (match.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> mc = <span class="keyword">new</span> Regex(digitPattern).Matches(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Fraction(<span class="keyword">int</span>.Parse(mc[<span class="number">0</span>].Value), <span class="keyword">int</span>.Parse(mc[<span class="number">1</span>].Value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Parse failed.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(</span><br><span class="line">            <span class="string">"Cannot parse value to target type."</span>, <span class="keyword">nameof</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SuppressMessage(<span class="meta-string">"Design"</span>, <span class="meta-string">"CA1031:Do not catch general exception types"</span>, Justification = <span class="meta-string">"&lt;Pending&gt;"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">TryParse</span>(<span class="params"><span class="keyword">string</span> str, [NotNullWhen(<span class="literal">true</span></span>)] <span class="keyword">out</span> Fraction? result)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = Parse(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        result = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<p><img src="fraction-test.png" alt=""></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/正则表达式/">正则表达式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/csharp-complier-generating-auto-property/" title="C# 里自动属性特性的编译器生成" itemprop="url">C# 里自动属性特性的编译器生成</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T13:02:37.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="属性和自动属性都是什么？"><a href="#属性和自动属性都是什么？" class="headerlink" title="属性和自动属性都是什么？"></a>属性和自动属性都是什么？</h2><p>属性在 C# 里是一个非常重要的概念。在 Java 里是没有这个概念的，它可以类比表示一种封装机制，将内部使用的字段通过 <code>getxxx</code> 和 <code>setxxx</code> 方法存取数据，暴露给外部，使得程序员可以更轻松地发现哪些字段可以被看到，并赋值和读取。这种封装机制在 C# 得到了简化。</p>
<p>最初的 C# 提供了属性机制，它是 Java 这种封装机制的整合工具。比如在 Java 里，封装一个字段的信息需要两个方法和一个字段，所以格式是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C# 里变为了这样的书写格式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">this</span>.age = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，它为这种封装机制取了个名，叫做 <code>Age</code>，它就是属性。这是一种约定俗成的习惯。我们习惯把属性的名称和字段的名字用到的词汇搞成一样的，只是字段用驼峰命名法（第一个单词首字母小写，后出现的单词每一个单词都大写首字母），而属性用帕斯卡命名法（所有单词用大写首字母的方式分隔）。</p>
<p>属性在前面配上了类似于返回值的写法，比如上述的第 5 行 <code>public int Age</code> 的 <code>int</code> 是作为属性在获取值和赋值过程之中用到的类型。比如 <code>Age</code> 为 <code>age</code> 字段提供赋值和获取值的两个工作。获取值的返回值是 <code>int</code>，而赋值用的是 <code>int</code> 类型的变量才能成功赋值。所以这个 <code>int</code> 在属性这个包装器上并不是表达返回值的意思，仅仅是恰好写这里作为一种语法规范而已。</p>
<p>自动属性表示自动实现的属性，因为大多的 <code>get</code> 和 <code>set</code> 块里的写法都是 <code>return</code> 一个数值和 <code>this.字段 = value</code> 的赋值模式，所以干脆就在 C# 3 里添加了自动实现的属性这个特性，就不必我们手动去写这么一大堆代码了。</p>
<blockquote>
<p>前文没有讲。<code>value</code> 关键字专门用来临时代替 <code>set</code> 块生成的参数名。就好像 Java 的 <code>setxxx</code> 方法一样，它一定会带有一个参数，为指定的字段赋值，这里的 <code>set</code> 块由于不让写参数名，所以就用了一个关键字专门来表达这个东西。</p>
</blockquote>
<h2 id="自动生成的代码"><a href="#自动生成的代码" class="headerlink" title="自动生成的代码"></a>自动生成的代码</h2><p>在 C# 3 里提供了自动属性，所以自动属性可以不要求你实现 <code>get</code> 和 <code>set</code> 块，直接用分号结尾即可，甚至不让你写字段名：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它都将自动生成，生成的代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">this</span>.age = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其它用法"><a href="#其它用法" class="headerlink" title="其它用法"></a>其它用法</h2><h3 id="带访问修饰符的自动属性"><a href="#带访问修饰符的自动属性" class="headerlink" title="带访问修饰符的自动属性"></a>带访问修饰符的自动属性</h3><p>在自动属性里，它甚至提供了配套访问修饰符的模式。比如这里我们不想让 <code>age</code> 字段拥有赋值的操作，我们一般都会把 <code>set</code> 定为私有的，然后不让外界访问，只有本类里的成员可以使用 <code>Age</code> 属性的 <code>set</code> 块。</p>
<p>那么代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确实很简单，只需要在前面加上 <code>private</code> 关键字即可。到时候它也会在指定的属性旁生成这个关键字，以表示 <code>set</code> 块是 <code>private</code> 的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span> &#123; <span class="keyword">this</span>.age = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始赋值的自动属性"><a href="#初始赋值的自动属性" class="headerlink" title="初始赋值的自动属性"></a>初始赋值的自动属性</h3><p>没想到吧，C# 6 里提供了初始赋值的自动属性。由于属性在自动属性特性实现后，字段已经被编译器“隐藏起来了”，所以我们只能通过属性来给字段赋初始值。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> FirstName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"Jane"</span>;</span><br></pre></td></tr></table></figure>
<p>生成的代码是这样的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">string</span> FirstName = <span class="string">"Jane"</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> FirstName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.firstName; &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; <span class="keyword">this</span>.firstName = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/C♯-编译器生成/">C♯.编译器生成</a><a href="/tags/C♯-3/">C♯ 3</a><a href="/tags/C♯-6/">C♯ 6</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/csharp-nrt/" title="C# 8 里的可空引用类型" itemprop="url">C# 8 里的可空引用类型</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T12:48:55.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="可空引用类型"><a href="#可空引用类型" class="headerlink" title="可空引用类型"></a>可空引用类型</h2><p>在前文里，我们介绍过<a href="https://sunnie-shine.github.io/2019/11/08/csharp-common-01-nvt/">可空值类型 <code>Nullable&lt;T&gt;</code></a> 的相关内容，可以发现值类型是可以使用 <code>Nullable&lt;T&gt;</code> 使之为 <code>null</code> 的，不过引用类型基于指针这一点来说，肯定是需要 <code>null</code> 这种机制的。</p>
<p>不过……是的，你没有看错，从 C# 8 开始，引用类型也开始支持可空了。但是，引用类型不是一直都可以为 <code>null</code> 吗？它默认数值不就是为 <code>null</code> 吗？是的，但 C# 8 “暴力地”破坏了这一个要求，为了防止尽可能少出现 <code>NullReferenceException</code> 这种可怕的异常，我们产生了一个新的语法规则：强制引用类型不可空。然后如果非得让引用类型为空的话，请采用 <code>T?</code> 的写法，和值类型可空的写法一样，比如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>? s = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>但需要你注意的是，这种写法需要基于可空引用类型的环境。你需要先打开你的项目配置文件 <code>.csproj</code>，然后添加一项：<code>&lt;Nullable&gt;Enable&lt;/Nullable&gt;</code> 即可使用这个特性。</p>
<blockquote>
<p>类似地，<strong>可空引用类型</strong>（Nullable Reference Type）一般被简称为 NRT。</p>
</blockquote>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>我们通过和可空值类型完全一样的语法 <code>T?</code> 来声明一个类型可空：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>? s = <span class="literal">null</span>; <span class="comment">// A string can be null.</span></span><br><span class="line">s = <span class="string">"Hello"</span>; <span class="comment">// Okay.</span></span><br><span class="line">s = <span class="literal">null</span>; <span class="comment">// Okay.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> t = <span class="literal">null</span>; <span class="comment">// Will get a complier warning.</span></span><br></pre></td></tr></table></figure>
<p>但请注意，可空引用类型仅仅是语法上看起来和可空值类型一样，但实际上，可空引用类型并没有类似于 <code>Nullable&lt;T&gt;</code> 的类型，它在运行时是和原本的类型完全一样的，只是从编译器层面约束和限制了我们无法赋 <code>null</code> 值的要求。说白了，<code>string?</code> 和 <code>string</code> 依旧用的是同一个数据类型，只是编译器在看到你的类型后带 <code>?</code> 后会被判定为“可空”，于是这个类型你就可以放 <code>null</code> 进去；但没有这个符号，你就没办法赋 <code>null</code> 值，否则将会产生 CS86 系列警告。</p>
<p>那么，对应的一些语法，我们就得注意了：</p>
<h3 id="后缀运算符"><a href="#后缀运算符" class="headerlink" title="! 后缀运算符"></a><code>!</code> 后缀运算符</h3><p>为了保证一些特定情况下，我们需要赋值不为空，但编译器依然认为你赋的是 <code>null</code> 值时，我们可以采用 <code>!</code> 后缀运算符来强制编译器取消告警。</p>
<p>举一个例子，例如我们写了一个字符串转结构体的 <code>Parse</code> 方法，其中返回值是一个可空的类型，</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> y</span>)</span> =&gt; (X, Y) = (x, y);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> X &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Y &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point? Parse(<span class="keyword">string</span> str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// `(a, b)` form is correct,</span></span><br><span class="line">        <span class="comment">// so we use regular expression to get `a` and `b`.</span></span><br><span class="line">        <span class="keyword">var</span> regex = <span class="keyword">new</span> Regex(<span class="string">@"\(\d+,\s*\d+\)"</span>);</span><br><span class="line">        <span class="keyword">var</span> match = regex.Match(str);</span><br><span class="line">        <span class="keyword">if</span> (match.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Parse successfully.</span></span><br><span class="line">            <span class="keyword">var</span> valRegex = <span class="keyword">new</span> Regex(<span class="string">@"\d+"</span>);</span><br><span class="line">            <span class="keyword">var</span> matches = regex.Matches(match.Value);</span><br><span class="line">            <span class="keyword">var</span> s1 = matches[<span class="number">0</span>].Value;</span><br><span class="line">            <span class="keyword">var</span> s2 = matches[<span class="number">1</span>].Value;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Return the correct answer.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="keyword">int</span>.Parse(s1), <span class="keyword">int</span>.Parse(s2));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Parse failed, it will return null value</span></span><br><span class="line">            <span class="comment">// to tell user the parsing operation has failed.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我在调用期间使用了这个方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p = Point.Parse(<span class="string">"(1, 3)"</span>);</span><br></pre></td></tr></table></figure>
<p>此时，将会产生一个编译器警告，提示你转换后的结果可能是 <code>null</code>。客观来讲，这确实是对的，因为返回值是可空类型的，而我们用一个不可为空的类型接受这个可空类型时，显然范围变小了，确实需要报错。</p>
<p>但是，我们完全可以发现，这个转换是有效且正确的，因为我们的正则表达式转换出来的结果一定可以得到 <code>X = 1</code> 和 <code>Y = 3</code> 的结果，这是令人烦躁的，所以我们只需要在转换结果后添加一个感叹号 <code>!</code> 来告诉编译器，这里的非空结果是预料之中的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p = Point.Parse(<span class="string">"(1, 3)"</span>)!;</span><br></pre></td></tr></table></figure>
<p>但需要你注意的是，如果在此时我们使用 <code>var</code> 类型来表示 <code>p</code> 的话，这两个语句都会得到什么结果呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = Point.Parse(<span class="string">"(1, 3)"</span>);  <span class="comment">// `p` is Point? type.</span></span><br><span class="line"><span class="keyword">var</span> q = Point.Parse(<span class="string">"(1, 3)"</span>)!; <span class="comment">// `q` is Point type.</span></span><br></pre></td></tr></table></figure>
<p>你答对了吗？</p>
<blockquote>
<p><code>!</code> 后缀运算符在 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/null-forgiving" target="_blank" rel="noopener">MSDN</a> 里称为<strong>null 包容运算符</strong>（Null-forgiving Operator），而在 Visual Studio 2019 下，这个运算符称为<strong>null 警告禁用运算符</strong>（Null-suppress Operator）。</p>
</blockquote>
<h3 id="as-的默认值"><a href="#as-的默认值" class="headerlink" title="as 的默认值"></a><code>as</code> 的默认值</h3><p>在 <a href="https://sunnie-shine.github.io/2019/11/06/csharplang-01-is-as-operator/">is 和 as</a> 一文中，我们提到了 <code>as</code> 的默认值。当引用类型时，转换无效时会返回 <code>null</code>。考虑如下情况。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> o = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">string</span> i = o <span class="keyword">as</span> <span class="keyword">string</span>; <span class="comment">// Hmmm</span></span><br></pre></td></tr></table></figure>
<p>可以看到，第二句话里，我们尝试将我们认为的 <code>o</code> 转为 <code>string</code> 类型。但这是不可能的，因为 <code>o</code> 装的是一个 <code>Point</code>，所以 <code>as</code> 转换失败后会返回 <code>null</code>。但显然，<code>string</code> 后没有问号，所以并不可空。那么这里一定会出现编译器的警告。那么，这下怎么办呢？</p>
<p>如果我们能保证这个转换是成立的，我们应当使用 <code>!</code> 后缀运算符来修饰结果，表示这个结果此时肯定不可空，是在我们预料之中的。但我们随时随地都可以加这个符号来取消警告。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> o = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">string</span> i = (o <span class="keyword">as</span> <span class="keyword">string</span>)!; <span class="comment">// What the hell?</span></span><br></pre></td></tr></table></figure>
<p>显然，这个转换是错误的，但我们确实取消了编译器的警告，那么，我们此时如果随意地使用这个 <code>i</code>，就会出现问题。比如我们取字符串的第 3 个字符：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = i[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>显然，这是会错的。所以，这产生了语义层面的 bug。我们应当尽量少使用 <code>!</code> 符号，而更多用在正确的地方。而且，哪怕原本类型就是 <code>string</code>，编译器依然会报错。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> o = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">string</span> s = o <span class="keyword">as</span> <span class="keyword">string</span>; <span class="comment">// Complier warning...</span></span><br></pre></td></tr></table></figure>
<p>这是因为编译器仅检查类型，它发现 <code>o</code> 是 <code>object</code> 时，就不会再往下查看具体 <code>o</code> 装的是什么类型的数据了，于是在使用 <code>as</code> 转换时，完全可能产生 <code>null</code> 结果，所以报错。此时我们不得不使用 <code>!</code> 后缀运算符：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> o = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">string</span> s = (o <span class="keyword">as</span> <span class="keyword">string</span>)!;</span><br></pre></td></tr></table></figure>
<p>但请注意，刚才说过，如果这里使用 <code>var</code> 来表示类型的话，如果不加 <code>!</code> 后缀运算符，将会被识别为 <code>string?</code> 而不是 <code>string</code>。</p>
<h3 id="使用特性来减少-后缀运算符的使用"><a href="#使用特性来减少-后缀运算符的使用" class="headerlink" title="使用特性来减少 ! 后缀运算符的使用"></a>使用特性来减少 <code>!</code> 后缀运算符的使用</h3><p>前文说过，<code>!</code> 的用法是认为决定的，所以这完全取决于人的使用方式，故我们无法做到编译器层面的完全禁止。而有一些情况，我们完全可以不去使用它们，以此让编译器为我们产生错误信息，来更好地约束我们的代码思维。此时，我们需要用到如下的一些特性。</p>
<h4 id="NotNullWhenAttribute"><a href="#NotNullWhenAttribute" class="headerlink" title="NotNullWhenAttribute"></a><code>NotNullWhenAttribute</code></h4><p>考虑如下 API。我们把刚才的 <code>Point</code> 类的 <code>Parse</code> 方法转换为 <code>TryParse</code> 方法，让它返回 <code>bool</code> 数值，而结果从参数返回。那么</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Parse</span>(<span class="params"><span class="keyword">string</span> str, <span class="keyword">out</span> Point? result</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// `(a, b)` form is correct,</span></span><br><span class="line">    <span class="comment">// so we use regular expression to get `a` and `b`.</span></span><br><span class="line">    <span class="keyword">var</span> regex = <span class="keyword">new</span> Regex(<span class="string">@"\(\d+,\s*\d+\)"</span>);</span><br><span class="line">    <span class="keyword">var</span> match = regex.Match(str);</span><br><span class="line">    <span class="keyword">if</span> (match.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Parse successfully.</span></span><br><span class="line">        <span class="keyword">var</span> valRegex = <span class="keyword">new</span> Regex(<span class="string">@"\d+"</span>);</span><br><span class="line">        <span class="keyword">var</span> matches = regex.Matches(match.Value);</span><br><span class="line">        <span class="keyword">var</span> s1 = matches[<span class="number">0</span>].Value;</span><br><span class="line">        <span class="keyword">var</span> s2 = matches[<span class="number">1</span>].Value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the correct answer.</span></span><br><span class="line">        result = <span class="keyword">new</span> Point(<span class="keyword">int</span>.Parse(s1), <span class="keyword">int</span>.Parse(s2));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Parse failed, it will return null value</span></span><br><span class="line">        <span class="comment">// to tell user the parsing operation has failed.</span></span><br><span class="line">        result = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要变化一点点内容即可。</p>
<p>现在，新的问题来了。我们调用的方式是</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point p;</span><br><span class="line"><span class="keyword">if</span> (TryParse(<span class="string">"(1, 3)"</span>, <span class="keyword">out</span> <span class="keyword">var</span> result))</span><br><span class="line">    p = result;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    p = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这样显然是不会有问题的，首先，返回为 <code>true</code> 时，意味着 <code>result</code> 此时肯定不为 <code>null</code>，所以可以安全赋值过去，但编译器由于发现 <code>result</code> 是 <code>Point?</code> 的，所以会报错。于是此时我们不得不使用 <code>!</code>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point p;</span><br><span class="line"><span class="keyword">if</span> (TryParse(<span class="string">"(1, 3)"</span>, <span class="keyword">out</span> <span class="keyword">var</span> result))</span><br><span class="line">    p = result!;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    p = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这样是没有错误的。但我们发现，这种写法是受到返回值的约束。当返回值为 <code>true</code>，这个 <code>out</code> 参数肯定是不为空的。所以我们可以把 API 改变一下。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Parse</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">string</span> str, [NotNullWhen(returnValue: <span class="literal">true</span></span>)] <span class="keyword">out</span> Point? result)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Same as before.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在第二个参数前面加上特性：<code>[NotNullWhen(returnValue: true)]</code>，那么这个 <code>result</code> 在编译器层面就会认为，当返回值为 <code>true</code> 时，这个参数值一定不会为空。所以，我们一旦用了这个模式书写代码，那么调用方就不用写 <code>!</code> 了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point p;</span><br><span class="line"><span class="keyword">if</span> (TryParse(<span class="string">"(1, 3)"</span>, <span class="keyword">out</span> <span class="keyword">var</span> result))</span><br><span class="line">    p = result; <span class="comment">// Correct now.</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    p = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="AllowNullAttribute-和-DisallowNullAttribute"><a href="#AllowNullAttribute-和-DisallowNullAttribute" class="headerlink" title="AllowNullAttribute 和 DisallowNullAttribute"></a><code>AllowNullAttribute</code> 和 <code>DisallowNullAttribute</code></h4><p>下面我们来看另外一个特性。这个特性表示我们给的数值是允许为 <code>null</code> 的。它一般用在属性的 setter，或参数上。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">AllowNull</span>]</span><br><span class="line">    <span class="keyword">set</span> &#123; name = Name ?? <span class="string">"DefaultName"</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，这个 setter 原本应该赋值为 <code>string</code> 的，但编译器此时允许你为其赋 <code>null</code> 进去。</p>
<p>当然了，<code>DisallowNull</code> 就是反过来的，不为 <code>null</code>。</p>
<h4 id="MaybeNullAttribute"><a href="#MaybeNullAttribute" class="headerlink" title="MaybeNullAttribute"></a><code>MaybeNullAttribute</code></h4><p>思考一下，当我们使用一个泛型是很普通的类型时，如果它为 <code>null</code> 了怎么办？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T FirstOrDefault&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;T&gt; source, Precicate&lt;T&gt; predicate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这个例子，它是 <a href="https://source.dot.net/#System.Linq/System/Linq/First.cs,8087366974af11d2,references" target="_blank" rel="noopener">Linq</a> 代码里的一个部分。这个方法是用于查找一个类型为 <code>T</code> 的集合 <code>source</code> 里，第一个满足 <code>predicate</code> 给定条件的项。当找到结果后，返回值为这个值；但没有找到结果的时候，返回值将为这个类型的默认值：值类型则是对应的默认结果，而引用类型则默认为 <code>null</code>。</p>
<p>按道理来讲，这里返回值就应当为可空的类型，所以我们应该设为 <code>T?</code> 类似的写法，来强制规定返回值可空。但很遗憾的是，这么做编译器会报错。这个编译器报错的大概意思是：“由于值类型和引用类型的行为不同，我们无法设置这一要求，请设置约束来规定这个泛型参数 <code>T</code> 是值类型还是引用类型”。</p>
<p>编译器的说法是有道理的。因为我们的值类型和引用类型的行为不同，值类型的可空，是将其翻译为另外一个类型 <code>Nullable&lt;T&gt;</code>，而引用类型则完全没有变化类型，只是告诉编译器它可空而已。如果我们“妄自”添加问号在类型上面的话，值类型和引用类型的处理方式都不同，那么后续交给程序，它并不知道这个类型此时是值类型还是引用类型，那后续有应该该怎么做呢？这是很复杂的一个问题。所以，我们临时给出的解决方案是，为这个返回值添加一个特性：<code>MaybeNullAttribute</code> 来表示这个返回值是可空的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">return: MaybeNull</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> T FirstOrDefault&lt;T&gt;(<span class="keyword">this</span> IEnumerable&lt;T&gt; source, Precicate&lt;T&gt; predicate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，编译器就能明白，此处的这个泛型返回值对应的类型，会依据值类型和引用类型分情况处理。引用类型下，就会产生警告。实际上，这个方法调用的是另外一个方法：<code>TryGetFirst</code>。它的源代码我也复制出来。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">return: MaybeNull</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TSource TryGetFirst&lt;T&gt;(</span><br><span class="line">    <span class="keyword">this</span> IEnumerable&lt;T&gt;? source, Predicate&lt;T&gt;? predicate, <span class="keyword">out</span> <span class="keyword">bool</span> found)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (predicate <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.predicate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (source <span class="keyword">is</span> OrderedEnumerable&lt;T&gt; ordered)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Check the type is OrderedEnumerable&lt;T&gt; or not.</span></span><br><span class="line">        <span class="comment">// If so, the code will be simplified a bit.</span></span><br><span class="line">        <span class="keyword">return</span> ordered.TryGetFirst(predicate, <span class="keyword">out</span> found);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate on source.</span></span><br><span class="line">    <span class="keyword">foreach</span> (T element <span class="keyword">in</span> source)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If satisfying the predicate...</span></span><br><span class="line">        <span class="keyword">if</span> (predicate(element))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Return the result.</span></span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Failed to find.</span></span><br><span class="line">    found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">default</span>!; <span class="comment">// The value may be null when the value is a reference type.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希望你能感受一下，这个特性在代码里起到的作用。</p>
<h4 id="NotNullAttribute"><a href="#NotNullAttribute" class="headerlink" title="NotNullAttribute"></a><code>NotNullAttribute</code></h4><p>下面来介绍一个用法和刚才这个差不多的特性。这个特性一般用在 <code>ref</code> 参数上，表示参数在传参时不可以赋值为 <code>null</code>，虽然它此时是可以为 <code>null</code> 的类型。</p>
<p>在 .NET 提供的数据结构的代码里，某个数据结构需要进行扩容，此时为了保证容量，会调用下面这样的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Messages has the default value (null) when EnsureCapacity is called:</span></span><br><span class="line">EnsureCapacity&lt;<span class="keyword">string</span>&gt;(<span class="keyword">ref</span> storage, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// Messages is not null.</span></span><br><span class="line">EnsureCapacity&lt;<span class="keyword">string</span>&gt;(storage, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>如果原本是一个数组的话，我们可以为 API 设计为这样：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> EnsureCapacity&lt;T&gt;([NotNull] <span class="keyword">ref</span> T[]? storage, <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时来告诉编译器，在传参时，是不允许为 <code>null</code> 赋值过去的，但最后 <code>storage</code> 可以为 <code>null</code>，并是否为 <code>null</code> 将在 API 设计的代码里决定，而不是外界。</p>
<h4 id="NotNullIfNotNullAttribute"><a href="#NotNullIfNotNullAttribute" class="headerlink" title="NotNullIfNotNullAttribute"></a><code>NotNullIfNotNullAttribute</code></h4><p>最后一个特性是最鬼畜的特性。这个特性其实和 <code>NotNullWhenAttribute</code> 的用法非常相似，只是有一点区别：<code>NotNullWhenAttribute</code> 依赖于返回值来决定是否为空，而这里说的这个特性，依赖于其它参数。其中参数是什么，那么它的可空性和返回值的可空性是一样的。</p>
<p>考虑如下代码。我们假设要写一个 DNS 解析的服务。我们需要返回一个根域名服务器的地址，用字符串表示，而参数表示当前主机的地址。但如果参数为空，显然返回值就应为空，因为主机都没有，那么对应的根域名服务器肯定也就为空了，返回值此时的可空行为是和参数 <code>url</code> 是一样的，所以我们为返回值设定 <code>NotNullIfNotNullAttribute</code> 特性，来告诉编译器，返回值在参数 <code>url</code> 不为空的时候不为空。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">return: NotNullIfNotNull(<span class="meta-string">"url"</span>)</span>]</span><br><span class="line"><span class="keyword">string</span>? GetTopLevelDomainFromFullUrl(<span class="keyword">string</span>? url);</span><br></pre></td></tr></table></figure>
<p>虽然有点绕，但意思应该是清晰的。</p>
<h3 id="关于泛型的可空性"><a href="#关于泛型的可空性" class="headerlink" title="关于泛型的可空性"></a>关于泛型的可空性</h3><p>在前文我们提到了泛型的可空性。由于值类型和引用类型的可空行为不同，所以我们恐怕无法单纯添加一个问号就解决这一点。在 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/nullable-attributes#generic-definitions-and-nullability" target="_blank" rel="noopener">MSDN</a> 的原文里，原文是这么说的：</p>
<blockquote>
<p>Correctly communicating the null state of generic types and generic methods requires special care. This stems from the fact that a nullable value type and a nullable reference type are fundamentally different. An <code>int?</code> is a synonym for <code>Nullable&lt;int&gt;</code>, whereas <code>string?</code> is <code>string</code> with an attribute added by the compiler. The result is that the compiler can’t generate correct code for <code>T?</code> without knowing if <code>T</code> is a <code>class</code> or a <code>struct</code>.</p>
<p>This doesn’t mean you can’t use a nullable type (either value type or reference type) as the type argument for a closed generic type. Both <code>List</code> and <code>List</code> are valid instantiations of <code>List</code>.</p>
<p>What it does mean is that you can’t use <code>T?</code> in a generic class or method declaration without constraints. For example, <a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault#System_Linq_Enumerable_FirstOrDefault__1_System_Collections_Generic_IEnumerable___0__" target="_blank" rel="noopener">Enumerable.FirstOrDefault(IEnumerable)</a> won’t be changed to return <code>T?</code>. You can overcome this limitation by adding either the <code>struct</code> or <code>class</code> constraint. With either of those constraints, the compiler knows how to generate code for both <code>T</code> and <code>T?</code>.</p>
<p>You may want to restrict the types used for a generic type argument to be non-nullable types. You can do that by adding the <code>notnull</code> constraint on that type argument. When that constraint is applied, the type argument must not be a nullable type.</p>
</blockquote>
<p>我把这段话大致翻译了一下，我希望你能看懂中文。:P</p>
<blockquote>
<p>对于一个泛型类型和泛型方法的 null 的状态的正确处理是我们肯定会关心的地方。这个“梗”的诞生源于值类型和引用类型处理的方式完全不同。一个 <code>int?</code> 类型被翻译转为 <code>Nullable&lt;int&gt;</code>，但 <code>string?</code> 在编译器层面仅仅是添加了一个特性标记来标注它是个可空的 <code>string</code> 类型而已，因此类型并没发生变化。所以，编译器根本不可能在它本身并不知道 <code>T</code> 是一个值类型还是引用类型之前，就生成完全正确的代码。</p>
<p>但这并不意味着，我们不能在一个闭合的泛型类型参数上使用可空类型了（这里的可空类型指的是值类型或引用类型的两种可空情况的其一）。换句话说，<code>List&lt;string?&gt;</code> 和 <code>List&lt;int?&gt;</code> 在初始化 <code>List&lt;T&gt;</code> 集合的时候，都是完全被允许的。</p>
<p>但是，我们也确实无法在没有任何泛型约束的状态下指定一个泛型类或泛型方法的泛型参数 <code>T</code> 上随意指定它可空（即 <code>T?</code>）。比如，<a href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault#System_Linq_Enumerable_FirstOrDefault__1_System_Collections_Generic_IEnumerable___0__" target="_blank" rel="noopener">Enumerable.FirstOrDefault(IEnumerable)</a>（上文里我们才看过的那个代码）就不可能允许直接返回一个 <code>T?</code>。但你完全可以克服这一点限制，通过为泛型参数添加一个值类型或引用类型的约束（写法是 <code>where T : struct</code> 或 <code>where T : class</code>），这样的话，编译器就肯定知道，接下来泛型类型 <code>T</code> 应如何去处理这个可空情况，即 <code>T?</code> 了。</p>
<p>你可能会想去限制某处的泛型参数不要为可空的类型，而且值类型和引用类型都可能。现在我们提供了一个泛型约束关键字 <code>notnull</code> 来表示这种特殊情况，只要我们为其设置 <code>where T : notnull</code> 泛型约束，那么此时的 <code>T</code> 就一定是一个不可以为空的类型了，而且值类型或引用类型均是允许的，只要它们不可空。</p>
</blockquote>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>很抱歉，这篇文章太长了。但我希望你能明白，可空值类型和可空引用类型的真正使用方式和操作，我可不希望你用错了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E8%AF%AD%E6%B3%95/">C♯.语法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/C♯-8/">C♯ 8</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/clang-07-for-loop/" title="C 语言语法系列（7）：for 语句" itemprop="url">C 语言语法系列（7）：for 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T12:35:56.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="for-（循环）语句"><a href="#for-（循环）语句" class="headerlink" title="for （循环）语句"></a><code>for</code> （循环）语句</h2><h3 id="for-语句的标准写法"><a href="#for-语句的标准写法" class="headerlink" title="for 语句的标准写法"></a><code>for</code> 语句的标准写法</h3><p>变量循环其实就是 <code>while</code> 和 <code>do-while</code> 语句的一种特别写法，为了方便人的理解，才创立的这样的循环操作，它是 <code>while</code> 的语法糖。</p>
<p>写法是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i; <span class="comment">// Note here, `i` is not `i++`.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code> 的括号里有三个语句，并且分别使用<strong>分号</strong>分开。原因在于它的写法会被编译为 <code>while</code> 语句，所以其实这些语句在 <code>while</code> 之中也都是需要加分号的，所以用分号隔开。两个分号把括号内的内容分隔成了三个部分，按顺序分别叫做<strong>初始值</strong>、<strong>条件</strong>、<strong>增量</strong>，即按变量来看的初始情况值，变量作循环需要满足的条件（或叫每做完一次循环后的判断条件），和每一次循环完成后变量需要变化的量。</p>
<p>它的解释是这样的：先赋初始值、然后判断条件、条件成立时执行循环里面的操作、然后对变量增加增量、然后判断条件、然后条件成立时只需循环里面的操作、然后对变量增加增量、然后判断条件，这样的操作。</p>
<p>比如上面的写法就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">i = 1</span><br><span class="line">i &lt; 100: 真</span><br><span class="line">sum += i: sum = 1</span><br><span class="line">i++: i = 2</span><br><span class="line">i &lt; 100: 真</span><br><span class="line">sum += i: sum = 3</span><br><span class="line">i++: i = 3</span><br><span class="line">i &lt; 100: 真</span><br><span class="line">sum += i: sum = 6</span><br><span class="line">i++: i = 4</span><br><span class="line">i &lt; 100: 真</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>另外，<code>sum = 0</code> 语句还可以直接写在 <code>for</code> 里。这也是可以的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, sum;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>, sum = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，变量赋初始值的时候，多个变量得用逗号隔开了。而且，标准 C 语言规定，变量的声明是不能写在 <code>for</code> 的里面的，比如这样是不可以的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种写法在 C99 标准里可以使用，而基本的 ANSI C 标准（C89）则不允许这么使用。</p>
</blockquote>
<h3 id="残缺-for"><a href="#残缺-for" class="headerlink" title="残缺 for"></a>残缺 <code>for</code></h3><p><code>for</code> 循环的分号内的东西可有可无，比如不需要的时候就可以不写，不过呢，分号不能省略。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样和上面的语句是等价的。毕竟赋初值可以在前面写，也可以后面写。</p>
<p>还可以这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; <span class="number">100</span>;)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样还是等效的。</p>
<h3 id="带有逗号表达式的-for"><a href="#带有逗号表达式的-for" class="headerlink" title="带有逗号表达式的 for"></a>带有逗号表达式的 <code>for</code></h3><p>在说这一点前，就不得不讲一个东西：逗号表达式。</p>
<h4 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h4><p>逗号表达式发明出来的唯一用途就只是放在 <code>for</code> 里，因为 <code>for</code> 需要用分号分隔所有部分（初值、条件和增量），所以如果想要同时给多个变量赋初始值的时候，或者是给多个变量设定增量的时候，就可以使用它，而不影响分号。</p>
<p>但是，因为它是在 C 语言里存在的语法点，所以也可以使用在其他场合，虽然这一点并不多大意义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">b = (a = <span class="number">3</span> * <span class="number">5</span>, a * <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>在赋值操作后，<code>a = 3 * 5, a * 4</code> 就是一个逗号表达式。它由两个部分构成：<code>a = 3 * 5</code> 和 <code>a * 4</code>。逗号表达式的计算是放在所有操作都执行完了才会执行的地方，这里是因为它有括号，所以会执行。</p>
<p>运算法则是这样的，从左到右依次计算，逗号表达式里面每一个用逗号分开的部分都会计算一次，并取最后一个部分，作为整体表达式的数值。比如这里，从左至右，先让 <code>a</code> 获得一个数值是 15，然后计算 <code>a * 4</code>，得到 60，这个 60 就是整体表达式的数值，最后赋值给 <code>b</code>，所以 <code>a = 15</code>、<code>b = 60</code>。</p>
<p>不过，由于它最后才会被计算，所以如果没有括号的话，就得小心了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c;</span><br><span class="line">c = a++, ++b, b++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%d%d"</span>, a, b, c);</span><br></pre></td></tr></table></figure>
<p>答案竟然是 <code>231</code>！你敢信？我们来看看为什么。</p>
<p>首先，C 语言规定，它的计算顺序是放在最后的，换句话说，赋值啥的所有操作全部在它前面。所以赋值会被先执行，也就是这句话等于是以下三句话的简写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = a++;</span><br><span class="line">++b;</span><br><span class="line">b++;</span><br></pre></td></tr></table></figure>
<p>只是合并了而已。而这句话你也看得出，逗号表达式虽然要取出最后一个逗号部分作为表达式的数值，但因为运算的关系，<code>a++</code> 已经先被赋值给 <code>c</code> 了，所以最终逗号表达式整体数值结果其实并没有什么用途，故这里其实只是相当于合并书写的一种操作罢了。</p>
<p>那么，<code>c = a++</code> 得到 <code>c</code> 的值应为 1，因为 <code>++</code> 在后。而 <code>a</code> 最终是会变为 2 的。然后 <code>b</code> 则会因为后面两句话，而增大两个单位。所以 <code>b</code> 应为 3。所以 $a = 2$、$b = 3$、$c = 1$。</p>
<h4 id="逗号表达式嵌套到-for-里"><a href="#逗号表达式嵌套到-for-里" class="headerlink" title="逗号表达式嵌套到 for 里"></a>逗号表达式嵌套到 <code>for</code> 里</h4><p>知道这一点之后，我们来看怎么嵌套。</p>
<p>我们知道，为 1 到 100 求和时，除了为作为循环的变量 <code>i</code> 赋值外，还需要为 <code>sum</code> 给定初始值，否则 <code>sum</code> 从一个根本就不知道是多少的数开始增加，是错误的。</p>
<p>所以我们可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, sum;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>, sum = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，简化写法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, sum;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>, sum = <span class="number">0</span>; i &lt;= <span class="number">100</span>; sum += i++);</span><br></pre></td></tr></table></figure>
<p>也是 OK 的。注意，这次 <code>for</code> 因为没有大括号的关系，循环的部分就只有 <code>for</code> 带上这个小括号这一部分而已。所以加上了分号，表示它在这里截断，<code>for</code> 的语句只能到这里。</p>
<h2 id="为什么经常把-for-里用的变量命名为-i？"><a href="#为什么经常把-for-里用的变量命名为-i？" class="headerlink" title="为什么经常把 for 里用的变量命名为 i？"></a>为什么经常把 <code>for</code> 里用的变量命名为 <code>i</code>？</h2><p>这是一个很好的问题。你记住一点，它诞生自人们的习惯。之前就说过，变量名称只会受到标识符命名规则的约束，所以取名这一点才是关键。我们最初经常使用到 <code>int</code> 类型来表示整数，除非万不得已才会调整类型。而在 <code>for</code> 循环里，我们常常使用 <code>int</code> 类型的变量作为循环的成员。而这个变量一般表示循环的量，所以它不太好取名。为了简单化处理，我们一般使用它的类型名称的首字母就直接作为了这个变量的名字。比如这里的 <code>int</code> 变量就直接叫做 <code>i</code>。包括后续会介绍到的嵌套循环，那么里面的变量就叫做 <code>j</code>，按着顺序排下来，从 <code>i</code> 开始，<code>i</code>、<code>j</code>、<code>k</code>、……。</p>
<p>当然，如果是一个字符类型的变量作为初始变量，那么一般就叫做 <code>c</code> 或者 <code>ch</code>，其它的变量按类型取名也都是一样的规则。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/csharp-default-interface/" title="C# 8 里的默认接口实现" itemprop="url">C# 8 里的默认接口实现</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T01:37:49.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="接口基础知识"><a href="#接口基础知识" class="headerlink" title="接口基础知识"></a>接口基础知识</h2><p>接口是一种面向对象编程 OOP 的语法机制，它和抽象类不同的地方在于，它需要你完全实现接口里给出的全部方法集合。</p>
<p>比如如下给定一个坐标对对象 <code>Point</code>，实现代码全部给出：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> row, <span class="keyword">int</span> column</span>)</span> =&gt; (Row, Column) = (row, column);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Row &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Column &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; (Row, Column).ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这些写法比较新，用的是 C# 6 提供的更多成员的 Lambda 实现模式以及 C# 7 给的元组模式来对位赋值，以及值元组类型 <code>ValueTuple&lt;...&gt;</code>。</p>
<p>显然，这个 API 太过于简单，我们还没有实现更多的东西。由于坐标对对象明显可以比较相等（只要行列的数值都相同，就可以认为坐标对对象是一样的），但我们为了后续可以告诉其它程序员，这个 API 可以提供比较和字典比较这些操作，我们需要实现 <code>IEquatable&lt;T&gt;</code> 接口来保证对象可以使用比较判断。</p>
<p>接着，设置好所有的重写方法和操作符重载：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Point : IEquatable&lt;Point&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> row, <span class="keyword">int</span> column</span>)</span> =&gt; (Row, Column) = (row, column);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Row &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Column &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span>? obj</span>)</span> =&gt; obj <span class="keyword">is</span> Point p &amp;&amp; Equals(p);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">Point other</span>)</span> =&gt; Row == other.Row &amp;&amp; Column == other.Column;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; (Row, Column).ToString();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span> =&gt; Row ^ Column;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point left, Point right) =&gt; left.Equals(right);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(Point left, Point right) =&gt; !left.Equals(right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先大致不用去看具体实现，因为我们这里的侧重点不是实现，而是接口。</p>
<p>当然，如果你不希望对方调用这个 <code>Equals</code> 方法的话，请把实现的方法改为显式实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> IEquatable&lt;Point&gt;.Equals(Point other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Row == other.Row &amp;&amp; Column == other.Column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>接口名.方法名</code> 来表示实现的接口，并且返回值前强制不加 <code>public</code>，因为接口里的方法在实现起来必然是 <code>public</code> 的，完全不必写出来。</p>
<h2 id="什么是默认接口实现？"><a href="#什么是默认接口实现？" class="headerlink" title="什么是默认接口实现？"></a>什么是默认接口实现？</h2><p>当我们需要的接口具有通用性，但又不是非要实现的话，我们就可以使用默认实现，类似于类里的虚方法。比如，我们完全可以使用给定的 <code>GetHashCode</code> 方法来判断对象是否数值上相等，于是我们就可以写一个接口，又不必实现，只需要这么写：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface IEquatableDefault&lt;in T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Default interface implementation.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">[MaybeNull] T other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> GetHashCode() == other.GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，我们就不必再每次都实现接口的方法了。把原来的 API 修改一下即可：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> Point : IEquatableDefault&lt;Point&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="keyword">int</span> row, <span class="keyword">int</span> column</span>)</span> =&gt; (Row, Column) = (row, column);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Row &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Column &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span>? obj</span>)</span> =&gt; obj <span class="keyword">is</span> Point p &amp;&amp; Equals(p);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">Point other</span>)</span> =&gt; ((IEquatableDefault&lt;Point&gt;)<span class="keyword">this</span>).Equals(other);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span> =&gt; (Row, Column).ToString();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">int</span> <span class="title">GetHashCode</span>(<span class="params"></span>)</span> =&gt; Row ^ Column;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(Point left, Point right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ((IEquatableDefault&lt;Point&gt;)left).Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> !=(Point left, Point right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !((IEquatableDefault&lt;Point&gt;)left).Equals(right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但请注意，接口默认的实现规则使得必须先把调用对象转为对应接口对象，然后才能调用。这是因为对象使用的默认方法实现，而实现机制要求你需要转换回接口，才能使用该方法，类似于显式实现的接口。</p>
<h2 id="重新实现接口"><a href="#重新实现接口" class="headerlink" title="重新实现接口"></a>重新实现接口</h2><h3 id="类重新实现基接口的成员"><a href="#类重新实现基接口的成员" class="headerlink" title="类重新实现基接口的成员"></a>类重新实现基接口的成员</h3><p>在前文给出的实现机制下，我们显然发现，这个 <code>GetHashCode</code> 写起来有点不太对，因为它直接异或运算得到的结果来比较，这一点不是很好。所以我们尝试去把原本接口里实现的方式进行修改。</p>
<p>我们尝试在 <code>Point</code> 里加入显式接口实现：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> IEquatableDefault&lt;Point&gt;.Equals(Point other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Row == other.Row &amp;&amp; Column == other.Column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一点和虚方法的重写不同，它不需要添加 <code>override</code> 关键字，因为它是属于接口层面的实现（之前的接口实现从来就没有写过 <code>override</code> 关键字，所以此时这里也是一样）。</p>
<p>然后，它就替换掉原本接口里的默认实现了。也就是说，如果我们尝试调用原本 API 的 <code>Equals</code> 方法，由于它调用的是接口的 <code>Equals</code> 方法的实现，而此时已经被重写，所以调用的实际上是上面这个重写后的显式接口实现的方法。</p>
<p>那么，原本接口内的方法就变成了类似于虚方法的机制了，当然，这只是”类似于“。</p>
<h3 id="接口重新实现基接口的成员"><a href="#接口重新实现基接口的成员" class="headerlink" title="接口重新实现基接口的成员"></a>接口重新实现基接口的成员</h3><p>下面来看另外一种情况。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface IEquatableDefault&lt;T&gt; : IEquatable&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> IEquatable&lt;T&gt;.Equals([AllowNull] T other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">is</span> <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> GetHashCode() == other.GetHashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的实现模式就可以把基类的 <code>Equals</code> 方法实现掉。不过这样的实现模式就不允许在类里重写方法了。因为显式接口实现是不允许重写的，否则将会产生如下的报错：</p>
<p><img src="error-info.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CS0539:</span><br><span class="line">&apos;Point.Equals(Point)&apos; in explicit interface declaration</span><br><span class="line">is not found among members of the interface that can be implemented.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从报错的编码就可以看出，实际上它并不是一种新的错误类型，而是之前的错误类型：不允许重写显式实现的方法。当你显式实现了一个接口里并不含有的方法时，就会产生这个错误，例如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">I</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Clx</span> : <span class="title">I</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> I.X() <span class="comment">// CS0539</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样便会产生 CS0539 错误。而从上面的文章示例可以看出，由于你显式实现的原接口 <code>IEquatable&lt;T&gt;</code> 的方法，所以类里就无法进行重写，因为这个显式实现并非 <code>IEquatableDefault&lt;T&gt;</code> 类里的元素（或者说，这个显式实现具有良好的封装性）。</p>
</blockquote>
<h2 id="使用其它访问修饰符成员的支持"><a href="#使用其它访问修饰符成员的支持" class="headerlink" title="使用其它访问修饰符成员的支持"></a>使用其它访问修饰符成员的支持</h2><p>当然，这一次默认接口实现的特性还添加了对其它访问修饰符成员的支持。你可以在接口里自行声明 <code>private</code>、<code>private protected</code>、<code>protected</code>、<code>protected internal</code>、<code>internal</code> 或 <code>public</code> 的默认接口成员的实现。不过，用法和前文介绍的默认接口实现的机制基本上一样，除了一点，就是访问修饰符的级别而已。</p>
<h2 id="静态成员的支持"><a href="#静态成员的支持" class="headerlink" title="静态成员的支持"></a>静态成员的支持</h2><p>除此之外，默认接口实现还支持静态成员。举个例子。类似于上文的 <code>Point</code> 对象，我们完全可以默认实现一个 <code>Parse</code> 执行的静态方法。</p>
<p>比方说，我们可以写一个模块，专门用于实现 <code>Point</code> 类型用字符串转换的解析操作，我们可以这么设计接口的 API。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPointParsable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">Parse</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> match = <span class="keyword">new</span> Regex(<span class="string">@"\(\d+,\s*\d+\)"</span>).Match(str);</span><br><span class="line">        <span class="keyword">if</span> (match.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> digitPair = <span class="keyword">new</span> Regex(<span class="string">@"\d+"</span>).Matches(match.Value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Point(</span><br><span class="line">                <span class="keyword">int</span>.Parse(digitPair[<span class="number">0</span>].Value),</span><br><span class="line">                <span class="keyword">int</span>.Parse(digitPair[<span class="number">1</span>].Value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"Parse failed."</span>, <span class="keyword">nameof</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">TryParse</span>(<span class="params"><span class="keyword">string</span> str, [NotNullWhen(<span class="literal">true</span></span>)] <span class="keyword">out</span> Point? result)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = Parse(str);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span></span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="keyword">default</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过调用的时候就只能这么书写了：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pt = IPointParsable.Parse(<span class="string">"(3, 5)"</span>);</span><br></pre></td></tr></table></figure>
<p>即使用 <code>接口名.静态方法名</code> 来调用。这一点确实有点让人不爽，还不如把方法直接写进结构里，哪怕在前期使用单独的静态类加静态方法，也可以使用 <code>静态类名.静态方法名</code> 依然可以解决，所以这个功能目前来说还不是很有用处。</p>
<h2 id="实现和重抽象化成员"><a href="#实现和重抽象化成员" class="headerlink" title="* 实现和重抽象化成员"></a>* 实现和重抽象化成员</h2><p>在官方给出的提案里，是提到了<strong>重写基默认接口成员的方法</strong>（Override）和<strong>重抽象</strong>（Re-abstraction）的内容，不过在目前的 C# 8 里全部尚不可以使用。所以这个坑就只能等到语法层面更新的时候才能继续往下写了。现在先给出一点概念。</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写基接口成员的方法，官方给出的方案是通过 <code>override</code> 的方式提供显式和隐式实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">"IA.M"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IB</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">void</span> IA.M() =&gt; Console.WriteLine(<span class="string">"IB.M"</span>); <span class="comment">// explicitly named</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IC</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">override</span> <span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">"IC.M"</span>); <span class="comment">// implicitly named</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上述示例里，<code>IA</code> 接口里有一个实现，在派生接口里，都得到了重写实现，它们都加上了 <code>override</code> 关键字，即使是显式实现的。</p>
<blockquote>
<p>不过从前文可以得知，目前想要实现基接口里的成员，必须使用显式接口实现，隐式目前还不支持。</p>
</blockquote>
<h3 id="重抽象"><a href="#重抽象" class="headerlink" title="重抽象"></a>重抽象</h3><p>你甚至支持在派生接口里重新把原本实现的操作再次抽象掉，这样在继续派生的话，就必须给出实现。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">M</span>(<span class="params"></span>)</span> &#123; WriteLine(<span class="string">"IA.M"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IB</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="keyword">void</span> IA.M();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">C</span> : <span class="title">IB</span> &#123; &#125; <span class="comment">// error: class 'C' does not implement 'IA.M'.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过，目前的重抽象是否被允许，还是一个遗留问题（Open issue），甚至 <code>IB</code> 接口里的显式实现到底应该写作 <code>abstract override</code> 还是 <code>abstract</code> 现在还没有给出结论。</p>
</blockquote>
<h3 id="菱形结构"><a href="#菱形结构" class="headerlink" title="菱形结构"></a>菱形结构</h3><p>当允许了上述的逻辑时，就必然会产生菱形结构：即某个类型继承自两个不同的接口，但两个不同的接口又同时实现了同一个接口的行为，且实现方式不同。</p>
<p>那么此时，这个所谓的“某个类型”到底是取哪一个接口的实现行为才应该是合理的呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Method</span>(<span class="params"></span>)</span> =&gt; Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(IA)&#125;</span>.<span class="subst">&#123;<span class="keyword">nameof</span>(Method)&#125;</span>()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IB</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IA.Method() =&gt; Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(IB)&#125;</span>.<span class="subst">&#123;<span class="keyword">nameof</span>(Method)&#125;</span>()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IC</span> : <span class="title">IA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> IA.Method() =&gt; Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">nameof</span>(IC)&#125;</span>.<span class="subst">&#123;<span class="keyword">nameof</span>(Method)&#125;</span>()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Class</span> : <span class="title">IB</span>, <span class="title">IC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ???</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，<code>Class</code> 里会报错，报错信息是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CS8705:</span><br><span class="line">Interface memeber &apos;IA.Method()&apos; does not have a most specific implementation.</span><br><span class="line">Neither &apos;IB.IA.Method()&apos;, nor &apos;IC.IA.Method()&apos; are most specific.</span><br></pre></td></tr></table></figure>
<p>提示信息的意思是，你现在使用的 <code>Class</code> 类实现了两个相似的接口 <code>IB</code> 和 <code>IC</code>，而它们全部显式实现了 <code>IA</code> 接口里的 <code>Method</code> 方法。但问题在于，它们都是显式接口实现，这都不是“真正实现”的方法。这样确实也防止了菱形结构的模棱两可的情况。</p>
<h3 id="该不该加-virtual-关键字？"><a href="#该不该加-virtual-关键字？" class="headerlink" title="该不该加 virtual 关键字？"></a>该不该加 <code>virtual</code> 关键字？</h3><p>前文用到的实现哪怕加入了 <code>override</code> 关键字来表达重写，但依旧不知道是否需要添加 <code>virtual</code> 关键字支持。从目前来说，在 IDE 里你完全可以添加 <code>virtual</code> 关键字，但实际上这个关键字加了当没加。因为加不加，都可以允许你显式实现接口成员，因此没有区别。但以后就不一定了，因为可能会出现 <code>override</code> 的情况，这样就可能出现前文提到了隐式实现模式和重抽象，这一点就完全可能会出现和体现 <code>virtual</code> 的功能了。</p>
<h3 id="指定基接口调用和实现"><a href="#指定基接口调用和实现" class="headerlink" title="指定基接口调用和实现"></a>指定基接口调用和实现</h3><p>在重写和重抽象的时候，我们可以使用 <code>base</code> 关键字指明你调用的是哪个基接口的对象的成员，不过目前也不支持，貌似等到 C# 9 才会出现了。目前有两种调用机制：<code>base(接口名).成员名</code> 和 <code>base&lt;接口名&gt;.成员名</code>。 </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://sunnie-shine.github.io/2019/11/08/common-01-nullable-types/#可空引用类型">可空引用类型</a>（博文）</li>
<li><a href="https://github.com/dotnet/csharplang/blob/master/proposals/csharp-8.0/default-interface-methods.md" target="_blank" rel="noopener">默认接口实现的提案</a>（GitHub “CSharplang” repo 里的提案）</li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/misc/cs0539" target="_blank" rel="noopener">CS0539 错误</a></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C%E2%99%AF/">C♯</a>►<a class="article-category-link" href="/categories/C%E2%99%AF/C%E2%99%AF-%E8%AF%AD%E6%B3%95/">C♯.语法</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C♯/">C♯</a><a href="/tags/C♯-8/">C♯ 8</a><a href="/tags/TODO/">TODO</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>



   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/11/19/clang-06-do-while-loop/" title="C 语言语法系列（6）：do-while 语句" itemprop="url">C 语言语法系列（6）：do-while 语句</a>
    
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="向向" target="_blank" itemprop="author">向向</a>
		
  <p class="article-time">
    <time datetime="2019-11-19T01:13:18.000Z" itemprop="datePublished"> 发表于 2019-11-19</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="改下上一个例子的代码"><a href="#改下上一个例子的代码" class="headerlink" title="改下上一个例子的代码"></a>改下上一个例子的代码</h2><p>在求得 1 到 100 的和的计算结果的时候，我们明显知道 <code>i</code> 第一次的初始数值（即 1）是不可能超过 100 的，所以第一次完全不必判断这个条件。</p>
<p>正是因为这样，我们便产生了 <code>do-while</code> 语句。在提及代码的写法格式之前，我们先来看一下它的执行逻辑，如下图所示。</p>
<p><img src="do-while-loop-example.png" alt=""></p>
<h2 id="do-while-（循环）语句"><a href="#do-while-（循环）语句" class="headerlink" title="do-while （循环）语句"></a><code>do-while</code> （循环）语句</h2><p>下面我们来看一下 <code>do-while</code> 语句的执行逻辑和代码规范。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    S += i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>这种写法把条件进行了后置处理，所以执行 <code>S += i++;</code> 操作是无条件都会执行至少一次的。然后执行后才会判断数值 <code>i</code> 是否不超过 100。</p>
<p>不过，此时的大括号最好就不要省略了，虽然编译器依旧允许你这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    S += i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>甚至</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> S += i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>, S = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> S += i++; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>这两种写法虽然没什么问题，不过不建议这么书写是因为代码不太好看。</p>
<p>一定要注意，语法格式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    loopExecutingSentence;</span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>
<p>里面的末端，写了括号和条件 <code>condition</code> 后，还要加上分号，标记整体是一个语句的结束。</p>
<h2 id="while-和-do-while-的异同"><a href="#while-和-do-while-的异同" class="headerlink" title="while 和 do-while 的异同"></a><code>while</code> 和 <code>do-while</code> 的异同</h2><p>从两种书写格式来看，<code>while</code> 的条件是前置的，而 <code>do-while</code> 的条件则是后置的，这使得条件判断的位置不同。C 语言的执行是从上到下的，所以遇到这些条件的机会和方式不同，<code>while</code> 是不论如何都会先判断条件，当条件成立的时候执行对应大括号里的内容，但条件如果不满足，则不会执行内部的语句。所以 <code>while</code> 语句的重复执行部分很有可能一次都不会去执行；但 <code>do-while</code> 不一样，它的条件被放到后面，这使得重复执行的代码不论如何都会先被执行一次，然后才会判断条件。所以 <code>do-while</code> 语句的重复执行部分最少都会执行一次。</p>
<p>除此之外，它们并无什么不同。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/C/">C</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/">C.语法</a>►<a class="article-category-link" href="/categories/C/C-%E8%AF%AD%E6%B3%95/C-%E8%AF%AD%E6%B3%95-%E6%95%99%E7%A8%8B/">C.语法.教程</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>




  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/">上一页 ↑</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">下一页 ↓</a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="Sunnie-Shine" data-theme="medium"></div>
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>



  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/C♯/" title="C♯">C♯<sup>25</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>16</sup></a></li>
			
		
			
				<li><a href="/tags/LINQ/" title="LINQ">LINQ<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/数学/" title="数学">数学<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/SQL/" title="SQL">SQL<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-编译器生成/" title="C♯.编译器生成">C♯.编译器生成<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/数独/" title="数独">数独<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-8/" title="C♯ 8">C♯ 8<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/正则表达式/" title="正则表达式">正则表达式<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/安卓/" title="安卓">安卓<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ASP/" title="ASP">ASP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/诗词/" title="诗词">诗词<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-3/" title="C♯ 3">C♯ 3<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C♯-6/" title="C♯ 6">C♯ 6<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/并发/" title="并发">并发<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/TODO/" title="TODO">TODO<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GDI/" title="GDI+">GDI+<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://sunniesudoku.cn/" target="_blank" title="向向的数独文档库">向向的数独文档库</a>
            
          </li>
        
          <li>
            
            	<a href="http://tieba.baidu.com/f?kw=%CA%FD%B6%C0" target="_blank" title="数独贴吧">数独贴吧</a>
            
          </li>
        
          <li>
            
            	<a href="https://space.bilibili.com/23736703" target="_blank" title="Bilibili">Bilibili</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello, I&#39;m Sunnie. <br/>
			This is my blog.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/Sunnie-Shine" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/Sunnie-Shine" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
	</div>
			
		

		<p class="copyright">
		Copyright © 2019 
		
		<a href="/about" target="_blank" title="向向">向向</a>
		
		<br />
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a>
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
  });
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript"
  async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
